// Genesis Kernel - Entry Point
// Microkernel for Genesis OS
// Phase 8: Capability-Based Security

// ============================================================
// Constants
// ============================================================

const VGA_BUFFER: i64 = 0xB8000;
const VGA_WIDTH: i64 = 80;
const VGA_HEIGHT: i64 = 25;

// VGA colors
const COLOR_BLACK: i64 = 0;
const COLOR_RED: i64 = 4;
const COLOR_GREEN: i64 = 10;
const COLOR_YELLOW: i64 = 14;
const COLOR_WHITE: i64 = 15;

// Memory constants (all as i64 to work with pointer arithmetic)
const PAGE_SIZE: i64 = 4096;
const PMM_BITMAP_ADDR: i64 = 0x400000;    // 4MB - Bitmap storage (32KB)
const PMM_STATE_ADDR: i64 = 0x408000;     // 4MB + 32KB - PMM state
const MULTIBOOT_PTR_ADDR: i64 = 0x500;    // Multiboot info pointer (set by boot.asm)

// Multiboot flags
const MB_FLAG_MMAP: i64 = 64;

// Interrupt constants
const IDT_ENTRIES: i64 = 256;
const IDT_ENTRY_SIZE: i64 = 16;
const IDT_ADDR: i64 = 0x410000;           // IDT table
const IDTR_ADDR: i64 = 0x411000;          // IDTR structure
const TICK_COUNT_ADDR: i64 = 0x412000;    // Timer tick counter

// PIC ports
const PIC1_CMD: i64 = 0x20;
const PIC1_DATA: i64 = 0x21;
const PIC2_CMD: i64 = 0xA0;
const PIC2_DATA: i64 = 0xA1;
const PIC_EOI: i64 = 0x20;

// PIT ports
const PIT_CHANNEL0: i64 = 0x40;
const PIT_CMD: i64 = 0x43;
const PIT_DIVISOR: i64 = 11932;  // ~100 Hz

// Serial port
const COM1: i64 = 0x3F8;

// Gate types
const GATE_INTERRUPT: i64 = 0x8E;
const KERNEL_CS: i64 = 0x08;

// User mode segment selectors (DPL=3, RPL=3)
const USER_CS: i64 = 0x1B;    // 0x18 | 3 (User Code64)
const USER_DS: i64 = 0x23;    // 0x20 | 3 (User Data)
const TSS_SEL: i64 = 0x28;    // TSS selector

// TSS size (structure from boot.asm, address obtained at runtime)
const TSS_SIZE: i64 = 104;            // TSS size in bytes

// GDT TSS descriptor offset
const GDT_TSS_OFFSET: i64 = 0x28;     // TSS descriptor at offset 0x28

// Process management
const MAX_PROCS: i64 = 8;
const PCB_SIZE: i64 = 64;
const PROC_TABLE_ADDR: i64 = 0x420000;    // PCB array
const CURRENT_PID_ADDR: i64 = 0x421000;   // Current process ID
const NUM_PROCS_ADDR: i64 = 0x421008;     // Number of active processes
const SCHED_ENABLED_ADDR: i64 = 0x421010; // Scheduler enabled flag
const PROC_STACK_BASE: i64 = 0x500000;    // Base for user process stacks
const PROC_STACK_SIZE: i64 = 0x4000;      // 16KB per process
const KSTACK_BASE: i64 = 0x600000;        // Base for kernel stacks (ring 0)
const KSTACK_SIZE: i64 = 0x2000;          // 8KB per kernel stack

// PCB offsets (Process Control Block structure)
const PCB_PID: i64 = 0;           // Process ID
const PCB_STATE: i64 = 8;         // Process state
const PCB_RSP: i64 = 16;          // Saved RSP (kernel stack pointer)
const PCB_STACK_BASE: i64 = 24;   // User stack base (for ring 3 processes)
const PCB_KSTACK_BASE: i64 = 32;  // Kernel stack base (for ring 0 operations)
const PCB_FLAGS: i64 = 40;        // Process flags (bit 0 = user mode)

// Process flags
const PROC_FLAG_USER: i64 = 1;    // Process runs in user mode (ring 3)

// Process states
const PROC_UNUSED: i64 = 0;
const PROC_READY: i64 = 1;
const PROC_RUNNING: i64 = 2;

// Test process counters (persistent memory)
const PROC_A_COUNTER: i64 = 0x422000;
const PROC_B_COUNTER: i64 = 0x422008;

// Context switch RSP (set by isr_handler, read by isr.asm)
const SWITCH_RSP_ADDR: i64 = 0x422010;

// ============================================================
// System Call Constants
// ============================================================

const SYS_YIELD: i64 = 0;      // Yield CPU to scheduler
const SYS_GETPID: i64 = 1;     // Get current process ID
const SYS_PRINT: i64 = 2;      // Print character to serial
const SYS_SEND: i64 = 3;       // Send message to process
const SYS_RECV: i64 = 4;       // Receive message from queue
const SYS_EXIT: i64 = 5;       // Exit process
const SYS_OPEN: i64 = 6;       // Open file (returns fd)
const SYS_READ: i64 = 7;       // Read from file
const SYS_WRITE: i64 = 8;      // Write to file
const SYS_CLOSE: i64 = 9;      // Close file descriptor
const SYS_FSTAT: i64 = 10;     // Get file status (size)

// Syscall result storage (returned in RAX after syscall)
const SYSCALL_RET_ADDR: i64 = 0x422020;

// ============================================================
// IPC Message Constants
// ============================================================

const MSG_SIZE: i64 = 32;          // Message size (32 bytes)
const MSG_QUEUE_SIZE: i64 = 8;     // Messages per process queue
const MSG_QUEUE_ADDR: i64 = 0x430000;  // Message queue base address
const MSG_QUEUE_ENTRY_SIZE: i64 = 256; // Per-process queue size (8 * 32)

// Message structure offsets
const MSG_SRC_PID: i64 = 0;        // Source process ID
const MSG_DATA: i64 = 8;           // Message data (24 bytes)

// Message queue header offsets (per process)
const MQ_HEAD: i64 = 0;            // Queue head index
const MQ_TAIL: i64 = 8;            // Queue tail index
const MQ_COUNT: i64 = 16;          // Number of messages in queue
const MQ_MSGS: i64 = 24;           // Message array start

// ============================================================
// VFS and RAM Disk Constants
// ============================================================

// VFS Server PID (fixed)
const VFS_SERVER_PID: i64 = 3;

// RAM Disk memory layout
const RAMFS_BASE: i64 = 0x700000;           // RAM disk base address
const RAMFS_SUPERBLOCK: i64 = 0x700000;     // Superblock (512 bytes)
const RAMFS_FILE_TABLE: i64 = 0x700200;     // File table (2KB)
const RAMFS_DATA_BLOCKS: i64 = 0x701000;    // Data blocks start

// RAM Disk limits
const RAMFS_MAX_FILES: i64 = 32;            // Maximum number of files
const RAMFS_FILE_ENTRY_SIZE: i64 = 64;      // Size of file table entry
const RAMFS_BLOCK_SIZE: i64 = 512;          // Data block size
const RAMFS_MAX_BLOCKS: i64 = 256;          // Maximum data blocks (128KB)
const RAMFS_NAME_MAX: i64 = 15;             // Max filename length

// Superblock offsets (512 bytes total)
const SB_MAGIC: i64 = 0;                    // Magic number (8 bytes)
const SB_VERSION: i64 = 8;                  // Version (8 bytes)
const SB_TOTAL_BLOCKS: i64 = 16;            // Total blocks (8 bytes)
const SB_FREE_BLOCKS: i64 = 24;             // Free blocks (8 bytes)
const SB_TOTAL_FILES: i64 = 32;             // Max files (8 bytes)
const SB_USED_FILES: i64 = 40;              // Used file slots (8 bytes)

// File entry offsets (64 bytes per entry)
const FE_FLAGS: i64 = 0;                    // Flags: 0=unused, 1=file, 2=dir
const FE_NAME: i64 = 8;                     // Filename (16 bytes)
const FE_SIZE: i64 = 24;                    // File size (8 bytes)
const FE_BLOCK: i64 = 32;                   // First data block index (8 bytes)
const FE_BLOCKS: i64 = 40;                  // Number of blocks used (8 bytes)
const FE_RESERVED: i64 = 48;                // Reserved (16 bytes)

// File flags
const FILE_UNUSED: i64 = 0;
const FILE_REGULAR: i64 = 1;
const FILE_DIRECTORY: i64 = 2;

// VFS IPC Message Types (first byte of message data)
const VFS_OPEN: i64 = 1;                    // Open file: {type, mode, name[14]}
const VFS_READ: i64 = 2;                    // Read file: {type, fd, offset(2), size(2)}
const VFS_WRITE: i64 = 3;                   // Write file: {type, fd, size, data[13]}
const VFS_CLOSE: i64 = 4;                   // Close file: {type, fd}
const VFS_STAT: i64 = 5;                    // Get file info: {type, fd}
const VFS_CREATE: i64 = 6;                  // Create file: {type, mode, name[14]}
const VFS_DELETE: i64 = 7;                  // Delete file: {type, name[15]}
const VFS_LIST: i64 = 8;                    // List files: {type, index}

// VFS Response Types
const VFS_OK: i64 = 0;                      // Success
const VFS_ERR_NOT_FOUND: i64 = -1;          // File not found
const VFS_ERR_EXISTS: i64 = -2;             // File already exists
const VFS_ERR_FULL: i64 = -3;               // Filesystem full
const VFS_ERR_INVALID: i64 = -4;            // Invalid operation
const VFS_ERR_NO_FD: i64 = -5;              // No free file descriptors

// File Descriptor Constants
const MAX_FDS_PER_PROC: i64 = 8;            // Max open files per process
const FD_TABLE_ADDR: i64 = 0x440000;        // File descriptor tables base
const FD_ENTRY_SIZE: i64 = 16;              // Size per FD entry
const FD_TABLE_SIZE: i64 = 128;             // Per-process FD table (8*16)

// FD Entry offsets
const FD_FILE_IDX: i64 = 0;                 // File table index (-1 if closed)
const FD_OFFSET: i64 = 8;                   // Current read/write offset

// Console Server PID
const CONSOLE_SERVER_PID: i64 = 4;

// Keyboard buffer
const KB_BUFFER_ADDR: i64 = 0x450000;       // Keyboard input buffer
const KB_BUFFER_SIZE: i64 = 256;            // Buffer size
const KB_HEAD_ADDR: i64 = 0x450100;         // Buffer head index
const KB_TAIL_ADDR: i64 = 0x450108;         // Buffer tail index

// RAMFS Magic number: "GENVFS\0\0"
const RAMFS_MAGIC: i64 = 0x0053465F56454E47;

// ============================================================
// Capability-Based Security Constants
// ============================================================

// Capability table memory layout
const CAP_TABLE_ADDR: i64 = 0x460000;         // Capability tables base
const MAX_CAPS_PER_PROC: i64 = 16;            // Max capabilities per process
const CAP_ENTRY_SIZE: i64 = 24;               // Size per capability entry
const CAP_TABLE_SIZE: i64 = 384;              // Per-process cap table (16*24)

// Capability entry offsets (24 bytes per entry)
const CAP_TYPE: i64 = 0;                      // Capability type (8 bytes)
const CAP_TARGET: i64 = 8;                    // Target identifier (8 bytes)
const CAP_RIGHTS: i64 = 16;                   // Rights bitmask (8 bytes)

// Capability types
const CAP_TYPE_UNUSED: i64 = 0;               // Empty slot
const CAP_TYPE_IPC: i64 = 1;                  // IPC send/recv to process
const CAP_TYPE_FILE: i64 = 2;                 // File access capability
const CAP_TYPE_MEM: i64 = 3;                  // Memory region capability
const CAP_TYPE_ROOT: i64 = 4;                 // Root (can create any cap)

// Capability rights bitmask
const CAP_RIGHT_READ: i64 = 1;                // Can read
const CAP_RIGHT_WRITE: i64 = 2;               // Can write
const CAP_RIGHT_SEND: i64 = 4;                // Can send IPC
const CAP_RIGHT_RECV: i64 = 8;                // Can receive IPC
const CAP_RIGHT_DERIVE: i64 = 16;             // Can derive weaker cap
const CAP_RIGHT_DELEGATE: i64 = 32;           // Can transfer to another proc
const CAP_RIGHT_ALL: i64 = 63;                // All rights

// Capability syscalls
const SYS_CAP_CREATE: i64 = 11;               // Create capability (needs ROOT)
const SYS_CAP_DERIVE: i64 = 12;               // Derive weaker capability
const SYS_CAP_GRANT: i64 = 13;                // Transfer cap via IPC
const SYS_CAP_REVOKE: i64 = 14;               // Revoke a capability
const SYS_CAP_LIST: i64 = 15;                 // List capabilities

// Capability error codes
const CAP_ERR_NONE: i64 = 0;                  // Success
const CAP_ERR_DENIED: i64 = -10;              // Permission denied
const CAP_ERR_NOT_FOUND: i64 = -11;           // Capability not found
const CAP_ERR_FULL: i64 = -12;                // Capability table full
const CAP_ERR_INVALID: i64 = -13;             // Invalid capability

// ============================================================
// Bitwise Operations Helper Functions
// ============================================================

fn shl_u64(value: u64, shift: u64) -> u64 {
    let mut result = value;
    result <<= shift;
    result
}

fn shr_u64(value: u64, shift: u64) -> u64 {
    let mut result = value;
    result >>= shift;
    result
}

fn bit_and(a: u64, b: u64) -> u64 {
    let mut result = a;
    result &= b;
    result
}

fn bit_or(a: u64, b: u64) -> u64 {
    let mut result = a;
    result |= b;
    result
}

fn bit_not(a: u64) -> u64 {
    let mut result = a;
    result ^= 0xFFFFFFFFFFFFFFFF;
    result
}

// ============================================================
// I/O Port Functions
// ============================================================

fn outb(port: i64, value: i64) {
    unsafe {
        asm!(
            "out %al, %dx",
            in("dx") port,
            in("al") value,
            options(nomem, nostack, att_syntax)
        );
    }
}

fn inb(port: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "in %dx, %al",
            in("dx") port,
            lateout("al") result,
            options(nomem, nostack, att_syntax)
        );
    }
    result
}

fn io_wait() {
    outb(0x80, 0);
}

// ============================================================
// VGA Text Mode
// ============================================================

fn vga_color(fg: i64, bg: i64) -> u8 {
    let mut result: u8 = (bg * 16) as u8;
    result |= fg as u8;
    result
}

fn vga_write_char(x: i64, y: i64, ch: i64, color: u8) {
    let offset = (y * VGA_WIDTH + x) * 2;
    let addr = VGA_BUFFER + offset;
    let ptr = addr as *mut u8;

    unsafe {
        volatile_write_u8(ptr, ch as u8);
        let color_ptr = (addr + 1) as *mut u8;
        volatile_write_u8(color_ptr, color);
    }
}

fn vga_clear() {
    let color = vga_color(COLOR_WHITE, COLOR_BLACK);
    let mut i: i64 = 0;
    while i < VGA_WIDTH * VGA_HEIGHT {
        vga_write_char(i % VGA_WIDTH, i / VGA_WIDTH, 32, color);
        i = i + 1;
    }
}

fn hex_digit(n: u64) -> i64 {
    if n < 10 {
        (48 + n) as i64   // '0' - '9'
    } else {
        (65 + n - 10) as i64  // 'A' - 'F'
    }
}

fn vga_write_hex(x: i64, y: i64, value: u64, color: u8) {
    // "0x" prefix
    vga_write_char(x, y, 48, color);      // '0'
    vga_write_char(x + 1, y, 120, color); // 'x'

    // Write 16 hex digits
    let mut i: i64 = 0;
    while i < 16 {
        let shift = (60 - i * 4) as u64;
        let nibble = bit_and(shr_u64(value, shift), 0xF);
        vga_write_char(x + 2 + i, y, hex_digit(nibble), color);
        i = i + 1;
    }
}

fn vga_write_dec(x: i64, y: i64, value: u64, color: u8) -> i64 {
    if value == 0 {
        vga_write_char(x, y, 48, color);
        return 1;
    }

    // Count digits
    let mut temp = value;
    let mut count: i64 = 0;
    while temp > 0 {
        temp = temp / 10;
        count = count + 1;
    }

    // Write in reverse
    temp = value;
    let mut i: i64 = count - 1;
    while i >= 0 {
        let digit = (48 + (temp % 10)) as i64;
        vga_write_char(x + i, y, digit, color);
        temp = temp / 10;
        i = i - 1;
    }

    count
}

fn vga_write_char_color(x: i64, y: i64, ch: i64, color: i64) {
    let offset = (y * VGA_WIDTH + x) * 2;
    let addr = VGA_BUFFER + offset;
    unsafe {
        let ptr = addr as *mut u8;
        volatile_write_u8(ptr, ch as u8);
        let color_ptr = (addr + 1) as *mut u8;
        volatile_write_u8(color_ptr, color as u8);
    }
}

fn vga_write_hex_byte(x: i64, y: i64, value: u64, color: i64) {
    let high = bit_and(shr_u64(value, 4), 0xF);
    let low = bit_and(value, 0xF);

    let ch_high: i64 = if high < 10 { 48 + (high as i64) } else { 55 + (high as i64) };
    let ch_low: i64 = if low < 10 { 48 + (low as i64) } else { 55 + (low as i64) };

    vga_write_char_color(x, y, ch_high, color);
    vga_write_char_color(x + 1, y, ch_low, color);
}

// ============================================================
// Serial Port (COM1)
// ============================================================

fn serial_out(ch: i64) {
    outb(COM1, ch);
}

// Output 8 hex digits (32 bits)
fn serial_hex32(value: u64) {
    serial_out(48);  // '0'
    serial_out(120); // 'x'

    let mut val = value;

    let mut i: i64 = 0;
    while i < 8 {
        let mut nibble: u64 = 0;
        nibble = val / 0x10000000;

        let chr: i64 = if nibble < 10 {
            48 + (nibble as i64)
        } else {
            55 + (nibble as i64)
        };

        outb(COM1, chr);

        val = val * 16;
        val = val % 0x100000000;

        i = i + 1;
    }
}

fn serial_hex(value: u64) {
    serial_hex32(value % 0x100000000);
}

fn serial_hex64(value: u64) {
    serial_out(48);  // '0'
    serial_out(120); // 'x'

    let mut i: i64 = 60;
    while i >= 0 {
        let nibble = bit_and(shr_u64(value, i as u64), 0xF) as i64;
        let ch: i64 = if nibble < 10 { 48 + nibble } else { 55 + nibble };
        serial_out(ch);
        i = i - 4;
    }
}

fn serial_newline() {
    serial_out(10);
}

// ============================================================
// CPU Control
// ============================================================

fn cli() {
    unsafe { asm!("cli", options(nomem, nostack)); }
}

fn sti() {
    unsafe { asm!("sti", options(nomem, nostack)); }
}

fn hlt() {
    unsafe { asm!("hlt", options(nomem, nostack)); }
}

// ============================================================
// Memory Access Helpers
// ============================================================

fn read_u32_at(base: i64, offset: i64) -> u32 {
    let addr = base + offset;
    let mut result: u32 = 0;
    unsafe {
        asm!(
            "movl (%rcx), %eax",
            in("rcx") addr,
            lateout("eax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn read_u64_at(base: i64, offset: i64) -> u32 {
    let addr = base + offset;
    let mut result: u32 = 0;
    unsafe {
        asm!(
            "movl (%rcx), %eax",
            in("rcx") addr,
            lateout("eax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn write_u64_at(base: i64, offset: i64, value: u64) {
    let addr = base + offset;
    unsafe {
        asm!(
            "movq %rax, (%rcx)",
            in("rcx") addr,
            in("rax") value,
            options(nostack, att_syntax)
        );
    }
}

fn read_u64_addr(addr: i64) -> u64 {
    let mut result: u64 = 0;
    unsafe {
        asm!(
            "movq (%rcx), %rax",
            in("rcx") addr,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn write_u64_addr(addr: i64, value: u64) {
    unsafe {
        asm!(
            "movq %rax, (%rcx)",
            in("rcx") addr,
            in("rax") value,
            options(nostack, att_syntax)
        );
    }
}

fn write_u16_addr(addr: i64, value: i64) {
    unsafe {
        asm!(
            "movw %ax, (%rcx)",
            in("rcx") addr,
            in("ax") value,
            options(nostack, att_syntax)
        );
    }
}

fn write_u32_addr(addr: i64, value: i64) {
    unsafe {
        asm!(
            "movl %eax, (%rcx)",
            in("rcx") addr,
            in("eax") value,
            options(nostack, att_syntax)
        );
    }
}

// ============================================================
// Physical Memory Manager
// ============================================================

fn pmm_init_bitmap() {
    let mut offset: i64 = 0;
    while offset < 32768 {
        write_u64_at(PMM_BITMAP_ADDR, offset, 0xFFFFFFFFFFFFFFFF);
        offset = offset + 8;
    }
}

fn pmm_init(max_addr: u64) {
    pmm_init_bitmap();

    let max_pages = max_addr / (PAGE_SIZE as u64);
    write_u64_at(PMM_STATE_ADDR, 0, max_pages);
    write_u64_at(PMM_STATE_ADDR, 8, 0);
    write_u64_at(PMM_STATE_ADDR, 16, max_addr);
}

fn pmm_mark_free(base: u64, length: u64) {
    let page_size = PAGE_SIZE as u64;
    let start_page = (base + page_size - 1) / page_size;
    let end_page = (base + length) / page_size;

    if start_page >= end_page {
        return;
    }

    let mut free_count: u64 = 0;
    let mut page = start_page;

    while page < end_page {
        let page_addr = page * page_size;
        if page_addr >= 0x800000 {
            let idx = page / 64;
            let bit = page % 64;
            let bitmap_offset = (idx * 8) as i64;

            if idx < 4096 {
                let current = read_u64_at(PMM_BITMAP_ADDR, bitmap_offset) as u64;
                let mask = shl_u64(1, bit);

                if bit_and(current, mask) != 0 {
                    write_u64_at(PMM_BITMAP_ADDR, bitmap_offset, bit_and(current, bit_not(mask)));
                    free_count = free_count + 1;
                }
            }
        }
        page = page + 1;
    }

    let current_free = read_u64_at(PMM_STATE_ADDR, 8) as u64;
    write_u64_at(PMM_STATE_ADDR, 8, current_free + free_count);
}

fn pmm_alloc_page() -> u64 {
    let mut idx: u64 = 0;

    while idx < 4096 {
        let bitmap_offset = (idx * 8) as i64;
        let entry = read_u64_at(PMM_BITMAP_ADDR, bitmap_offset) as u64;

        if entry != 0xFFFFFFFFFFFFFFFF {
            let mut bit: u64 = 0;
            while bit < 64 {
                let mask = shl_u64(1, bit);
                if bit_and(entry, mask) == 0 {
                    write_u64_at(PMM_BITMAP_ADDR, bitmap_offset, bit_or(entry, mask));

                    let current_free = read_u64_at(PMM_STATE_ADDR, 8) as u64;
                    if current_free > 0 {
                        write_u64_at(PMM_STATE_ADDR, 8, current_free - 1);
                    }

                    let page = idx * 64 + bit;
                    return page * (PAGE_SIZE as u64);
                }
                bit = bit + 1;
            }
        }
        idx = idx + 1;
    }

    0
}

fn pmm_free_page(addr: u64) {
    if addr == 0 {
        return;
    }

    let page_size = PAGE_SIZE as u64;
    let page = addr / page_size;
    let idx = page / 64;
    let bit = page % 64;

    if idx >= 4096 {
        return;
    }

    let bitmap_offset = (idx * 8) as i64;
    let current = read_u64_at(PMM_BITMAP_ADDR, bitmap_offset) as u64;
    let mask = shl_u64(1, bit);

    if bit_and(current, mask) != 0 {
        write_u64_at(PMM_BITMAP_ADDR, bitmap_offset, bit_and(current, bit_not(mask)));

        let current_free = read_u64_at(PMM_STATE_ADDR, 8) as u64;
        write_u64_at(PMM_STATE_ADDR, 8, current_free + 1);
    }
}

fn pmm_get_free_pages() -> u64 {
    read_u64_at(PMM_STATE_ADDR, 8) as u64
}

// ============================================================
// Multiboot Parsing
// ============================================================

fn parse_multiboot(mb_info_addr: i64) -> u64 {
    let flags = read_u32_at(mb_info_addr, 0) as u64;
    let mmap_flag = MB_FLAG_MMAP as u64;

    if bit_and(flags, mmap_flag) == 0 {
        let mem_kb = read_u32_at(mb_info_addr, 8);
        return (mem_kb as u64 + 1024) * 1024;
    }

    let mmap_length = read_u32_at(mb_info_addr, 44);
    let mmap_addr = read_u32_at(mb_info_addr, 48) as i64;

    let mut highest: u64 = 0;
    let mut offset: i64 = 0;

    while offset < (mmap_length as i64) {
        let entry_ptr = mmap_addr + offset;
        let entry_size = read_u32_at(entry_ptr, 0);

        let entry_type = read_u32_at(entry_ptr, 20);

        if entry_type == 1 {
            let base_low = read_u32_at(entry_ptr, 4);
            let base_high = read_u32_at(entry_ptr, 8);
            let len_low = read_u32_at(entry_ptr, 12);
            let len_high = read_u32_at(entry_ptr, 16);

            let base = (base_high as u64) * 0x100000000 + (base_low as u64);
            let length = (len_high as u64) * 0x100000000 + (len_low as u64);

            let end = base + length;
            if end > highest {
                highest = end;
            }

            pmm_mark_free(base, length);
        }

        offset = offset + (entry_size as i64) + 4;
    }

    highest
}

// ============================================================
// Memory Management Initialization
// ============================================================

fn init_memory(mb_info_addr: i64) -> bool {
    let green = vga_color(COLOR_GREEN, COLOR_BLACK);
    let white = vga_color(COLOR_WHITE, COLOR_BLACK);
    let yellow = vga_color(COLOR_YELLOW, COLOR_BLACK);

    // Line 2: "PMM init..."
    vga_write_char(0, 2, 80, white);   // P
    vga_write_char(1, 2, 77, white);   // M
    vga_write_char(2, 2, 77, white);   // M
    vga_write_char(3, 2, 32, white);   // space
    vga_write_char(4, 2, 105, white);  // i
    vga_write_char(5, 2, 110, white);  // n
    vga_write_char(6, 2, 105, white);  // i
    vga_write_char(7, 2, 116, white);  // t

    pmm_init(0x40000000);

    let max_addr = parse_multiboot(mb_info_addr);

    // Line 3: "Max: 0x..."
    vga_write_char(0, 3, 77, white);   // M
    vga_write_char(1, 3, 97, white);   // a
    vga_write_char(2, 3, 120, white);  // x
    vga_write_char(3, 3, 58, white);   // :
    vga_write_char(4, 3, 32, white);   // space
    vga_write_hex(5, 3, max_addr, yellow);

    serial_out(77);  // M
    serial_out(97);  // a
    serial_out(120); // x
    serial_out(58);  // :
    serial_out(32);  // space
    serial_hex(max_addr);
    serial_newline();

    let free_pages = pmm_get_free_pages();
    let free_mb = (free_pages * (PAGE_SIZE as u64)) / (1024 * 1024);

    // Line 4: "Free: XXX MB"
    vga_write_char(0, 4, 70, white);   // F
    vga_write_char(1, 4, 114, white);  // r
    vga_write_char(2, 4, 101, white);  // e
    vga_write_char(3, 4, 101, white);  // e
    vga_write_char(4, 4, 58, white);   // :
    vga_write_char(5, 4, 32, white);   // space
    let d1 = vga_write_dec(6, 4, free_mb, green);
    vga_write_char(6 + d1, 4, 32, white);
    vga_write_char(7 + d1, 4, 77, white);  // M
    vga_write_char(8 + d1, 4, 66, white);  // B

    let test_page = pmm_alloc_page();

    // Line 5: "Alloc: 0x..."
    vga_write_char(0, 5, 65, white);   // A
    vga_write_char(1, 5, 108, white);  // l
    vga_write_char(2, 5, 108, white);  // l
    vga_write_char(3, 5, 111, white);  // o
    vga_write_char(4, 5, 99, white);   // c
    vga_write_char(5, 5, 58, white);   // :
    vga_write_char(6, 5, 32, white);   // space
    vga_write_hex(7, 5, test_page, green);

    pmm_free_page(test_page);

    let test_page2 = pmm_alloc_page();

    // Line 6: "Again: 0x..."
    vga_write_char(0, 6, 65, white);   // A
    vga_write_char(1, 6, 103, white);  // g
    vga_write_char(2, 6, 97, white);   // a
    vga_write_char(3, 6, 105, white);  // i
    vga_write_char(4, 6, 110, white);  // n
    vga_write_char(5, 6, 58, white);   // :
    vga_write_char(6, 6, 32, white);   // space
    vga_write_hex(7, 6, test_page2, green);

    let ok = test_page == test_page2;

    // Line 8: "MM OK" or "MM FAIL"
    if ok {
        vga_write_char(0, 8, 77, green);   // M
        vga_write_char(1, 8, 77, green);   // M
        vga_write_char(2, 8, 32, white);   // space
        vga_write_char(3, 8, 79, green);   // O
        vga_write_char(4, 8, 75, green);   // K

        serial_out(77);
        serial_out(77);
        serial_out(32);
        serial_out(79);
        serial_out(75);
        serial_newline();
    } else {
        let red = vga_color(COLOR_RED, COLOR_BLACK);
        vga_write_char(0, 8, 77, red);
        vga_write_char(1, 8, 77, red);
        vga_write_char(2, 8, 32, white);
        vga_write_char(3, 8, 70, red);
        vga_write_char(4, 8, 65, red);
        vga_write_char(5, 8, 73, red);
        vga_write_char(6, 8, 76, red);
    }

    ok
}

// ============================================================
// PIC (8259 Programmable Interrupt Controller)
// ============================================================

fn pic_init() {
    // Save masks
    let mask1 = inb(PIC1_DATA);
    let mask2 = inb(PIC2_DATA);

    // ICW1: init + ICW4 needed
    outb(PIC1_CMD, 0x11);
    io_wait();
    outb(PIC2_CMD, 0x11);
    io_wait();

    // ICW2: vector offsets
    outb(PIC1_DATA, 32);  // IRQ 0-7 -> INT 32-39
    io_wait();
    outb(PIC2_DATA, 40);  // IRQ 8-15 -> INT 40-47
    io_wait();

    // ICW3: cascading
    outb(PIC1_DATA, 4);   // Slave on IRQ2
    io_wait();
    outb(PIC2_DATA, 2);   // Cascade identity
    io_wait();

    // ICW4: 8086 mode
    outb(PIC1_DATA, 1);
    io_wait();
    outb(PIC2_DATA, 1);
    io_wait();

    // Enable only timer (IRQ0) and keyboard (IRQ1)
    outb(PIC1_DATA, 0xFC);
    outb(PIC2_DATA, 0xFF);
}

fn pic_send_eoi(irq: i64) {
    if irq >= 8 {
        outb(PIC2_CMD, PIC_EOI);
    }
    outb(PIC1_CMD, PIC_EOI);
}

// ============================================================
// PIT (Programmable Interval Timer)
// ============================================================

fn timer_init() {
    // Initialize tick counter
    write_u64_addr(TICK_COUNT_ADDR, 0);

    // PIT command: channel 0, lobyte/hibyte, mode 3 (square wave)
    outb(PIT_CMD, 0x36);

    // Send divisor (PIT_DIVISOR = 11932, low byte = 0x9C, high byte = 0x2E)
    let divisor_low = PIT_DIVISOR & 0xFF;
    let divisor_high = (PIT_DIVISOR / 256) & 0xFF;
    outb(PIT_CHANNEL0, divisor_low);
    outb(PIT_CHANNEL0, divisor_high);
}

fn timer_get_ticks() -> u64 {
    read_u64_addr(TICK_COUNT_ADDR)
}

// ============================================================
// IDT (Interrupt Descriptor Table)
// ============================================================

fn idt_set_gate(index: i64, handler: i64) {
    let entry_addr = IDT_ADDR + (index * IDT_ENTRY_SIZE);

    // Extract handler address parts using division/modulo
    // This avoids potential issues with bit operations
    let handler_u64 = handler as u64;
    let offset_low = (handler_u64 % 65536) as i64;        // bits 0-15
    let offset_mid = ((handler_u64 / 65536) % 65536) as i64;  // bits 16-31
    let offset_high = (handler_u64 / 0x100000000) as i64;     // bits 32-63

    // Type attributes byte: 0x8E = Present + DPL0 + IntGate
    // At byte 5, IST at byte 4 = 0
    // As u16 little-endian: 0x8E00 (byte4=0x00, byte5=0x8E)
    let type_attr: i64 = 0x8E00;

    // Write IDT entry (16 bytes)
    write_u16_addr(entry_addr + 0, offset_low);           // offset_low
    write_u16_addr(entry_addr + 2, KERNEL_CS);            // selector
    write_u16_addr(entry_addr + 4, type_attr);            // IST=0, type
    write_u16_addr(entry_addr + 6, offset_mid);           // offset_mid
    write_u32_addr(entry_addr + 8, offset_high);          // offset_high
    write_u32_addr(entry_addr + 12, 0);                   // reserved

}

fn idt_clear() {
    let mut i: i64 = 0;
    while i < IDT_ENTRIES * IDT_ENTRY_SIZE {
        write_u64_addr(IDT_ADDR + i, 0);
        i = i + 8;
    }
}

fn idt_set_gate_dpl(index: i64, handler: i64, dpl: i64) {
    let entry_addr = IDT_ADDR + (index * IDT_ENTRY_SIZE);

    // Extract handler address parts using division/modulo
    let handler_u64 = handler as u64;
    let offset_low = (handler_u64 % 65536) as i64;
    let offset_mid = ((handler_u64 / 65536) % 65536) as i64;
    let offset_high = (handler_u64 / 0x100000000) as i64;

    // Type attributes byte: Present + DPL + IntGate
    // 0x8E = Present(1) + DPL0(00) + 0 + IntGate(1110)
    // 0xEE = Present(1) + DPL3(11) + 0 + IntGate(1110)
    let type_attr: i64 = if dpl == 3 { 0xEE00 } else { 0x8E00 };

    // Write IDT entry (16 bytes)
    write_u16_addr(entry_addr + 0, offset_low);
    write_u16_addr(entry_addr + 2, KERNEL_CS);
    write_u16_addr(entry_addr + 4, type_attr);
    write_u16_addr(entry_addr + 6, offset_mid);
    write_u32_addr(entry_addr + 8, offset_high);
    write_u32_addr(entry_addr + 12, 0);
}

fn idt_init() {
    // Clear all entries
    idt_clear();

    // Get ISR stub table address
    let stub_table = get_isr_stub_ptr();

    // Set up all 48 handlers (32 exceptions + 16 IRQs)
    let mut i: i64 = 0;
    while i < 48 {
        let handler = read_u64_addr(stub_table + (i * 8));
        idt_set_gate(i, handler as i64);
        i = i + 1;
    }

    // Set up syscall handler at INT 0x80 (entry 128) with DPL=3
    let syscall_ptr = get_syscall_stub_ptr();
    let syscall_handler = read_u64_addr(syscall_ptr);
    idt_set_gate_dpl(128, syscall_handler as i64, 3);

    // Load IDT
    idt_load();
}

fn get_isr_stub_ptr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea isr_stub_table(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn get_syscall_stub_ptr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea isr_syscall_ptr(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn idt_load() {
    // Set up IDTR at IDTR_ADDR
    let limit = (IDT_ENTRIES * IDT_ENTRY_SIZE - 1) as i64;
    write_u16_addr(IDTR_ADDR, limit);

    // Write base (64-bit)
    unsafe {
        asm!(
            "movq %rax, 2(%rcx)",
            in("rcx") IDTR_ADDR,
            in("rax") IDT_ADDR,
            options(nostack, att_syntax)
        );
    }

    // Load IDT
    unsafe {
        asm!(
            "lidt (%rax)",
            in("rax") IDTR_ADDR,
            options(nostack, att_syntax)
        );
    }
}

// ============================================================
// Interrupt Handler (called from assembly)
// ============================================================

fn read_stack_u64(base: i64, offset: i64) -> u64 {
    read_u64_addr(base + offset)
}

fn read_cr2() -> u64 {
    let mut result: u64 = 0;
    unsafe {
        asm!(
            "mov %cr2, %rax",
            lateout("rax") result,
            options(nomem, nostack, att_syntax)
        );
    }
    result
}

fn serial_print_hex64(value: u64) {
    serial_out(48);  // '0'
    serial_out(120); // 'x'

    let mut i: i64 = 60;
    while i >= 0 {
        let nibble = bit_and(shr_u64(value, i as u64), 0xF) as i64;
        let ch: i64 = if nibble < 10 { 48 + nibble } else { 55 + nibble };
        serial_out(ch);
        i = i - 4;
    }
}

// ISR handler - called from assembly (isr_common)
// Sets SWITCH_RSP_ADDR to new RSP if context switch needed, 0 otherwise
pub fn isr_handler(frame_ptr: i64) {
    // Clear switch RSP at start
    write_u64_addr(SWITCH_RSP_ADDR, 0);

    // Stack layout:
    //   [0]   = DS
    //   [8]   = R15
    //   [16]  = R14
    //   [24]  = R13
    //   [32]  = R12
    //   [40]  = R11
    //   [48]  = R10
    //   [56]  = R9
    //   [64]  = R8
    //   [72]  = RBP
    //   [80]  = RDI
    //   [88]  = RSI
    //   [96]  = RDX
    //   [104] = RCX
    //   [112] = RBX
    //   [120] = RAX
    //   [128] = interrupt number
    //   [136] = error code
    //   [144] = RIP

    let int_num = read_stack_u64(frame_ptr, 128) as i64;

    if int_num == 128 {
        // System call (INT 0x80)
        // Syscall ABI: RAX = syscall number, RDI = arg1, RSI = arg2, RDX = arg3
        let syscall_num = read_stack_u64(frame_ptr, 120) as i64;  // RAX
        let arg1 = read_stack_u64(frame_ptr, 80) as i64;          // RDI
        let arg2 = read_stack_u64(frame_ptr, 88) as i64;          // RSI
        let arg3 = read_stack_u64(frame_ptr, 96) as i64;          // RDX

        let result = handle_syscall(syscall_num, arg1, arg2, arg3, frame_ptr);

        // Store result in RAX on the stack (will be restored by iretq)
        write_u64_addr(frame_ptr + 120, result as u64);
    } else if int_num < 32 {
        // CPU Exception
        let error_code = read_stack_u64(frame_ptr, 136);
        let rip = read_stack_u64(frame_ptr, 144);
        handle_exception(int_num, error_code, rip);
    } else if int_num < 48 {
        // Hardware IRQ
        let irq = int_num - 32;
        handle_irq(irq);

        // On timer interrupt (IRQ 0), check for context switch
        if irq == 0 {
            let current = get_current_pid();

            // Only save RSP if process was RUNNING (was scheduled before)
            // This prevents overwriting initial RSP of idle process
            let current_state = pcb_get_state(current);
            if current_state == PROC_RUNNING {
                pcb_set_rsp(current, frame_ptr);
            }

            // Get next process RSP (scheduler updates current_pid)
            let new_rsp = schedule_pick_next();
            if new_rsp != 0 {
                write_u64_addr(SWITCH_RSP_ADDR, new_rsp as u64);
            }
        }
    }
}

// ============================================================
// System Call Handler
// ============================================================

fn handle_syscall(num: i64, arg1: i64, arg2: i64, arg3: i64, frame_ptr: i64) -> i64 {
    let mut result: i64 = -1;

    if num == SYS_YIELD {
        result = syscall_yield(frame_ptr);
    } else if num == SYS_GETPID {
        result = syscall_getpid();
    } else if num == SYS_PRINT {
        result = syscall_print(arg1);
    } else if num == SYS_SEND {
        result = syscall_send(arg1, arg2);
    } else if num == SYS_RECV {
        result = syscall_recv(arg1);
    } else if num == SYS_EXIT {
        result = syscall_exit();
    } else if num == SYS_OPEN {
        result = syscall_open(arg1);
    } else if num == SYS_READ {
        result = syscall_read(arg1, arg2);
    } else if num == SYS_WRITE {
        result = syscall_write(arg1, arg2);
    } else if num == SYS_CLOSE {
        result = syscall_close(arg1);
    } else if num == SYS_FSTAT {
        result = syscall_fstat(arg1);
    } else if num == SYS_CAP_CREATE {
        result = syscall_cap_create(arg1, arg2, arg3);
    } else if num == SYS_CAP_DERIVE {
        result = syscall_cap_derive(arg1, arg2);
    } else if num == SYS_CAP_GRANT {
        result = syscall_cap_grant(arg1, arg2);
    } else if num == SYS_CAP_REVOKE {
        result = syscall_cap_revoke(arg1);
    } else if num == SYS_CAP_LIST {
        result = syscall_cap_list(arg1);
    }

    result
}

// SYS_YIELD - Yield CPU to scheduler
fn syscall_yield(frame_ptr: i64) -> i64 {
    let current = get_current_pid();

    // Save current RSP
    let current_state = pcb_get_state(current);
    if current_state == PROC_RUNNING {
        pcb_set_rsp(current, frame_ptr);
    }

    // Get next process RSP
    let new_rsp = schedule_pick_next();
    if new_rsp != 0 {
        write_u64_addr(SWITCH_RSP_ADDR, new_rsp as u64);
    }

    0
}

// SYS_GETPID - Get current process ID
fn syscall_getpid() -> i64 {
    get_current_pid()
}

// SYS_PRINT - Print character to serial
fn syscall_print(ch: i64) -> i64 {
    serial_out(ch);
    0
}

// SYS_EXIT - Exit current process
fn syscall_exit() -> i64 {
    let current = get_current_pid();
    pcb_set_state(current, PROC_UNUSED);

    serial_out(80);  // P
    serial_out(current + 48);  // Process number
    serial_out(88);  // X
    serial_newline();

    // Yield to next process
    let new_rsp = schedule_pick_next();
    if new_rsp != 0 {
        write_u64_addr(SWITCH_RSP_ADDR, new_rsp as u64);
    }

    0
}

// ============================================================
// File System Syscalls
// ============================================================

// SYS_OPEN - Open file by index (simplified: arg1 = file index)
// Returns: file descriptor, or -1 on error
fn syscall_open(file_idx: i64) -> i64 {
    let current = get_current_pid();

    // Validate file index
    if file_idx < 0 || file_idx >= RAMFS_MAX_FILES {
        return VFS_ERR_INVALID;
    }

    // Check file access capability (READ for now)
    if !cap_check_file(current, file_idx, CAP_RIGHT_READ) {
        serial_out(67);  // C
        serial_out(65);  // A
        serial_out(80);  // P
        serial_out(70);  // F
        serial_out(33);  // !
        serial_out(current + 48);
        serial_out(58);  // :
        serial_out(file_idx + 48);
        serial_newline();
        return CAP_ERR_DENIED;
    }

    // Check if file exists
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let flags = read_u64_addr(entry_addr + FE_FLAGS) as i64;
    if flags == FILE_UNUSED {
        return VFS_ERR_NOT_FOUND;
    }

    // Allocate file descriptor
    let fd = fd_alloc(current, file_idx);
    if fd < 0 {
        return VFS_ERR_NO_FD;
    }

    fd
}

// SYS_READ - Read byte from file descriptor
// arg1 = fd, arg2 = not used (reads current position)
// Returns: byte value (0-255), or -1 on EOF/error
fn syscall_read(fd: i64, arg2: i64) -> i64 {
    let current = get_current_pid();

    // Get file index from FD
    let file_idx = fd_get_file(current, fd);
    if file_idx < 0 {
        return -1;  // Invalid FD
    }

    // Get current offset
    let offset = fd_get_offset(current, fd);

    // Read byte from file
    let byte = ramfs_read_byte(file_idx, offset);
    if byte < 0 {
        return -1;  // EOF or error
    }

    // Advance offset
    fd_set_offset(current, fd, offset + 1);

    byte
}

// SYS_WRITE - Write byte to file descriptor (simplified: single byte)
// arg1 = fd, arg2 = byte value
// Returns: 0 on success, -1 on error
fn syscall_write(fd: i64, byte_val: i64) -> i64 {
    let current = get_current_pid();

    // Get file index from FD
    let file_idx = fd_get_file(current, fd);
    if file_idx < 0 {
        return -1;  // Invalid FD
    }

    // Check file write capability
    if !cap_check_file(current, file_idx, CAP_RIGHT_WRITE) {
        return CAP_ERR_DENIED;
    }

    // Get current offset
    let offset = fd_get_offset(current, fd);

    // Write byte to file (simplified: only supports writing within block)
    if offset >= RAMFS_BLOCK_SIZE {
        return -1;  // Block full
    }

    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
    let data_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

    // Calculate byte position within 8-byte word
    let word_offset = (offset / 8) * 8;
    let byte_pos = offset % 8;

    // Read current word, modify byte, write back
    let current_word = read_u64_addr(data_addr + word_offset);

    // Build mask and new byte position using multiplication
    let mut multiplier: u64 = 1;
    let mut bi: i64 = 0;
    while bi < byte_pos {
        multiplier = multiplier * 256;
        bi = bi + 1;
    }

    // Clear the byte at position and set new value
    let clear_mask = 255 * multiplier;
    let cleared = current_word - ((current_word / multiplier) % 256) * multiplier;
    let new_word = cleared + ((byte_val as u64) * multiplier);

    write_u64_addr(data_addr + word_offset, new_word);

    // Update file size if writing past current size
    let current_size = read_u64_addr(entry_addr + FE_SIZE) as i64;
    if offset >= current_size {
        write_u64_addr(entry_addr + FE_SIZE, (offset + 1) as u64);
    }

    // Advance offset
    fd_set_offset(current, fd, offset + 1);

    0
}

// SYS_CLOSE - Close file descriptor
// arg1 = fd
// Returns: 0 on success, -1 on error
fn syscall_close(fd: i64) -> i64 {
    let current = get_current_pid();
    fd_close(current, fd)
}

// SYS_FSTAT - Get file size
// arg1 = fd
// Returns: file size, or -1 on error
fn syscall_fstat(fd: i64) -> i64 {
    let current = get_current_pid();

    // Get file index from FD
    let file_idx = fd_get_file(current, fd);
    if file_idx < 0 {
        return -1;
    }

    ramfs_file_size(file_idx)
}

// ============================================================
// IPC Message Queue Functions
// ============================================================

fn mq_base_addr(pid: i64) -> i64 {
    MSG_QUEUE_ADDR + (pid * MSG_QUEUE_ENTRY_SIZE)
}

fn mq_init(pid: i64) {
    let base = mq_base_addr(pid);
    write_u64_addr(base + MQ_HEAD, 0);
    write_u64_addr(base + MQ_TAIL, 0);
    write_u64_addr(base + MQ_COUNT, 0);
}

fn mq_is_full(pid: i64) -> bool {
    let base = mq_base_addr(pid);
    let count = read_u64_addr(base + MQ_COUNT) as i64;
    count >= MSG_QUEUE_SIZE
}

fn mq_is_empty(pid: i64) -> bool {
    let base = mq_base_addr(pid);
    let count = read_u64_addr(base + MQ_COUNT) as i64;
    count == 0
}

fn mq_enqueue(dst_pid: i64, src_pid: i64, data: i64) -> bool {
    if mq_is_full(dst_pid) {
        return false;
    }

    let base = mq_base_addr(dst_pid);
    let tail = read_u64_addr(base + MQ_TAIL) as i64;

    // Calculate message slot address
    let msg_addr = base + MQ_MSGS + (tail * MSG_SIZE);

    // Write message: source PID and data
    write_u64_addr(msg_addr + MSG_SRC_PID, src_pid as u64);
    write_u64_addr(msg_addr + MSG_DATA, data as u64);

    // Update tail and count
    let new_tail = (tail + 1) % MSG_QUEUE_SIZE;
    write_u64_addr(base + MQ_TAIL, new_tail as u64);

    let count = read_u64_addr(base + MQ_COUNT);
    write_u64_addr(base + MQ_COUNT, count + 1);

    true
}

fn mq_dequeue(pid: i64, src_out: i64, data_out: i64) -> bool {
    if mq_is_empty(pid) {
        return false;
    }

    let base = mq_base_addr(pid);
    let head = read_u64_addr(base + MQ_HEAD) as i64;

    // Calculate message slot address
    let msg_addr = base + MQ_MSGS + (head * MSG_SIZE);

    // Read message
    let src = read_u64_addr(msg_addr + MSG_SRC_PID);
    let data = read_u64_addr(msg_addr + MSG_DATA);

    // Write to output pointers
    write_u64_addr(src_out, src);
    write_u64_addr(data_out, data);

    // Update head and count
    let new_head = (head + 1) % MSG_QUEUE_SIZE;
    write_u64_addr(base + MQ_HEAD, new_head as u64);

    let count = read_u64_addr(base + MQ_COUNT);
    write_u64_addr(base + MQ_COUNT, count - 1);

    true
}

// SYS_SEND - Send message to a process
// arg1 = destination PID, arg2 = message data
fn syscall_send(dst_pid: i64, data: i64) -> i64 {
    // Validate destination PID
    if dst_pid < 0 || dst_pid >= get_num_procs() {
        return -1;  // Invalid PID
    }

    let src_pid = get_current_pid();

    // Check capability to send to destination
    if !cap_check_ipc_send(src_pid, dst_pid) {
        // Debug output for denied send
        serial_out(67);  // C
        serial_out(65);  // A
        serial_out(80);  // P
        serial_out(33);  // !
        serial_out(src_pid + 48);
        serial_out(45);  // -
        serial_out(62);  // >
        serial_out(dst_pid + 48);
        serial_newline();
        return CAP_ERR_DENIED;
    }

    // Try to enqueue the message
    if mq_enqueue(dst_pid, src_pid, data) {
        // Debug output
        serial_out(83);  // S
        serial_out(78);  // N
        serial_out(68);  // D
        serial_out(58);  // :
        serial_out(src_pid + 48);
        serial_out(45);  // -
        serial_out(62);  // >
        serial_out(dst_pid + 48);
        serial_newline();
        0
    } else {
        -2  // Queue full
    }
}

// SYS_RECV - Receive message from queue
// arg1 = pointer to store source PID (or 0 to discard)
// Returns: message data, or -1 if no message
fn syscall_recv(src_out_ptr: i64) -> i64 {
    let current = get_current_pid();
    let mut result: i64 = -1;

    // Use stack variables for output
    let src_addr = SYSCALL_RET_ADDR + 8;   // Temp storage for src
    let data_addr = SYSCALL_RET_ADDR + 16; // Temp storage for data

    // Check if queue has messages
    if !mq_is_empty(current) {
        if mq_dequeue(current, src_addr, data_addr) {
            // Write source PID if caller wants it
            if src_out_ptr != 0 {
                let src = read_u64_addr(src_addr);
                write_u64_addr(src_out_ptr, src);
            }

            result = read_u64_addr(data_addr) as i64;
        }
    }

    result
}

// ============================================================
// Capability Syscalls
// ============================================================

// SYS_CAP_CREATE - Create a new capability (requires ROOT)
// arg1 = capability type, arg2 = target, arg3 = rights
// Returns: capability index, or error code
fn syscall_cap_create(cap_type: i64, target: i64, rights: i64) -> i64 {
    let current = get_current_pid();

    // Only ROOT can create arbitrary capabilities
    if !cap_has_root(current) {
        return CAP_ERR_DENIED;
    }

    // Validate capability type
    if cap_type < CAP_TYPE_IPC || cap_type > CAP_TYPE_ROOT {
        return CAP_ERR_INVALID;
    }

    // Create the capability
    cap_add(current, cap_type, target, rights)
}

// SYS_CAP_DERIVE - Derive a weaker capability from existing one
// arg1 = source capability index, arg2 = new rights
// Returns: new capability index, or error code
fn syscall_cap_derive(src_cap_idx: i64, new_rights: i64) -> i64 {
    let current = get_current_pid();
    cap_derive(current, src_cap_idx, new_rights)
}

// SYS_CAP_GRANT - Grant capability to another process
// arg1 = destination PID, arg2 = capability index
// Returns: 0 on success, or error code
fn syscall_cap_grant(dst_pid: i64, cap_idx: i64) -> i64 {
    // Validate destination PID
    if dst_pid < 0 || dst_pid >= get_num_procs() {
        return CAP_ERR_INVALID;
    }

    let current = get_current_pid();
    cap_grant(current, dst_pid, cap_idx)
}

// SYS_CAP_REVOKE - Revoke a capability
// arg1 = capability index
// Returns: 0 on success, or error code
fn syscall_cap_revoke(cap_idx: i64) -> i64 {
    let current = get_current_pid();
    cap_remove(current, cap_idx)
}

// SYS_CAP_LIST - Get capability info at index
// arg1 = capability index
// Returns: capability type (high byte) | target (low byte), or error code
fn syscall_cap_list(cap_idx: i64) -> i64 {
    let current = get_current_pid();

    let cap_type = cap_get_type(current, cap_idx);
    if cap_type == CAP_TYPE_UNUSED {
        return CAP_ERR_NOT_FOUND;
    }

    let target = cap_get_target(current, cap_idx);
    let rights = cap_get_rights(current, cap_idx);

    // Pack type and target into return value
    // Format: (type * 65536) + (target * 256) + rights
    (cap_type * 65536) + (target * 256) + rights
}

// ============================================================
// RAM Disk Functions
// ============================================================

// Initialize RAM disk with empty filesystem
fn ramfs_init() {
    // Clear superblock
    let mut i: i64 = 0;
    while i < 512 {
        write_u64_addr(RAMFS_SUPERBLOCK + i, 0);
        i = i + 8;
    }

    // Write superblock
    write_u64_addr(RAMFS_SUPERBLOCK + SB_MAGIC, RAMFS_MAGIC as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_VERSION, 1);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_TOTAL_BLOCKS, RAMFS_MAX_BLOCKS as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_FREE_BLOCKS, RAMFS_MAX_BLOCKS as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_TOTAL_FILES, RAMFS_MAX_FILES as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES, 0);

    // Clear file table
    let file_table_size = RAMFS_MAX_FILES * RAMFS_FILE_ENTRY_SIZE;
    i = 0;
    while i < file_table_size {
        write_u64_addr(RAMFS_FILE_TABLE + i, 0);
        i = i + 8;
    }

    // Create initial test files
    ramfs_create_file_internal(104, 101, 108, 108, 111, 0, 0, 0);  // "hello"
    ramfs_write_file_data(0, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 10, 0);  // "Hello World!\n"

    ramfs_create_file_internal(116, 101, 115, 116, 0, 0, 0, 0);    // "test"
    ramfs_write_file_data(1, 84, 101, 115, 116, 32, 102, 105, 108, 101, 10, 0, 0, 0, 0);  // "Test file\n"

    serial_out(82);  // R
    serial_out(65);  // A
    serial_out(77);  // M
    serial_out(70);  // F
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

// Helper: create file with character name (max 8 chars for simplicity)
fn ramfs_create_file_internal(c0: i64, c1: i64, c2: i64, c3: i64, c4: i64, c5: i64, c6: i64, c7: i64) -> i64 {
    // Find free slot
    let used = read_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES) as i64;
    if used >= RAMFS_MAX_FILES {
        return -1;
    }

    let slot = used;
    let entry_addr = RAMFS_FILE_TABLE + (slot * RAMFS_FILE_ENTRY_SIZE);

    // Set flags to regular file
    write_u64_addr(entry_addr + FE_FLAGS, FILE_REGULAR as u64);

    // Write name as bytes (pack into 64-bit values)
    let name_lo: u64 = (c0 as u64) + ((c1 as u64) * 256) + ((c2 as u64) * 65536) + ((c3 as u64) * 16777216)
                     + ((c4 as u64) * 0x100000000) + ((c5 as u64) * 0x10000000000)
                     + ((c6 as u64) * 0x1000000000000) + ((c7 as u64) * 0x100000000000000);
    write_u64_addr(entry_addr + FE_NAME, name_lo);
    write_u64_addr(entry_addr + FE_NAME + 8, 0);  // Clear rest of name

    // Set size to 0 initially
    write_u64_addr(entry_addr + FE_SIZE, 0);

    // Allocate first data block
    let free_blocks = read_u64_addr(RAMFS_SUPERBLOCK + SB_FREE_BLOCKS) as i64;
    if free_blocks <= 0 {
        return -1;
    }

    let block_idx = (RAMFS_MAX_BLOCKS - free_blocks) as i64;
    write_u64_addr(entry_addr + FE_BLOCK, block_idx as u64);
    write_u64_addr(entry_addr + FE_BLOCKS, 1);

    // Update superblock
    write_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES, (used + 1) as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_FREE_BLOCKS, (free_blocks - 1) as u64);

    slot
}

// Helper: write initial data to file (up to 14 bytes)
fn ramfs_write_file_data(file_idx: i64, b0: i64, b1: i64, b2: i64, b3: i64, b4: i64, b5: i64, b6: i64,
                          b7: i64, b8: i64, b9: i64, b10: i64, b11: i64, b12: i64, b13: i64) {
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
    let data_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

    // Write data bytes
    let lo: u64 = (b0 as u64) + ((b1 as u64) * 256) + ((b2 as u64) * 65536) + ((b3 as u64) * 16777216)
                + ((b4 as u64) * 0x100000000) + ((b5 as u64) * 0x10000000000)
                + ((b6 as u64) * 0x1000000000000) + ((b7 as u64) * 0x100000000000000);
    write_u64_addr(data_addr, lo);

    let hi: u64 = (b8 as u64) + ((b9 as u64) * 256) + ((b10 as u64) * 65536) + ((b11 as u64) * 16777216)
                + ((b12 as u64) * 0x100000000) + ((b13 as u64) * 0x10000000000);
    write_u64_addr(data_addr + 8, hi);

    // Calculate actual size (count non-zero bytes until first zero)
    let mut size: i64 = 14;  // Assume full length
    if b0 == 0 { size = 0; }
    else if b1 == 0 { size = 1; }
    else if b2 == 0 { size = 2; }
    else if b3 == 0 { size = 3; }
    else if b4 == 0 { size = 4; }
    else if b5 == 0 { size = 5; }
    else if b6 == 0 { size = 6; }
    else if b7 == 0 { size = 7; }
    else if b8 == 0 { size = 8; }
    else if b9 == 0 { size = 9; }
    else if b10 == 0 { size = 10; }
    else if b11 == 0 { size = 11; }
    else if b12 == 0 { size = 12; }
    else if b13 == 0 { size = 13; }

    write_u64_addr(entry_addr + FE_SIZE, size as u64);
}

// Find file by name (first 8 chars only for simplicity)
fn ramfs_find_file(name_lo: u64) -> i64 {
    let used = read_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES) as i64;
    let mut result: i64 = -1;
    let mut i: i64 = 0;
    while i < used {
        let entry_addr = RAMFS_FILE_TABLE + (i * RAMFS_FILE_ENTRY_SIZE);
        let flags = read_u64_addr(entry_addr + FE_FLAGS) as i64;
        if flags != FILE_UNUSED {
            let entry_name = read_u64_addr(entry_addr + FE_NAME);
            if entry_name == name_lo {
                if result < 0 {
                    result = i;
                }
            }
        }
        i = i + 1;
    }
    result
}

// Read file size
fn ramfs_file_size(file_idx: i64) -> i64 {
    let mut result: i64 = -1;
    if file_idx >= 0 && file_idx < RAMFS_MAX_FILES {
        let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
        result = read_u64_addr(entry_addr + FE_SIZE) as i64;
    }
    result
}

// Read byte from file at offset
fn ramfs_read_byte(file_idx: i64, offset: i64) -> i64 {
    let mut result: i64 = -1;

    if file_idx >= 0 && file_idx < RAMFS_MAX_FILES {
        let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
        let size = read_u64_addr(entry_addr + FE_SIZE) as i64;

        if offset >= 0 && offset < size {
            let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
            let data_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

            // Read the byte at offset
            let byte_offset = offset % 8;
            let qword_offset = (offset / 8) * 8;
            let qword = read_u64_addr(data_addr + qword_offset);

            // Extract byte using division (avoid bitwise issues)
            let mut shift_val = qword;
            let mut bi: i64 = 0;
            while bi < byte_offset {
                shift_val = shift_val / 256;
                bi = bi + 1;
            }
            result = (shift_val % 256) as i64;
        }
    }

    result
}

// ============================================================
// File Descriptor Table Functions
// ============================================================

// Get FD table base for a process
fn fd_table_addr(pid: i64) -> i64 {
    FD_TABLE_ADDR + (pid * FD_TABLE_SIZE)
}

// Initialize FD table for a process
fn fd_init(pid: i64) {
    let base = fd_table_addr(pid);
    let mut i: i64 = 0;
    while i < MAX_FDS_PER_PROC {
        let entry = base + (i * FD_ENTRY_SIZE);
        write_u64_addr(entry + FD_FILE_IDX, 0xFFFFFFFFFFFFFFFF);  // -1 = closed
        write_u64_addr(entry + FD_OFFSET, 0);
        i = i + 1;
    }
}

// Allocate a new FD for a process
fn fd_alloc(pid: i64, file_idx: i64) -> i64 {
    let base = fd_table_addr(pid);
    let mut result: i64 = -1;
    let mut i: i64 = 0;
    while i < MAX_FDS_PER_PROC {
        let entry = base + (i * FD_ENTRY_SIZE);
        let idx = read_u64_addr(entry + FD_FILE_IDX);
        if idx == 0xFFFFFFFFFFFFFFFF {
            if result < 0 {
                // Found free slot
                write_u64_addr(entry + FD_FILE_IDX, file_idx as u64);
                write_u64_addr(entry + FD_OFFSET, 0);
                result = i;
            }
        }
        i = i + 1;
    }
    result
}

// Get file index from FD
fn fd_get_file(pid: i64, fd: i64) -> i64 {
    let mut result: i64 = -1;
    if fd >= 0 && fd < MAX_FDS_PER_PROC {
        let base = fd_table_addr(pid);
        let entry = base + (fd * FD_ENTRY_SIZE);
        let idx = read_u64_addr(entry + FD_FILE_IDX);
        if idx != 0xFFFFFFFFFFFFFFFF {
            result = idx as i64;
        }
    }
    result
}

// Get current offset for FD
fn fd_get_offset(pid: i64, fd: i64) -> i64 {
    let mut result: i64 = -1;
    if fd >= 0 && fd < MAX_FDS_PER_PROC {
        let base = fd_table_addr(pid);
        let entry = base + (fd * FD_ENTRY_SIZE);
        result = read_u64_addr(entry + FD_OFFSET) as i64;
    }
    result
}

// Set offset for FD
fn fd_set_offset(pid: i64, fd: i64, offset: i64) {
    if fd >= 0 && fd < MAX_FDS_PER_PROC {
        let base = fd_table_addr(pid);
        let entry = base + (fd * FD_ENTRY_SIZE);
        write_u64_addr(entry + FD_OFFSET, offset as u64);
    }
}

// Close FD
fn fd_close(pid: i64, fd: i64) -> i64 {
    let mut result: i64 = -1;
    if fd >= 0 && fd < MAX_FDS_PER_PROC {
        let base = fd_table_addr(pid);
        let entry = base + (fd * FD_ENTRY_SIZE);
        write_u64_addr(entry + FD_FILE_IDX, 0xFFFFFFFFFFFFFFFF);
        write_u64_addr(entry + FD_OFFSET, 0);
        result = 0;
    }
    result
}

// ============================================================
// Capability Table Functions
// ============================================================

// Get capability table base address for a process
fn cap_table_addr(pid: i64) -> i64 {
    CAP_TABLE_ADDR + (pid * CAP_TABLE_SIZE)
}

// Initialize capability table for a process
fn cap_init(pid: i64) {
    let base = cap_table_addr(pid);
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        write_u64_addr(entry + CAP_TYPE, CAP_TYPE_UNUSED as u64);
        write_u64_addr(entry + CAP_TARGET, 0);
        write_u64_addr(entry + CAP_RIGHTS, 0);
        i = i + 1;
    }
}

// Find a free capability slot for a process
fn cap_find_free(pid: i64) -> i64 {
    let base = cap_table_addr(pid);
    let mut result: i64 = -1;
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        let cap_type = read_u64_addr(entry + CAP_TYPE) as i64;
        if cap_type == CAP_TYPE_UNUSED {
            if result < 0 {
                result = i;
            }
        }
        i = i + 1;
    }
    result
}

// Add a capability to a process's table
fn cap_add(pid: i64, cap_type: i64, target: i64, rights: i64) -> i64 {
    let slot = cap_find_free(pid);
    if slot < 0 {
        return CAP_ERR_FULL;
    }

    let base = cap_table_addr(pid);
    let entry = base + (slot * CAP_ENTRY_SIZE);
    write_u64_addr(entry + CAP_TYPE, cap_type as u64);
    write_u64_addr(entry + CAP_TARGET, target as u64);
    write_u64_addr(entry + CAP_RIGHTS, rights as u64);

    slot  // Return capability index
}

// Remove a capability from a process
fn cap_remove(pid: i64, cap_idx: i64) -> i64 {
    let mut result: i64 = CAP_ERR_NOT_FOUND;
    if cap_idx >= 0 && cap_idx < MAX_CAPS_PER_PROC {
        let base = cap_table_addr(pid);
        let entry = base + (cap_idx * CAP_ENTRY_SIZE);
        write_u64_addr(entry + CAP_TYPE, CAP_TYPE_UNUSED as u64);
        write_u64_addr(entry + CAP_TARGET, 0);
        write_u64_addr(entry + CAP_RIGHTS, 0);
        result = CAP_ERR_NONE;
    }
    result
}

// Get capability type at index
fn cap_get_type(pid: i64, cap_idx: i64) -> i64 {
    let mut result: i64 = CAP_TYPE_UNUSED;
    if cap_idx >= 0 && cap_idx < MAX_CAPS_PER_PROC {
        let base = cap_table_addr(pid);
        let entry = base + (cap_idx * CAP_ENTRY_SIZE);
        result = read_u64_addr(entry + CAP_TYPE) as i64;
    }
    result
}

// Get capability target at index
fn cap_get_target(pid: i64, cap_idx: i64) -> i64 {
    let mut result: i64 = 0;
    if cap_idx >= 0 && cap_idx < MAX_CAPS_PER_PROC {
        let base = cap_table_addr(pid);
        let entry = base + (cap_idx * CAP_ENTRY_SIZE);
        result = read_u64_addr(entry + CAP_TARGET) as i64;
    }
    result
}

// Get capability rights at index
fn cap_get_rights(pid: i64, cap_idx: i64) -> i64 {
    let mut result: i64 = 0;
    if cap_idx >= 0 && cap_idx < MAX_CAPS_PER_PROC {
        let base = cap_table_addr(pid);
        let entry = base + (cap_idx * CAP_ENTRY_SIZE);
        result = read_u64_addr(entry + CAP_RIGHTS) as i64;
    }
    result
}

// Check if process has ROOT capability
fn cap_has_root(pid: i64) -> bool {
    let base = cap_table_addr(pid);
    let mut has_root: bool = false;
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        let cap_type = read_u64_addr(entry + CAP_TYPE) as i64;
        if cap_type == CAP_TYPE_ROOT {
            has_root = true;
        }
        i = i + 1;
    }
    has_root
}

// Check if process has IPC capability to send to target
fn cap_check_ipc_send(pid: i64, target_pid: i64) -> bool {
    // ROOT capability allows all IPC
    if cap_has_root(pid) {
        return true;
    }

    let base = cap_table_addr(pid);
    let mut allowed: bool = false;
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        let cap_type = read_u64_addr(entry + CAP_TYPE) as i64;
        let target = read_u64_addr(entry + CAP_TARGET) as i64;
        let rights = read_u64_addr(entry + CAP_RIGHTS) as i64;

        if cap_type == CAP_TYPE_IPC && target == target_pid {
            // Check SEND right using modulo to avoid bitwise issues
            if (rights / CAP_RIGHT_SEND) % 2 == 1 {
                allowed = true;
            }
        }
        i = i + 1;
    }
    allowed
}

// Check if process has FILE capability for a file
fn cap_check_file(pid: i64, file_idx: i64, required_rights: i64) -> bool {
    // ROOT capability allows all file access
    if cap_has_root(pid) {
        return true;
    }

    let base = cap_table_addr(pid);
    let mut allowed: bool = false;
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        let cap_type = read_u64_addr(entry + CAP_TYPE) as i64;
        let target = read_u64_addr(entry + CAP_TARGET) as i64;
        let rights = read_u64_addr(entry + CAP_RIGHTS) as i64;

        if cap_type == CAP_TYPE_FILE && target == file_idx {
            // Check if required rights are present
            // For READ (1): check bit 0
            // For WRITE (2): check bit 1
            let mut has_rights: bool = true;

            if required_rights == CAP_RIGHT_READ {
                if rights % 2 != 1 {
                    has_rights = false;
                }
            } else if required_rights == CAP_RIGHT_WRITE {
                if (rights / 2) % 2 != 1 {
                    has_rights = false;
                }
            }

            if has_rights {
                allowed = true;
            }
        }
        i = i + 1;
    }
    allowed
}

// Derive a new capability from an existing one (with same or fewer rights)
fn cap_derive(pid: i64, src_cap_idx: i64, new_rights: i64) -> i64 {
    // Check source capability exists and has DERIVE right
    let src_type = cap_get_type(pid, src_cap_idx);
    if src_type == CAP_TYPE_UNUSED {
        return CAP_ERR_NOT_FOUND;
    }

    let src_rights = cap_get_rights(pid, src_cap_idx);

    // Check DERIVE right (bit 4)
    if (src_rights / 16) % 2 != 1 {
        return CAP_ERR_DENIED;
    }

    // New rights must be subset of source rights (excluding DERIVE)
    // Since we can't use bitwise AND easily, we check individually
    let base_rights = src_rights % 16;  // Rights without DERIVE/DELEGATE
    let requested = new_rights % 16;

    // For simplicity, allow if new_rights <= base_rights
    // This isn't perfect subset checking but works for common cases
    if requested > base_rights {
        return CAP_ERR_DENIED;
    }

    // Create new capability
    let target = cap_get_target(pid, src_cap_idx);
    cap_add(pid, src_type, target, new_rights)
}

// Grant a capability to another process (transfer via IPC)
fn cap_grant(src_pid: i64, dst_pid: i64, cap_idx: i64) -> i64 {
    // Check source capability exists and has DELEGATE right
    let cap_type = cap_get_type(src_pid, cap_idx);
    if cap_type == CAP_TYPE_UNUSED {
        return CAP_ERR_NOT_FOUND;
    }

    let rights = cap_get_rights(src_pid, cap_idx);

    // Check DELEGATE right (bit 5)
    if (rights / 32) % 2 != 1 {
        return CAP_ERR_DENIED;
    }

    // Copy capability to destination (without DELEGATE right)
    let target = cap_get_target(src_pid, cap_idx);
    let new_rights = rights % 32;  // Remove DELEGATE right

    cap_add(dst_pid, cap_type, target, new_rights)
}

fn handle_exception(num: i64, error_code: u64, rip: u64) {
    // Print to serial
    serial_out(69);  // E
    serial_out(88);  // X
    serial_out(67);  // C
    serial_out(58);  // :
    serial_out(48 + ((num / 10) % 10));
    serial_out(48 + (num % 10));
    serial_newline();

    // Print error code
    serial_out(69); serial_out(82); serial_out(82); serial_out(58); // ERR:
    serial_print_hex64(error_code);
    serial_newline();

    // Print RIP
    serial_out(82); serial_out(73); serial_out(80); serial_out(58); // RIP:
    serial_print_hex64(rip);
    serial_newline();

    // Page fault: print CR2
    if num == 14 {
        let cr2 = read_cr2();
        serial_out(67); serial_out(82); serial_out(50); serial_out(58); // CR2:
        serial_print_hex64(cr2);
        serial_newline();
    }

    // Display on VGA
    let red: i64 = 0x4F;
    vga_write_char_color(0, 20, 69, red);   // E
    vga_write_char_color(1, 20, 88, red);   // X
    vga_write_char_color(2, 20, 67, red);   // C
    vga_write_char_color(3, 20, 32, red);   // space
    vga_write_hex_byte(4, 20, num as u64, red);

    // Halt on fatal exceptions
    if num == 8 || num == 13 || num == 14 {
        serial_out(72); serial_out(65); serial_out(76); serial_out(84); // HALT
        serial_newline();
        loop {
            unsafe { asm!("cli; hlt", options(nomem, nostack)); }
        }
    }
}

fn handle_irq(irq: i64) {
    if irq == 0 {
        // Timer interrupt
        handle_timer();
    } else if irq == 1 {
        // Keyboard interrupt
        handle_keyboard();
    }

    // Send EOI
    pic_send_eoi(irq);
}

fn handle_timer() {
    let ticks = read_u64_addr(TICK_COUNT_ADDR);
    write_u64_addr(TICK_COUNT_ADDR, ticks + 1);

    // Every 100 ticks (~1 second), print TICK
    if (ticks + 1) % 100 == 0 {
        serial_out(84);  // T
        serial_out(73);  // I
        serial_out(67);  // C
        serial_out(75);  // K
        serial_newline();

        // Update VGA tick counter (row 10)
        let seconds = ((ticks + 1) / 100) as i64;
        let green: i64 = 0x0A;
        vga_write_char_color(0, 10, 84, green);  // T
        vga_write_char_color(1, 10, 58, green);  // :

        let d2 = (seconds / 100) % 10;
        let d1 = (seconds / 10) % 10;
        let d0 = seconds % 10;
        vga_write_char_color(2, 10, 48 + d2, green);
        vga_write_char_color(3, 10, 48 + d1, green);
        vga_write_char_color(4, 10, 48 + d0, green);
        vga_write_char_color(5, 10, 115, green); // s
    }
}

fn handle_keyboard() {
    let scancode = inb(0x60);

    serial_out(75);  // K
    serial_out(66);  // B
    serial_out(58);  // :
    serial_print_hex64(scancode as u64);
    serial_newline();
}

// ============================================================
// Interrupt Initialization
// ============================================================

fn init_interrupts() {
    let white = vga_color(COLOR_WHITE, COLOR_BLACK);
    let green = vga_color(COLOR_GREEN, COLOR_BLACK);

    // Line 9: "INT init..."
    vga_write_char(0, 9, 73, white);   // I
    vga_write_char(1, 9, 78, white);   // N
    vga_write_char(2, 9, 84, white);   // T
    vga_write_char(3, 9, 32, white);   // space
    vga_write_char(4, 9, 105, white);  // i
    vga_write_char(5, 9, 110, white);  // n
    vga_write_char(6, 9, 105, white);  // i
    vga_write_char(7, 9, 116, white);  // t

    // Initialize PIC (remap IRQs to 32-47)
    pic_init();

    // Initialize PIT timer (~100 Hz)
    timer_init();

    // Initialize IDT with ISR stubs
    idt_init();

    // Enable interrupts
    sti();

    // Update display: "INT OK"
    vga_write_char(9, 9, 79, green);   // O
    vga_write_char(10, 9, 75, green);  // K

    serial_out(73);  // I
    serial_out(78);  // N
    serial_out(84);  // T
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Print syscall ready status
    serial_out(83);  // S
    serial_out(89);  // Y
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

// ============================================================
// TSS (Task State Segment) Management
// ============================================================

// TSS structure layout (64-bit mode, 104 bytes):
// Offset 0x00: Reserved (4 bytes)
// Offset 0x04: RSP0 (8 bytes) - Kernel stack for ring 0
// Offset 0x0C: RSP1 (8 bytes)
// Offset 0x14: RSP2 (8 bytes)
// Offset 0x1C: Reserved (8 bytes)
// Offset 0x24: IST1-IST7 (56 bytes)
// Offset 0x5C: Reserved (8 bytes)
// Offset 0x64: Reserved (2 bytes)
// Offset 0x66: IOPB offset (2 bytes)

fn tss_init() {
    let tss_addr = get_tss64_addr();

    // Clear TSS structure
    let mut i: i64 = 0;
    while i < TSS_SIZE {
        write_u64_addr(tss_addr + i, 0);
        i = i + 8;
    }

    // Set IOPB offset to beyond TSS (disable IO bitmap)
    // IOPB offset at 0x66, set to 104 (TSS_SIZE)
    write_u16_addr(tss_addr + 0x66, TSS_SIZE);

    serial_out(84);  // T
    serial_out(83);  // S
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(73);  // I
    serial_out(78);  // N
    serial_out(73);  // I
    serial_out(84);  // T
    serial_newline();
}

fn tss_set_kernel_stack(rsp0: i64) {
    let tss_addr = get_tss64_addr();
    // RSP0 is at offset 4 in TSS
    write_u64_addr(tss_addr + 4, rsp0 as u64);
}

fn tss_get_kernel_stack() -> i64 {
    let tss_addr = get_tss64_addr();
    read_u64_addr(tss_addr + 4) as i64
}

// Set up TSS descriptor in GDT at offset 0x28
// 64-bit TSS descriptor is 16 bytes (occupies 2 GDT entries)
fn gdt_setup_tss() {
    let tss_addr = get_tss64_addr();
    let base = tss_addr as u64;
    let limit = (TSS_SIZE - 1) as u64;

    // TSS Descriptor format (16 bytes for 64-bit):
    // Bytes 0-1: Limit [15:0]
    // Bytes 2-3: Base [15:0]
    // Byte 4: Base [23:16]
    // Byte 5: Type + Attributes (0x89 = Present + TSS Available)
    // Byte 6: Limit [19:16] + Flags
    // Byte 7: Base [31:24]
    // Bytes 8-11: Base [63:32]
    // Bytes 12-15: Reserved (0)

    // Get GDT base from assembly
    let gdt_base = get_gdt64_addr();
    let tss_desc_addr = gdt_base + GDT_TSS_OFFSET;

    // Low 8 bytes
    let base_low = base % 65536;
    let base_mid_low = (base / 65536) % 256;
    let base_mid_high = (base / 16777216) % 256;
    let limit_low = limit % 65536;
    let limit_high = (limit / 65536) % 16;

    // Build low descriptor (8 bytes)
    // Format: limit_low(16) | base_low(16) | base_mid_low(8) | type(8) | limit_high+flags(8) | base_mid_high(8)
    let low_qword: u64 = limit_low
        + (base_low * 65536)
        + (base_mid_low * 0x100000000)
        + (0x89 * 0x10000000000)          // Type: Present + TSS Available
        + (limit_high * 0x1000000000000)
        + (base_mid_high * 0x100000000000000);

    // High 8 bytes (base[63:32] + reserved)
    let base_high = base / 0x100000000;
    let high_qword: u64 = base_high;

    // Write TSS descriptor to GDT
    write_u64_addr(tss_desc_addr, low_qword);
    write_u64_addr(tss_desc_addr + 8, high_qword);

    serial_out(84);  // T
    serial_out(83);  // S
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(71);  // G
    serial_out(68);  // D
    serial_out(84);  // T
    serial_newline();
}

fn get_gdt64_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea gdt64(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn get_tss64_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea tss64(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn tss_load_tr() {
    // Load Task Register with TSS selector (0x28)
    unsafe {
        asm!(
            "mov $$0x28, %ax; ltr %ax",
            options(nostack, att_syntax)
        );
    }

    serial_out(84);  // T
    serial_out(82);  // R
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

// ============================================================
// Process Management
// ============================================================

// Assembly function wrappers

// Placeholder - context switch now done in isr.asm
fn do_context_switch(old_rsp_ptr: i64, new_rsp: i64) {
    // Not used anymore - switch done via return value in isr_handler
}

// Initialize process stack with fake interrupt frame (KERNEL MODE)
// Returns the initial RSP to store in PCB
fn init_process_stack(stack_top: i64, entry: i64) -> i64 {
    let mut ptr = stack_top;

    // Push SS (kernel data segment)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x10);

    // Push RSP (process stack pointer after iretq)
    ptr = ptr - 8;
    write_u64_addr(ptr, (stack_top - 8) as u64);

    // Push RFLAGS (IF=1 to enable interrupts)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x202);

    // Push CS (kernel code segment)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x08);

    // Push RIP (entry point)
    ptr = ptr - 8;
    write_u64_addr(ptr, entry as u64);

    // Push error code (0)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0);

    // Push interrupt number (0)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0);

    // Push 15 GPRs (all zeros): rax, rbx, rcx, rdx, rsi, rdi, rbp, r8-r15
    // Note: isr_common pushes 15 GPRs, NOT 16!
    let mut i: i64 = 0;
    while i < 15 {
        ptr = ptr - 8;
        write_u64_addr(ptr, 0);
        i = i + 1;
    }

    // Push DS (kernel data segment)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x10);

    ptr
}

// Initialize process stack for USER MODE (ring 3)
// user_stack_top: top of user stack (ring 3)
// kernel_stack_top: top of kernel stack (ring 0, for interrupts/syscalls)
// entry: entry point in user space
// Returns: initial RSP pointing to kernel stack with fake frame
fn init_process_stack_user(user_stack_top: i64, kernel_stack_top: i64, entry: i64) -> i64 {
    // The interrupt frame goes on the kernel stack
    // When IRETQ executes, CPU will:
    // 1. Pop RIP, CS, RFLAGS, RSP, SS from kernel stack
    // 2. Load user segments and jump to entry point
    // 3. Switch to user stack (RSP from frame)

    let mut ptr = kernel_stack_top;

    // Push SS (user data segment with RPL=3)
    ptr = ptr - 8;
    write_u64_addr(ptr, USER_DS as u64);

    // Push RSP (user stack pointer)
    ptr = ptr - 8;
    write_u64_addr(ptr, (user_stack_top - 8) as u64);

    // Push RFLAGS (IF=1 to enable interrupts)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x202);

    // Push CS (user code segment with RPL=3)
    ptr = ptr - 8;
    write_u64_addr(ptr, USER_CS as u64);

    // Push RIP (entry point)
    ptr = ptr - 8;
    write_u64_addr(ptr, entry as u64);

    // Push error code (0)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0);

    // Push interrupt number (0)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0);

    // Push 15 GPRs (all zeros)
    let mut i: i64 = 0;
    while i < 15 {
        ptr = ptr - 8;
        write_u64_addr(ptr, 0);
        i = i + 1;
    }

    // Push DS (user data segment)
    ptr = ptr - 8;
    write_u64_addr(ptr, USER_DS as u64);

    ptr
}

fn asm_get_rsp() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "mov %rsp, %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn pcb_addr(pid: i64) -> i64 {
    PROC_TABLE_ADDR + (pid * PCB_SIZE)
}

fn pcb_get_pid(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_PID) as i64
}

fn pcb_get_state(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_STATE) as i64
}

fn pcb_set_state(pid: i64, state: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_STATE, state as u64);
}

fn pcb_get_rsp(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_RSP) as i64
}

fn pcb_set_rsp(pid: i64, rsp: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_RSP, rsp as u64);
}

fn pcb_get_kstack(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_KSTACK_BASE) as i64
}

fn pcb_set_kstack(pid: i64, kstack: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_KSTACK_BASE, kstack as u64);
}

fn pcb_get_flags(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_FLAGS) as i64
}

fn pcb_set_flags(pid: i64, flags: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_FLAGS, flags as u64);
}

fn pcb_is_user_mode(pid: i64) -> bool {
    let flags = pcb_get_flags(pid);
    (flags % 2) == 1  // Check bit 0 using modulo (avoiding bitwise issues)
}

fn get_current_pid() -> i64 {
    read_u64_addr(CURRENT_PID_ADDR) as i64
}

fn set_current_pid(pid: i64) {
    write_u64_addr(CURRENT_PID_ADDR, pid as u64);
}

fn get_num_procs() -> i64 {
    read_u64_addr(NUM_PROCS_ADDR) as i64
}

fn is_sched_enabled() -> bool {
    read_u64_addr(SCHED_ENABLED_ADDR) != 0
}

fn enable_scheduler() {
    write_u64_addr(SCHED_ENABLED_ADDR, 1);
}

// Create a new KERNEL MODE process (ring 0)
fn proc_create(entry: i64) -> i64 {
    let num_procs = get_num_procs();
    if num_procs >= MAX_PROCS {
        return -1;
    }

    let pid = num_procs;
    let pcb = pcb_addr(pid);

    // Calculate stack for this process (uses same stack for user/kernel in ring 0)
    let stack_base = PROC_STACK_BASE + (pid * PROC_STACK_SIZE);
    let stack_top = stack_base + PROC_STACK_SIZE;

    // Initialize the process stack with fake interrupt frame
    let initial_rsp = init_process_stack(stack_top, entry);

    // Fill PCB
    write_u64_addr(pcb + PCB_PID, pid as u64);
    write_u64_addr(pcb + PCB_STATE, PROC_READY as u64);
    write_u64_addr(pcb + PCB_RSP, initial_rsp as u64);
    write_u64_addr(pcb + PCB_STACK_BASE, stack_base as u64);
    write_u64_addr(pcb + PCB_KSTACK_BASE, stack_base as u64);  // Same stack for kernel processes
    write_u64_addr(pcb + PCB_FLAGS, 0);  // Not user mode

    // Increment process count
    write_u64_addr(NUM_PROCS_ADDR, (num_procs + 1) as u64);

    pid
}

// Create a new USER MODE process (ring 3)
fn proc_create_user(entry: i64) -> i64 {
    let num_procs = get_num_procs();
    if num_procs >= MAX_PROCS {
        return -1;
    }

    let pid = num_procs;
    let pcb = pcb_addr(pid);

    // Calculate user stack for this process
    let user_stack_base = PROC_STACK_BASE + (pid * PROC_STACK_SIZE);
    let user_stack_top = user_stack_base + PROC_STACK_SIZE;

    // Calculate kernel stack for this process (used during syscalls/interrupts)
    let kernel_stack_base = KSTACK_BASE + (pid * KSTACK_SIZE);
    let kernel_stack_top = kernel_stack_base + KSTACK_SIZE;

    // Initialize the process stack for user mode
    // The interrupt frame is on kernel stack, but RSP/SS point to user stack
    let initial_rsp = init_process_stack_user(user_stack_top, kernel_stack_top, entry);

    // Fill PCB
    write_u64_addr(pcb + PCB_PID, pid as u64);
    write_u64_addr(pcb + PCB_STATE, PROC_READY as u64);
    write_u64_addr(pcb + PCB_RSP, initial_rsp as u64);
    write_u64_addr(pcb + PCB_STACK_BASE, user_stack_base as u64);
    write_u64_addr(pcb + PCB_KSTACK_BASE, kernel_stack_base as u64);
    write_u64_addr(pcb + PCB_FLAGS, PROC_FLAG_USER as u64);  // User mode flag

    // Increment process count
    write_u64_addr(NUM_PROCS_ADDR, (num_procs + 1) as u64);

    serial_out(85);  // U
    serial_out(83);  // S
    serial_out(82);  // R
    serial_out(58);  // :
    serial_out(48 + pid);
    serial_newline();

    pid
}

// ============================================================
// Scheduler
// ============================================================

// Returns the new RSP if switch needed, 0 if no switch
fn schedule_pick_next() -> i64 {
    if !is_sched_enabled() {
        return 0;
    }

    let num_procs = get_num_procs();
    if num_procs < 2 {
        return 0;
    }

    let current = get_current_pid();

    // Find next ready process (round-robin)
    let mut next = (current + 1) % num_procs;
    let mut checked: i64 = 0;

    while checked < num_procs {
        let state = pcb_get_state(next);
        if state == PROC_READY || state == PROC_RUNNING {
            break;
        }
        next = (next + 1) % num_procs;
        checked = checked + 1;
    }

    // No switch needed if same process
    if next == current {
        return 0;
    }

    // Update states
    pcb_set_state(current, PROC_READY);
    pcb_set_state(next, PROC_RUNNING);

    // Save current RSP will be done by caller using frame_ptr
    // Return the new RSP
    let new_rsp = pcb_get_rsp(next);

    // Update TSS.RSP0 for the next process
    // This is critical for ring 3 -> ring 0 transitions
    if pcb_is_user_mode(next) {
        // Set kernel stack top as RSP0 in TSS
        let kstack_base = pcb_get_kstack(next);
        let kstack_top = kstack_base + KSTACK_SIZE;
        tss_set_kernel_stack(kstack_top);
    }

    // Update current PID
    set_current_pid(next);

    new_rsp
}

// ============================================================
// Test Processes
// ============================================================

// Syscall wrapper: print a character
fn sys_print(ch: i64) {
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_PRINT,
            in("rdi") ch,
            options(nostack, att_syntax)
        );
    }
}

// Syscall wrapper: get process ID
fn sys_getpid() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_GETPID,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: yield CPU
fn sys_yield() {
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_YIELD,
            options(nostack, att_syntax)
        );
    }
}

// Syscall wrapper: send message
fn sys_send(dst_pid: i64, data: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_SEND,
            in("rdi") dst_pid,
            in("rsi") data,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: receive message
fn sys_recv() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_RECV,
            in("rdi") 0,  // Don't need source PID
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: open file by index
fn sys_open(file_idx: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_OPEN,
            in("rdi") file_idx,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: read byte from file
fn sys_read(fd: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_READ,
            in("rdi") fd,
            in("rsi") 0,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: write byte to file
fn sys_write_file(fd: i64, byte_val: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_WRITE,
            in("rdi") fd,
            in("rsi") byte_val,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: close file
fn sys_close(fd: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_CLOSE,
            in("rdi") fd,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: get file size
fn sys_fstat(fd: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_FSTAT,
            in("rdi") fd,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// User mode server A (runs in ring 3)
fn process_a() {
    // Print startup message using syscalls
    sys_print(91);   // [
    sys_print(65);   // A
    sys_print(93);   // ]
    sys_print(32);   // space

    // Demonstrate VFS: open and read "hello" file (index 0)
    let fd = sys_open(0);  // Open file index 0 ("hello")
    if fd >= 0 {
        sys_print(70);   // F
        sys_print(58);   // :

        // Read and print file contents
        loop {
            let byte = sys_read(fd);
            if byte < 0 || byte == 0 {
                break;  // EOF or error
            }
            sys_print(byte);
        }

        sys_close(fd);
        sys_print(32);   // space
    }

    // Counter for messages
    let mut counter: i64 = 0;

    loop {
        counter = counter + 1;

        // Send message to process B (PID 2) every 500 iterations
        if counter % 500 == 0 {
            sys_send(2, 65);  // Send 'A' character
        }

        // Check for incoming messages
        let msg = sys_recv();
        if msg >= 0 {
            sys_print(60);   // <
            sys_print(msg);  // Print the received character
            sys_print(62);   // >
        }

        sys_yield();  // Yield CPU (user mode friendly)
    }
}

// User mode server B (runs in ring 3)
fn process_b() {
    // Print startup message using syscalls
    sys_print(91);   // [
    sys_print(66);   // B
    sys_print(93);   // ]
    sys_print(32);   // space

    // Counter for messages
    let mut counter: i64 = 0;

    loop {
        counter = counter + 1;

        // Send message to process A (PID 1) every 150 iterations
        if counter % 150 == 0 {
            sys_send(1, 66);  // Send 'B' character
        }

        // Check for incoming messages
        let msg = sys_recv();
        if msg >= 0 {
            sys_print(60);   // <
            sys_print(msg);  // Print the received character
            sys_print(62);   // >
        }

        sys_yield();  // Yield CPU (user mode friendly)
    }
}

fn process_idle() {
    loop {
        hlt();
    }
}

// ============================================================
// VFS Server Process (PID 3)
// ============================================================

// VFS Server: handles file operations via IPC
fn process_vfs_server() {
    // Print startup message
    sys_print(91);   // [
    sys_print(86);   // V
    sys_print(70);   // F
    sys_print(83);   // S
    sys_print(93);   // ]
    sys_print(32);   // space

    loop {
        // Check for incoming VFS requests
        let msg = sys_recv();
        if msg >= 0 {
            // Extract command type from message (low byte)
            let cmd = msg % 256;

            // Handle VFS commands
            if cmd == VFS_LIST {
                // List files: respond with file count
                vfs_handle_list();
            } else if cmd == VFS_OPEN {
                // Open file: extract filename from message
                vfs_handle_open(msg);
            } else if cmd == VFS_READ {
                // Read file
                vfs_handle_read(msg);
            } else if cmd == VFS_STAT {
                // Get file info
                vfs_handle_stat(msg);
            }
        }

        sys_yield();
    }
}

// VFS Handler: list files
fn vfs_handle_list() {
    // Get number of files in filesystem
    let used = read_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES) as i64;

    // Print to serial for debugging
    sys_print(76);   // L
    sys_print(58);   // :
    sys_print(48 + used);  // file count
    sys_print(32);   // space
}

// VFS Handler: open file (simplified - just return file index)
fn vfs_handle_open(msg: i64) {
    // For now, treat msg as file index directly (simplified)
    // In real implementation, would parse filename from IPC message buffer
    let file_idx = (msg / 256) % 256;  // Second byte is file index

    if file_idx >= 0 && file_idx < RAMFS_MAX_FILES {
        let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
        let flags = read_u64_addr(entry_addr + FE_FLAGS) as i64;

        if flags != FILE_UNUSED {
            sys_print(79);   // O
            sys_print(58);   // :
            sys_print(48 + file_idx);  // file index
            sys_print(32);   // space
        }
    }
}

// VFS Handler: read file
fn vfs_handle_read(msg: i64) {
    // Parse: byte 1 = file_idx, byte 2 = offset
    let file_idx = (msg / 256) % 256;
    let offset = (msg / 65536) % 256;

    let byte = ramfs_read_byte(file_idx, offset);
    if byte >= 0 && byte != 0 {
        sys_print(byte);  // Output the byte read
    }
}

// VFS Handler: get file stat (size)
fn vfs_handle_stat(msg: i64) {
    let file_idx = (msg / 256) % 256;
    let size = ramfs_file_size(file_idx);

    sys_print(83);   // S
    sys_print(58);   // :
    if size >= 0 {
        sys_print(48 + (size % 10));
    }
    sys_print(32);   // space
}

// ============================================================
// Console Server Process (PID 4)
// ============================================================

// Console Server: handles keyboard input and display
fn process_console_server() {
    // Print startup message
    sys_print(91);   // [
    sys_print(67);   // C
    sys_print(79);   // O
    sys_print(78);   // N
    sys_print(93);   // ]
    sys_print(32);   // space

    loop {
        // Console server mainly handles keyboard events
        // In this simplified version, just yield
        sys_yield();
    }
}

fn get_process_a_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea process_a(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn get_process_b_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea process_b(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn get_process_idle_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea process_idle(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn get_vfs_server_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea process_vfs_server(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn get_console_server_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea process_console_server(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// ============================================================
// Process Initialization
// ============================================================

fn init_processes() {
    let white = vga_color(COLOR_WHITE, COLOR_BLACK);
    let green = vga_color(COLOR_GREEN, COLOR_BLACK);

    // Line 11: "PROC init..."
    vga_write_char(0, 11, 80, white);   // P
    vga_write_char(1, 11, 82, white);   // R
    vga_write_char(2, 11, 79, white);   // O
    vga_write_char(3, 11, 67, white);   // C
    vga_write_char(4, 11, 32, white);   // space
    vga_write_char(5, 11, 105, white);  // i
    vga_write_char(6, 11, 110, white);  // n
    vga_write_char(7, 11, 105, white);  // i
    vga_write_char(8, 11, 116, white);  // t

    // Initialize TSS (Task State Segment)
    tss_init();

    // Set up TSS descriptor in GDT
    gdt_setup_tss();

    // Load Task Register with TSS selector
    tss_load_tr();

    // Clear process table
    let mut i: i64 = 0;
    while i < MAX_PROCS * PCB_SIZE {
        write_u64_addr(PROC_TABLE_ADDR + i, 0);
        i = i + 8;
    }

    // Initialize scheduler state
    write_u64_addr(CURRENT_PID_ADDR, 0);
    write_u64_addr(NUM_PROCS_ADDR, 0);
    write_u64_addr(SCHED_ENABLED_ADDR, 0);

    // Initialize test process counters
    write_u64_addr(PROC_A_COUNTER, 0);
    write_u64_addr(PROC_B_COUNTER, 0);

    // Initialize message queues for all potential processes
    let mut mq_i: i64 = 0;
    while mq_i < MAX_PROCS {
        mq_init(mq_i);
        mq_i = mq_i + 1;
    }

    // Initialize file descriptor tables for all processes
    let mut fd_i: i64 = 0;
    while fd_i < MAX_PROCS {
        fd_init(fd_i);
        fd_i = fd_i + 1;
    }

    // Initialize capability tables for all processes
    let mut cap_i: i64 = 0;
    while cap_i < MAX_PROCS {
        cap_init(cap_i);
        cap_i = cap_i + 1;
    }

    // Initialize RAM disk filesystem
    ramfs_init();

    // Create idle process (PID 0) - runs in KERNEL mode
    // Note: PID 0 starts as READY, not RUNNING
    // This prevents saving kernel stack as P0's RSP on first switch
    let idle_addr = get_process_idle_addr();
    let pid0 = proc_create(idle_addr);
    set_current_pid(pid0);

    // Create test process A (PID 1) - runs in USER mode (ring 3)
    let proc_a_addr = get_process_a_addr();
    proc_create_user(proc_a_addr);

    // Create test process B (PID 2) - runs in USER mode (ring 3)
    let proc_b_addr = get_process_b_addr();
    proc_create_user(proc_b_addr);

    // Create VFS server (PID 3) - runs in USER mode (ring 3)
    let vfs_addr = get_vfs_server_addr();
    proc_create_user(vfs_addr);

    // Create Console server (PID 4) - runs in USER mode (ring 3)
    let console_addr = get_console_server_addr();
    proc_create_user(console_addr);

    // ============================================================
    // Initialize Capabilities for each process
    // ============================================================

    // PID 0 (Idle): No special capabilities needed

    // PID 1 (Process A): ROOT capability (init process)
    // ROOT allows creating and granting any capability
    cap_add(1, CAP_TYPE_ROOT, 0, CAP_RIGHT_ALL);

    // Grant PID 1 IPC capability to send to PID 2 (Process B)
    cap_add(1, CAP_TYPE_IPC, 2, CAP_RIGHT_SEND + CAP_RIGHT_RECV + CAP_RIGHT_DERIVE + CAP_RIGHT_DELEGATE);

    // Grant PID 1 FILE capability for file 0 ("hello") - read only
    cap_add(1, CAP_TYPE_FILE, 0, CAP_RIGHT_READ + CAP_RIGHT_DERIVE);

    // PID 2 (Process B): IPC capability to send to PID 1
    cap_add(2, CAP_TYPE_IPC, 1, CAP_RIGHT_SEND + CAP_RIGHT_RECV);

    // PID 3 (VFS Server): ROOT capability for file operations
    cap_add(3, CAP_TYPE_ROOT, 0, CAP_RIGHT_ALL);

    // PID 4 (Console Server): ROOT capability
    cap_add(4, CAP_TYPE_ROOT, 0, CAP_RIGHT_ALL);

    // Debug: Print capability initialization status
    serial_out(67);  // C
    serial_out(65);  // A
    serial_out(80);  // P
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Enable scheduler
    enable_scheduler();

    // Update display: "PROC OK"
    vga_write_char(10, 11, 79, green);  // O
    vga_write_char(11, 11, 75, green);  // K

    serial_out(80);  // P
    serial_out(82);  // R
    serial_out(79);  // O
    serial_out(67);  // C
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    let num = get_num_procs();
    serial_out(78);  // N
    serial_out(61);  // =
    serial_out(48 + num);  // number
    serial_newline();

    serial_out(85);  // U
    serial_out(83);  // S
    serial_out(69);  // E
    serial_out(82);  // R
    serial_out(32);  // space
    serial_out(77);  // M
    serial_out(79);  // O
    serial_out(68);  // D
    serial_out(69);  // E
    serial_newline();
}

// ============================================================
// Kernel Entry Point
// ============================================================

fn _start() {
    // Disable interrupts during setup
    cli();

    // Debug: write "KERNEL\n" to serial
    serial_out(75);  // K
    serial_out(69);  // E
    serial_out(82);  // R
    serial_out(78);  // N
    serial_out(69);  // E
    serial_out(76);  // L
    serial_newline();

    // Clear screen
    vga_clear();

    let green = vga_color(COLOR_GREEN, COLOR_BLACK);
    let white = vga_color(COLOR_WHITE, COLOR_BLACK);

    // Line 0: "Genesis Kernel v0.8.0"
    vga_write_char(0, 0, 71, green);   // G
    vga_write_char(1, 0, 101, green);  // e
    vga_write_char(2, 0, 110, green);  // n
    vga_write_char(3, 0, 101, green);  // e
    vga_write_char(4, 0, 115, green);  // s
    vga_write_char(5, 0, 105, green);  // i
    vga_write_char(6, 0, 115, green);  // s
    vga_write_char(7, 0, 32, white);   // space
    vga_write_char(8, 0, 75, green);   // K
    vga_write_char(9, 0, 101, green);  // e
    vga_write_char(10, 0, 114, green); // r
    vga_write_char(11, 0, 110, green); // n
    vga_write_char(12, 0, 101, green); // e
    vga_write_char(13, 0, 108, green); // l
    vga_write_char(14, 0, 32, white);  // space
    vga_write_char(15, 0, 118, white); // v
    vga_write_char(16, 0, 48, white);  // 0
    vga_write_char(17, 0, 46, white);  // .
    vga_write_char(18, 0, 56, white);  // 8
    vga_write_char(19, 0, 46, white);  // .
    vga_write_char(20, 0, 48, white);  // 0

    serial_out(118); // v
    serial_out(48);  // 0
    serial_out(46);  // .
    serial_out(56);  // 8
    serial_out(46);  // .
    serial_out(48);  // 0
    serial_newline();

    // Initialize memory
    let mb_info_addr: i64 = 0;
    let mm_ok = init_memory(mb_info_addr);

    // Initialize processes BEFORE interrupts (scheduler state must exist)
    init_processes();

    // Initialize interrupts (this enables timer which triggers scheduler)
    init_interrupts();

    // Main loop with halt
    loop {
        hlt();
    }
}
