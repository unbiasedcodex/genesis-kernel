// Genesis Kernel - Entry Point
// Microkernel for Genesis OS
// Phase 12: Device Drivers & Disk I/O

// ============================================================
// Module Imports
// ============================================================

mod net;

// ============================================================
// Constants
// ============================================================

const VGA_BUFFER: i64 = 0xB8000;
const VGA_WIDTH: i64 = 80;
const VGA_HEIGHT: i64 = 25;

// VGA colors
const COLOR_BLACK: i64 = 0;
const COLOR_RED: i64 = 4;
const COLOR_GREEN: i64 = 10;
const COLOR_YELLOW: i64 = 14;
const COLOR_WHITE: i64 = 15;

// Memory constants (all as i64 to work with pointer arithmetic)
const PAGE_SIZE: i64 = 4096;
const PMM_BITMAP_ADDR: i64 = 0x400000;    // 4MB - Bitmap storage (32KB)
const PMM_STATE_ADDR: i64 = 0x408000;     // 4MB + 32KB - PMM state
const MULTIBOOT_PTR_ADDR: i64 = 0x500;    // Multiboot info pointer (set by boot.asm)

// Multiboot flags
const MB_FLAG_MODS: i64 = 8;              // Modules present (bit 3)
const MB_FLAG_MMAP: i64 = 64;             // Memory map present (bit 6)

// Multiboot info offsets
const MB_MODS_COUNT: i64 = 20;            // Offset to mods_count
const MB_MODS_ADDR: i64 = 24;             // Offset to mods_addr

// Module entry offsets
const MOD_START: i64 = 0;                 // Module start address
const MOD_END: i64 = 4;                   // Module end address
const MOD_CMDLINE: i64 = 8;               // Command line string pointer

// Interrupt constants
const IDT_ENTRIES: i64 = 256;
const IDT_ENTRY_SIZE: i64 = 16;
const IDT_ADDR: i64 = 0x410000;           // IDT table
const IDTR_ADDR: i64 = 0x411000;          // IDTR structure
const TICK_COUNT_ADDR: i64 = 0x412000;    // Timer tick counter

// PIC ports
const PIC1_CMD: i64 = 0x20;
const PIC1_DATA: i64 = 0x21;
const PIC2_CMD: i64 = 0xA0;
const PIC2_DATA: i64 = 0xA1;
const PIC_EOI: i64 = 0x20;

// PIT ports
const PIT_CHANNEL0: i64 = 0x40;
const PIT_CMD: i64 = 0x43;
const PIT_DIVISOR: i64 = 11932;  // ~100 Hz

// Serial port
const COM1: i64 = 0x3F8;

// Gate types
const GATE_INTERRUPT: i64 = 0x8E;
const KERNEL_CS: i64 = 0x08;

// User mode segment selectors (DPL=3, RPL=3)
const USER_CS: i64 = 0x1B;    // 0x18 | 3 (User Code64)
const USER_DS: i64 = 0x23;    // 0x20 | 3 (User Data)
const TSS_SEL: i64 = 0x28;    // TSS selector

// TSS size (structure from boot.asm, address obtained at runtime)
const TSS_SIZE: i64 = 104;            // TSS size in bytes

// GDT TSS descriptor offset
const GDT_TSS_OFFSET: i64 = 0x28;     // TSS descriptor at offset 0x28

// Process management
const MAX_PROCS: i64 = 32;
const PCB_SIZE: i64 = 80;  // Must match PCB_SIZE_EXT to include all PCB fields
const PROC_TABLE_ADDR: i64 = 0x420000;    // PCB array
const CURRENT_PID_ADDR: i64 = 0x421000;   // Current process ID
const NUM_PROCS_ADDR: i64 = 0x421008;     // Number of active processes
const SCHED_ENABLED_ADDR: i64 = 0x421010; // Scheduler enabled flag
const PROC_STACK_BASE: i64 = 0x500000;    // Base for user process stacks
const PROC_STACK_SIZE: i64 = 0x4000;      // 16KB per process
const KSTACK_BASE: i64 = 0x600000;        // Base for kernel stacks (ring 0)
const KSTACK_SIZE: i64 = 0x2000;          // 8KB per kernel stack

// PCB offsets (Process Control Block structure)
const PCB_PID: i64 = 0;           // Process ID
const PCB_STATE: i64 = 8;         // Process state
const PCB_RSP: i64 = 16;          // Saved RSP (kernel stack pointer)
const PCB_STACK_BASE: i64 = 24;   // User stack base (for ring 3 processes)
const PCB_KSTACK_BASE: i64 = 32;  // Kernel stack base (for ring 0 operations)
const PCB_FLAGS: i64 = 40;        // Process flags (bit 0 = user mode)

// Process flags
const PROC_FLAG_USER: i64 = 1;    // Process runs in user mode (ring 3)

// Process states: See ProcState enum and proc_state_to_i64/i64_to_proc_state

// Context switch RSP (set by isr_handler, read by isr.asm)
const SWITCH_RSP_ADDR: i64 = 0x422010;

// ============================================================
// System Call Constants
// ============================================================

const SYS_YIELD: i64 = 0;      // Yield CPU to scheduler
const SYS_GETPID: i64 = 1;     // Get current process ID
const SYS_PRINT: i64 = 2;      // Print character to serial
const SYS_SEND: i64 = 3;       // Send message to process
const SYS_RECV: i64 = 4;       // Receive message from queue
const SYS_EXIT: i64 = 5;       // Exit process
const SYS_OPEN: i64 = 6;       // Open file (returns fd)
const SYS_READ: i64 = 7;       // Read from file
const SYS_WRITE: i64 = 8;      // Write to file
const SYS_CLOSE: i64 = 9;      // Close file descriptor
const SYS_FSTAT: i64 = 10;     // Get file status (size)

// Syscall result storage (returned in RAX after syscall)
const SYSCALL_RET_ADDR: i64 = 0x422020;

// ============================================================
// IPC Message Constants
// ============================================================

const MSG_SIZE: i64 = 256;         // Message size (256 bytes)
const MSG_QUEUE_SIZE: i64 = 64;    // Messages per process queue
const MSG_QUEUE_ADDR: i64 = 0x1000000; // Message queue base (16MB)
const MSG_QUEUE_ENTRY_SIZE: i64 = 0x5000; // Per-process queue size (20KB: 24 header + 64*256 msgs)

// Message structure offsets
const MSG_SRC_PID: i64 = 0;        // Source process ID
const MSG_DATA: i64 = 8;           // Message data (248 bytes)

// Message queue header offsets (per process)
const MQ_HEAD: i64 = 0;            // Queue head index
const MQ_TAIL: i64 = 8;            // Queue tail index
const MQ_COUNT: i64 = 16;          // Number of messages in queue
const MQ_MSGS: i64 = 24;           // Message array start

// ============================================================
// VFS and RAM Disk Constants
// ============================================================

// VFS Server PID (Init is PID 1, VFS is PID 2)
const VFS_SERVER_PID: i64 = 2;

// RAM Disk memory layout
const RAMFS_BASE: i64 = 0x700000;           // RAM disk base address
const RAMFS_SUPERBLOCK: i64 = 0x700000;     // Superblock (512 bytes)
const RAMFS_FILE_TABLE: i64 = 0x700200;     // File table (2KB)
const RAMFS_DATA_BLOCKS: i64 = 0x701000;    // Data blocks start

// RAM Disk limits
const RAMFS_MAX_FILES: i64 = 32;            // Maximum number of files
const RAMFS_FILE_ENTRY_SIZE: i64 = 64;      // Size of file table entry
const RAMFS_BLOCK_SIZE: i64 = 65536;        // Data block size (64KB per file)
const RAMFS_MAX_BLOCKS: i64 = 8;            // Maximum data blocks (512KB total)
const RAMFS_NAME_MAX: i64 = 15;             // Max filename length

// Superblock offsets (512 bytes total)
const SB_MAGIC: i64 = 0;                    // Magic number (8 bytes)
const SB_VERSION: i64 = 8;                  // Version (8 bytes)
const SB_TOTAL_BLOCKS: i64 = 16;            // Total blocks (8 bytes)
const SB_FREE_BLOCKS: i64 = 24;             // Free blocks (8 bytes)
const SB_TOTAL_FILES: i64 = 32;             // Max files (8 bytes)
const SB_USED_FILES: i64 = 40;              // Used file slots (8 bytes)

// File entry offsets (64 bytes per entry)
const FE_FLAGS: i64 = 0;                    // Flags: 0=unused, 1=file, 2=dir
const FE_NAME: i64 = 8;                     // Filename (16 bytes)
const FE_SIZE: i64 = 24;                    // File size (8 bytes)
const FE_BLOCK: i64 = 32;                   // First data block index (8 bytes)
const FE_BLOCKS: i64 = 40;                  // Number of blocks used (8 bytes)
const FE_RESERVED: i64 = 48;                // Reserved (16 bytes)

// File flags
const FILE_UNUSED: i64 = 0;
const FILE_REGULAR: i64 = 1;
const FILE_DIRECTORY: i64 = 2;

// VFS IPC Message Types (first byte of message data)
const VFS_OPEN: i64 = 1;                    // Open file: {type, mode, name[14]}
const VFS_READ: i64 = 2;                    // Read file: {type, fd, offset(2), size(2)}
const VFS_WRITE: i64 = 3;                   // Write file: {type, fd, size, data[13]}
const VFS_CLOSE: i64 = 4;                   // Close file: {type, fd}
const VFS_STAT: i64 = 5;                    // Get file info: {type, fd}
const VFS_CREATE: i64 = 6;                  // Create file: {type, mode, name[14]}
const VFS_DELETE: i64 = 7;                  // Delete file: {type, name[15]}
const VFS_LIST: i64 = 8;                    // List files: {type, index}

// VFS Response Types
const VFS_OK: i64 = 0;                      // Success
const VFS_ERR_NOT_FOUND: i64 = -1;          // File not found
const VFS_ERR_EXISTS: i64 = -2;             // File already exists
const VFS_ERR_FULL: i64 = -3;               // Filesystem full
const VFS_ERR_INVALID: i64 = -4;            // Invalid operation
const VFS_ERR_NO_FD: i64 = -5;              // No free file descriptors

// File Descriptor Constants
const MAX_FDS_PER_PROC: i64 = 8;            // Max open files per process
const FD_TABLE_ADDR: i64 = 0x440000;        // File descriptor tables base
const FD_ENTRY_SIZE: i64 = 16;              // Size per FD entry
const FD_TABLE_SIZE: i64 = 128;             // Per-process FD table (8*16)

// FD Entry offsets
const FD_FILE_IDX: i64 = 0;                 // File table index (-1 if closed)
const FD_OFFSET: i64 = 8;                   // Current read/write offset

// Console Server PID (Init=1, VFS=2, Console=3)
const CONSOLE_SERVER_PID: i64 = 3;

// Keyboard buffer
const KB_BUFFER_ADDR: i64 = 0x450000;       // Keyboard input buffer
const KB_BUFFER_SIZE: i64 = 256;            // Buffer size
const KB_HEAD_ADDR: i64 = 0x450100;         // Buffer head index
const KB_TAIL_ADDR: i64 = 0x450108;         // Buffer tail index

// RAMFS Magic number: "GENVFS\0\0"
const RAMFS_MAGIC: i64 = 0x0053465F56454E47;

// ============================================================
// Capability-Based Security Constants
// ============================================================

// Capability table memory layout
const CAP_TABLE_ADDR: i64 = 0x460000;         // Capability tables base
const MAX_CAPS_PER_PROC: i64 = 16;            // Max capabilities per process
const CAP_ENTRY_SIZE: i64 = 24;               // Size per capability entry
const CAP_TABLE_SIZE: i64 = 384;              // Per-process cap table (16*24)

// Capability entry offsets (24 bytes per entry)
const CAP_TYPE: i64 = 0;                      // Capability type (8 bytes)
const CAP_TARGET: i64 = 8;                    // Target identifier (8 bytes)
const CAP_RIGHTS: i64 = 16;                   // Rights bitmask (8 bytes)

// Capability types
const CAP_TYPE_UNUSED: i64 = 0;               // Empty slot
const CAP_TYPE_IPC: i64 = 1;                  // IPC send/recv to process
const CAP_TYPE_FILE: i64 = 2;                 // File access capability
const CAP_TYPE_MEM: i64 = 3;                  // Memory region capability
const CAP_TYPE_ROOT: i64 = 4;                 // Root (can create any cap)

// Capability rights bitmask
const CAP_RIGHT_READ: i64 = 1;                // Can read
const CAP_RIGHT_WRITE: i64 = 2;               // Can write
const CAP_RIGHT_SEND: i64 = 4;                // Can send IPC
const CAP_RIGHT_RECV: i64 = 8;                // Can receive IPC
const CAP_RIGHT_DERIVE: i64 = 16;             // Can derive weaker cap
const CAP_RIGHT_DELEGATE: i64 = 32;           // Can transfer to another proc
const CAP_RIGHT_ALL: i64 = 63;                // All rights

// Capability syscalls
const SYS_CAP_CREATE: i64 = 11;               // Create capability (needs ROOT)
const SYS_CAP_DERIVE: i64 = 12;               // Derive weaker capability
const SYS_CAP_GRANT: i64 = 13;                // Transfer cap via IPC
const SYS_CAP_REVOKE: i64 = 14;               // Revoke a capability
const SYS_CAP_LIST: i64 = 15;                 // List capabilities

// Capability error codes
const CAP_ERR_NONE: i64 = 0;                  // Success
const CAP_ERR_DENIED: i64 = -10;              // Permission denied
const CAP_ERR_NOT_FOUND: i64 = -11;           // Capability not found
const CAP_ERR_FULL: i64 = -12;                // Capability table full
const CAP_ERR_INVALID: i64 = -13;             // Invalid capability

// ============================================================
// Shell and Console Constants (Phase 9)
// ============================================================

// Shell process PID (Init=1, VFS=2, Console=3, Shell=4)
const SHELL_PID: i64 = 4;

// Shell line buffer
const SHELL_LINE_ADDR: i64 = 0x470000;        // Line buffer (256 bytes)
const SHELL_LINE_MAX: i64 = 80;               // Max line length
const SHELL_LINE_LEN_ADDR: i64 = 0x470100;    // Current line length

// VGA Console state
const CONSOLE_CURSOR_X: i64 = 0x470110;       // Cursor X position
const CONSOLE_CURSOR_Y: i64 = 0x470118;       // Cursor Y position
const CONSOLE_START_ROW: i64 = 14;            // Shell starts at row 14

// Keyboard syscall
const SYS_KB_READ: i64 = 16;                  // Read character from keyboard buffer
const SYS_KB_AVAIL: i64 = 17;                 // Check if key available

// Special keys
const KEY_BACKSPACE: i64 = 8;
const KEY_ENTER: i64 = 10;
const KEY_ESC: i64 = 27;

// ELF Loader syscall
const SYS_EXEC: i64 = 18;                      // Execute ELF binary

// ============================================================
// ELF64 Format Constants
// ============================================================

// ELF Magic bytes: 0x7F 'E' 'L' 'F'
const ELF_MAGIC0: i64 = 0x7F;
const ELF_MAGIC1: i64 = 0x45;  // E
const ELF_MAGIC2: i64 = 0x4C;  // L
const ELF_MAGIC3: i64 = 0x46;  // F

// ELF Header offsets (64-bit ELF)
const EH_MAGIC: i64 = 0;                       // Magic (4 bytes)
const EH_CLASS: i64 = 4;                       // Class: 1=32-bit, 2=64-bit
const EH_DATA: i64 = 5;                        // Data: 1=LE, 2=BE
const EH_VERSION: i64 = 6;                     // Version
const EH_OSABI: i64 = 7;                       // OS/ABI
const EH_TYPE: i64 = 16;                       // Type: 2=EXEC
const EH_MACHINE: i64 = 18;                    // Machine: 0x3E=x86-64
const EH_ENTRY: i64 = 24;                      // Entry point (8 bytes)
const EH_PHOFF: i64 = 32;                      // Program header offset (8 bytes)
const EH_SHOFF: i64 = 40;                      // Section header offset (8 bytes)
const EH_PHENTSIZE: i64 = 54;                  // Program header entry size (2 bytes)
const EH_PHNUM: i64 = 56;                      // Number of program headers (2 bytes)

// ELF Class values
const ELF_CLASS64: i64 = 2;

// ELF Data (endianness)
const ELF_DATA_LE: i64 = 1;

// ELF Type values
const ET_EXEC: i64 = 2;

// ELF Machine values
const EM_X86_64: i64 = 0x3E;

// Program Header offsets (64-bit)
const PH_TYPE: i64 = 0;                        // Segment type (4 bytes)
const PH_FLAGS: i64 = 4;                       // Segment flags (4 bytes)
const PH_OFFSET: i64 = 8;                      // File offset (8 bytes)
const PH_VADDR: i64 = 16;                      // Virtual address (8 bytes)
const PH_PADDR: i64 = 24;                      // Physical address (8 bytes)
const PH_FILESZ: i64 = 32;                     // Size in file (8 bytes)
const PH_MEMSZ: i64 = 40;                      // Size in memory (8 bytes)
const PH_ALIGN: i64 = 48;                      // Alignment (8 bytes)

// Program Header size
const PH_SIZE: i64 = 56;

// Segment types
const PT_NULL: i64 = 0;
const PT_LOAD: i64 = 1;

// Segment flags
const PF_X: i64 = 1;                           // Execute
const PF_W: i64 = 2;                           // Write
const PF_R: i64 = 4;                           // Read

// ELF Loader memory region
const ELF_LOAD_BASE: i64 = 0x800000;           // Base address for loaded ELF
const ELF_LOAD_SIZE: i64 = 0x100000;           // 1MB max per ELF

// ELF Loader errors
const ELF_OK: i64 = 0;
const ELF_ERR_NOT_FOUND: i64 = -1;
const ELF_ERR_BAD_MAGIC: i64 = -2;
const ELF_ERR_NOT_64BIT: i64 = -3;
const ELF_ERR_NOT_LE: i64 = -4;
const ELF_ERR_NOT_EXEC: i64 = -5;
const ELF_ERR_BAD_ARCH: i64 = -6;
const ELF_ERR_NO_PROC: i64 = -7;
const ELF_ERR_LOAD_FAIL: i64 = -8;

// ============================================================
// Signal Constants (Phase 11)
// ============================================================

// Signal numbers (Unix-compatible subset)
const SIG_NONE: i64 = 0;                          // No signal
const SIGTERM: i64 = 15;                          // Terminate (graceful)
const SIGKILL: i64 = 9;                           // Kill (immediate, cannot be caught)
const SIGSTOP: i64 = 19;                          // Stop process
const SIGCONT: i64 = 18;                          // Continue stopped process
const SIGUSR1: i64 = 10;                          // User-defined signal 1
const SIGUSR2: i64 = 12;                          // User-defined signal 2
const SIGCHLD: i64 = 17;                          // Child process status change

// Maximum signal number
const SIG_MAX: i64 = 32;

// Signal syscalls
const SYS_KILL: i64 = 19;                         // Send signal to process
const SYS_WAIT: i64 = 20;                         // Wait for child process (arg2: flags, WAIT_NOHANG=1)
const SYS_GETPPID: i64 = 21;                      // Get parent process ID

// Wait options
const WAIT_NOHANG: i64 = 1;                       // Return immediately if no child exited

// Signal error codes
const SIG_ERR_INVALID: i64 = -20;                 // Invalid signal number
const SIG_ERR_NO_PROC: i64 = -21;                 // Process not found
const SIG_ERR_PERM: i64 = -22;                    // Permission denied
const SIG_ERR_NO_CHILD: i64 = -23;                // No child processes

// ============================================================
// Shared Memory Constants (Phase 11)
// ============================================================

// Shared memory base address and limits
const SHM_BASE_ADDR: i64 = 0x900000;              // Shared memory region base
const SHM_REGION_SIZE: i64 = 0x10000;             // 64KB per region
const SHM_MAX_REGIONS: i64 = 8;                   // Maximum shared memory regions
const SHM_TABLE_ADDR: i64 = 0x480000;             // Shared memory table

// Shared memory entry size and offsets (32 bytes per entry)
const SHM_ENTRY_SIZE: i64 = 32;
const SHM_KEY: i64 = 0;                           // Shared memory key (8 bytes)
const SHM_ADDR: i64 = 8;                          // Base address (8 bytes)
const SHM_SIZE: i64 = 16;                         // Size in bytes (8 bytes)
const SHM_REFCOUNT: i64 = 24;                     // Reference count (8 bytes)

// Shared memory syscalls
const SYS_SHMGET: i64 = 22;                       // Get/create shared memory region
const SYS_SHMAT: i64 = 23;                        // Attach to shared memory
const SYS_SHMDT: i64 = 24;                        // Detach from shared memory

// Shared memory error codes
const SHM_ERR_INVALID: i64 = -30;                 // Invalid key or ID
const SHM_ERR_FULL: i64 = -31;                    // No free shared memory regions
const SHM_ERR_NOMEM: i64 = -32;                   // Not enough memory
const SHM_ERR_PERM: i64 = -33;                    // Permission denied

// ============================================================
// Memory-Mapped Files Constants (Phase 13)
// ============================================================
// Enables demand paging for ELF loading - pages are loaded from
// RAMFS only when accessed, reducing memory usage for large ELFs

const MMAP_TABLE_ADDR: i64 = 0x490000;            // Memory mapping table base
const MMAP_MAX_ENTRIES: i64 = 64;                 // Maximum mappings (all processes)
const MMAP_ENTRY_SIZE: i64 = 64;                  // Size of each mapping entry

// Mapping entry offsets (64 bytes per entry)
const MMAP_VADDR_START: i64 = 0;                  // Virtual address start (8 bytes)
const MMAP_VADDR_END: i64 = 8;                    // Virtual address end (8 bytes)
const MMAP_FILE_IDX: i64 = 16;                    // RAMFS file index (8 bytes)
const MMAP_FILE_OFFSET: i64 = 24;                 // Offset in file (8 bytes)
const MMAP_FLAGS: i64 = 32;                       // Mapping flags (8 bytes)
const MMAP_PID: i64 = 40;                         // Owner process ID (8 bytes)
const MMAP_PAGES_LOADED: i64 = 48;                // Bitmask of loaded pages (8 bytes)
const MMAP_RESERVED: i64 = 56;                    // Reserved for future use (8 bytes)

// Mapping flags
const MMAP_FLAG_VALID: i64 = 1;                   // Entry is valid/in use
const MMAP_FLAG_READ: i64 = 2;                    // Readable
const MMAP_FLAG_WRITE: i64 = 4;                   // Writable
const MMAP_FLAG_EXEC: i64 = 8;                    // Executable
const MMAP_FLAG_COW: i64 = 16;                    // Copy-on-write (future)

// Mapping error codes
const MMAP_ERR_FULL: i64 = -40;                   // No free mapping entries
const MMAP_ERR_INVALID: i64 = -41;                // Invalid parameters
const MMAP_ERR_OVERLAP: i64 = -42;                // Address range overlaps existing
const MMAP_ERR_NOTFOUND: i64 = -43;               // Mapping not found

// Page size for demand paging
const MMAP_PAGE_SIZE: i64 = 4096;                 // 4KB pages

// ============================================================
// Kernel Page Table Pool (for MMIO and kernel mappings)
// ============================================================
// This pool provides pre-allocated pages for page table structures
// Used when pmm_alloc_page might fail (e.g., mapping high MMIO addresses)

const KPTPOOL_BASE: i64 = 0x4A0000;               // Kernel PT pool base address
const KPTPOOL_SIZE: i64 = 0x10000;                // 64KB = 16 pages for page tables
const KPTPOOL_PAGES: i64 = 16;                    // Number of pages in pool
const KPTPOOL_NEXT_ADDR: i64 = 0x4A0000;          // Next free page index (stored at base)

// ============================================================
// Extended PCB Fields (Phase 11)
// ============================================================

// New PCB offsets (extending from existing 48 bytes to 80 bytes)
const PCB_PARENT_PID: i64 = 48;                   // Parent process ID (8 bytes)
const PCB_EXIT_CODE: i64 = 56;                    // Exit code (8 bytes)
const PCB_PENDING_SIG: i64 = 64;                  // Pending signals bitmask (8 bytes)
const PCB_CHILD_COUNT: i64 = 72;                  // Number of child processes (8 bytes)

// Extended PCB size
const PCB_SIZE_EXT: i64 = 80;

// ============================================================
// ATA PIO Constants (Phase 12)
// ============================================================

// Primary ATA controller ports (I/O base 0x1F0)
const ATA_PRIMARY_IO: i64 = 0x1F0;
const ATA_PRIMARY_CTRL: i64 = 0x3F6;

// ATA I/O port offsets
const ATA_DATA: i64 = 0;                          // Data register (R/W, 16-bit)
const ATA_ERROR: i64 = 1;                         // Error register (R)
const ATA_FEATURES: i64 = 1;                      // Features register (W)
const ATA_SECCOUNT: i64 = 2;                      // Sector count (R/W)
const ATA_LBA_LO: i64 = 3;                        // LBA low byte (R/W)
const ATA_LBA_MID: i64 = 4;                       // LBA mid byte (R/W)
const ATA_LBA_HI: i64 = 5;                        // LBA high byte (R/W)
const ATA_DRIVE: i64 = 6;                         // Drive/head register (R/W)
const ATA_STATUS: i64 = 7;                        // Status register (R)
const ATA_COMMAND: i64 = 7;                       // Command register (W)

// ATA control port offsets
const ATA_ALT_STATUS: i64 = 0;                    // Alternate status (R)
const ATA_DEV_CTRL: i64 = 0;                      // Device control (W)

// ATA status register bits
const ATA_SR_BSY: i64 = 0x80;                     // Busy
const ATA_SR_DRDY: i64 = 0x40;                    // Drive ready
const ATA_SR_DF: i64 = 0x20;                      // Drive fault
const ATA_SR_DSC: i64 = 0x10;                     // Drive seek complete
const ATA_SR_DRQ: i64 = 0x08;                     // Data request ready
const ATA_SR_CORR: i64 = 0x04;                    // Corrected data
const ATA_SR_IDX: i64 = 0x02;                     // Index
const ATA_SR_ERR: i64 = 0x01;                     // Error

// ATA commands
const ATA_CMD_READ_PIO: i64 = 0x20;               // Read sectors (PIO)
const ATA_CMD_WRITE_PIO: i64 = 0x30;              // Write sectors (PIO)
const ATA_CMD_IDENTIFY: i64 = 0xEC;               // Identify drive
const ATA_CMD_FLUSH: i64 = 0xE7;                  // Flush cache

// Drive selection
const ATA_MASTER: i64 = 0xE0;                     // Master drive (LBA mode)
const ATA_SLAVE: i64 = 0xF0;                      // Slave drive (LBA mode)

// ATA sector size
const ATA_SECTOR_SIZE: i64 = 512;

// ATA memory addresses for driver state
const ATA_STATE_ADDR: i64 = 0xA00000;             // ATA driver state
const ATA_IDENTIFY_ADDR: i64 = 0xA00100;          // IDENTIFY data (512 bytes)
const ATA_BUFFER_ADDR: i64 = 0xA10000;            // Disk read buffer (64KB)
const ATA_BUFFER_SIZE: i64 = 0x10000;             // 64KB buffer (128 sectors)

// ATA state offsets
const ATA_PRESENT: i64 = 0;                       // Drive present flag (8 bytes)
const ATA_TOTAL_SECTORS: i64 = 8;                 // Total sectors (8 bytes)
const ATA_LAST_ERROR: i64 = 16;                   // Last error code (8 bytes)

// ATA syscalls
const SYS_DISK_READ: i64 = 25;                    // Read disk sectors
const SYS_DISK_INFO: i64 = 26;                    // Get disk information
const SYS_DISK_WRITE: i64 = 27;                   // Write disk sectors
const SYS_PCI_READ: i64 = 28;                     // Read PCI config space
const SYS_PCI_WRITE: i64 = 29;                    // Write PCI config space
const SYS_PCI_ENUMERATE: i64 = 30;                // Enumerate PCI devices
const SYS_IRQ_REGISTER: i64 = 31;                 // Register IRQ handler
const SYS_IRQ_UNREGISTER: i64 = 32;               // Unregister IRQ handler
const SYS_IRQ_ACK: i64 = 33;                      // Acknowledge IRQ
const SYS_TIME: i64 = 34;                         // Get system time (ticks)
const SYS_SLEEP: i64 = 35;                        // Sleep for ticks

// VGA syscalls (for Console Server in userspace)
const SYS_VGA_PUTCHAR: i64 = 36;                  // Write char at position with color
const SYS_VGA_SETCURSOR: i64 = 37;                // Set hardware cursor position
const SYS_VGA_CLEAR: i64 = 38;                    // Clear screen region
const SYS_VGA_SCROLL: i64 = 39;                   // Scroll screen region

// RAMFS syscalls (for VFS Server in userspace)
const SYS_RAMFS_FILE_COUNT: i64 = 40;             // Get number of files in RAMFS
const SYS_RAMFS_FILE_INFO: i64 = 41;              // Get file flags (0=unused, 1=regular)
const SYS_RAMFS_READ_BYTE: i64 = 42;              // Read byte from file at offset
const SYS_RAMFS_FILE_SIZE: i64 = 43;              // Get file size

// Process info syscalls (Phase 3: Shell in userspace)
const SYS_PROC_COUNT: i64 = 44;                   // Get number of processes
const SYS_PROC_STATE: i64 = 45;                   // Get process state by PID
const SYS_RAMFS_READ_NAME: i64 = 46;              // Read filename character

// ============================================================
// Network Syscall Constants (Phase 13: Network Stack)
// ============================================================

// Socket syscalls (50-69)
const SYS_NET_SOCKET: i64 = 50;       // socket(domain, type, protocol) -> fd
const SYS_NET_BIND: i64 = 51;         // bind(socket, ip, port) -> result
const SYS_NET_LISTEN: i64 = 52;       // listen(socket, backlog) -> result
const SYS_NET_ACCEPT: i64 = 53;       // accept(socket) -> new_socket
const SYS_NET_CONNECT: i64 = 54;      // connect(socket, ip, port) -> result
const SYS_NET_SEND: i64 = 55;         // send(socket, buffer, len) -> bytes_sent
const SYS_NET_RECV: i64 = 56;         // recv(socket, buffer, len) -> bytes_recv
const SYS_NET_CLOSE: i64 = 57;        // close(socket) -> result
const SYS_NET_CONFIG: i64 = 58;       // configure(ip, mask, gw, dns) -> result
const SYS_NET_STATUS: i64 = 59;       // get network status -> status

// Extended network syscalls
const SYS_NET_RESOLVE: i64 = 60;      // resolve(hostname_addr) -> ip
const SYS_NET_PING: i64 = 61;         // ping(ip, timeout) -> rtt_ticks
const SYS_NET_ARP: i64 = 62;          // arp_lookup(ip, mac_out) -> result
const SYS_NET_SENDTO: i64 = 63;       // sendto(socket, buf, len, ip, port) -> bytes
const SYS_NET_RECVFROM: i64 = 64;     // recvfrom(socket, buf, len, ip_out, port_out) -> bytes
const SYS_NET_DHCP: i64 = 65;         // start DHCP -> result
const SYS_NET_POLL: i64 = 66;         // poll network stack -> packets_processed

// TLS Syscalls (80-83)
const SYS_TLS_CONNECT: i64 = 80;      // tls_connect(socket, hostname_addr, hostname_len) -> result
const SYS_TLS_SEND: i64 = 81;         // tls_send(socket, data_addr, len) -> bytes_sent
const SYS_TLS_RECV: i64 = 82;         // tls_recv(socket, data_addr, max_len) -> bytes_recv
const SYS_TLS_CLOSE: i64 = 83;        // tls_close(socket) -> result

// Network address families
const NET_AF_INET: i64 = 2;           // IPv4

// Network socket types
const NET_SOCK_STREAM: i64 = 1;       // TCP
const NET_SOCK_DGRAM: i64 = 2;        // UDP

// IRQ forwarding table (16 IRQs, each 8 bytes: handler PID, 0 = no handler)
const IRQ_HANDLER_TABLE: i64 = 0x1100000;         // 17MB - IRQ handler table

// ATA error codes
const ATA_OK: i64 = 0;                            // Success
const ATA_ERR_NO_DRIVE: i64 = -40;                // No drive present
const ATA_ERR_TIMEOUT: i64 = -41;                 // Operation timeout
const ATA_ERR_IO: i64 = -42;                      // I/O error
const ATA_ERR_INVALID: i64 = -43;                 // Invalid parameter

// ============================================================
// Struct Definitions (L4)
// ============================================================

// L4.1: Basic struct definition
struct Point {
    x: i64,
    y: i64,
}

// L4.7: Nested struct (uses Point)
struct Rect {
    origin: Point,
    size: Point,
}

// L9.3: Three-level nested struct for testing deep nesting
struct Line {
    start: Point,
    end: Point,
}

struct Canvas {
    line: Line,
    color: i64,
}

// L5.4: Struct with array field
struct Buffer4 {
    data: [i64; 4],
    len: i64,
}

// L14.3: Process state enum (replaces PROC_* integer constants)
// Discriminants: Unused=0, Ready=1, Running=2, Waiting=3, Zombie=4, Stopped=5
enum ProcState {
    Unused,
    Ready,
    Running,
    Waiting,
    Zombie,
    Stopped,
}

// Convert ProcState to i64 for storage in PCB memory
fn proc_state_to_i64(state: ProcState) -> i64 {
    match state {
        ProcState::Unused => 0,
        ProcState::Ready => 1,
        ProcState::Running => 2,
        ProcState::Waiting => 3,
        ProcState::Zombie => 4,
        ProcState::Stopped => 5,
    }
}

// Convert i64 from PCB memory to ProcState
// Returns Unused for invalid values
fn i64_to_proc_state(n: i64) -> ProcState {
    match n {
        0 => ProcState::Unused,
        1 => ProcState::Ready,
        2 => ProcState::Running,
        3 => ProcState::Waiting,
        4 => ProcState::Zombie,
        5 => ProcState::Stopped,
        _ => ProcState::Unused,
    }
}

// ============================================================
// Bitwise Operations Helper Functions
// ============================================================

fn shl_u64(value: u64, shift: u64) -> u64 {
    // Use multiplication instead of broken <<= operator
    // value << n = value * 2^n
    if shift >= 64 {
        return 0;
    }
    let mut result = value;
    let mut count = shift;
    while count > 0 {
        result = result * 2;
        count = count - 1;
    }
    result
}

fn shr_u64(value: u64, shift: u64) -> u64 {
    // Use a simpler approach - manual shift loop for small shifts
    // This avoids compiler issues with inline assembly
    if shift >= 64 {
        return 0;
    }
    let mut result = value;
    let mut count = shift;
    while count > 0 {
        // Shift right by 1: divide by 2 using bit operations
        // result = (result >> 1) implemented as: result / 2 for unsigned
        let hi_bit = bit_and(result, 0x8000000000000000);
        result = result / 2;
        // The division by 2 is equivalent to unsigned right shift by 1
        count = count - 1;
    }
    result
}

fn bit_and(a: u64, b: u64) -> u64 {
    let mut result: u64 = 0;
    unsafe {
        asm!(
            "movq %rdi, %rax
             andq %rsi, %rax",
            in("rdi") a,
            in("rsi") b,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn bit_or(a: u64, b: u64) -> u64 {
    let mut result: u64 = 0;
    unsafe {
        asm!(
            "movq %rdi, %rax
             orq %rsi, %rax",
            in("rdi") a,
            in("rsi") b,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn bit_not(a: u64) -> u64 {
    let mut result: u64 = 0;
    unsafe {
        asm!(
            "movq %rdi, %rax
             notq %rax",
            in("rdi") a,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn bit_xor(a: u64, b: u64) -> u64 {
    let mut result: u64 = 0;
    unsafe {
        asm!(
            "movq %rdi, %rax
             xorq %rsi, %rax",
            in("rdi") a,
            in("rsi") b,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// ============================================================
// PS/2 Keyboard Scancode Translation (Phase 9)
// ============================================================

// Convert PS/2 scancode (set 1) to ASCII character
// Returns: ASCII value, or 0 if not printable, or -1 if key release
// L12/L14: Refactored to use match expression with integer literals
fn scancode_to_ascii(scancode: i64) -> i64 {
    // Key release (high bit set) - early return
    if scancode >= 128 {
        return -1;
    }

    match scancode {
        // Numbers row (0x02-0x0D)
        0x02 => 49,   // 1
        0x03 => 50,   // 2
        0x04 => 51,   // 3
        0x05 => 52,   // 4
        0x06 => 53,   // 5
        0x07 => 54,   // 6
        0x08 => 55,   // 7
        0x09 => 56,   // 8
        0x0A => 57,   // 9
        0x0B => 48,   // 0
        0x0C => 45,   // -
        0x0D => 61,   // =

        // QWERTY row (0x10-0x1B)
        0x10 => 113,  // q
        0x11 => 119,  // w
        0x12 => 101,  // e
        0x13 => 114,  // r
        0x14 => 116,  // t
        0x15 => 121,  // y
        0x16 => 117,  // u
        0x17 => 105,  // i
        0x18 => 111,  // o
        0x19 => 112,  // p
        0x1A => 91,   // [
        0x1B => 93,   // ]

        // ASDF row (0x1E-0x28)
        0x1E => 97,   // a
        0x1F => 115,  // s
        0x20 => 100,  // d
        0x21 => 102,  // f
        0x22 => 103,  // g
        0x23 => 104,  // h
        0x24 => 106,  // j
        0x25 => 107,  // k
        0x26 => 108,  // l
        0x27 => 59,   // ;
        0x28 => 39,   // '

        // ZXCV row (0x2C-0x35)
        0x2C => 122,  // z
        0x2D => 120,  // x
        0x2E => 99,   // c
        0x2F => 118,  // v
        0x30 => 98,   // b
        0x31 => 110,  // n
        0x32 => 109,  // m
        0x33 => 44,   // ,
        0x34 => 46,   // .
        0x35 => 47,   // /

        // Special keys
        0x01 => KEY_ESC,        // Escape
        0x0E => KEY_BACKSPACE,  // Backspace
        0x0F => 9,              // Tab
        0x1C => KEY_ENTER,      // Enter
        0x39 => 32,             // Space
        0x29 => 96,             // `

        // Unknown scancode
        _ => 0,
    }
}

// Read byte from address
fn read_byte_addr(addr: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "movzbq (%rdi), %rax",
            in("rdi") addr,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Write byte to address
fn write_byte_addr(addr: i64, value: i64) {
    unsafe {
        asm!(
            "movb %sil, (%rdi)",
            in("rdi") addr,
            in("sil") value,
            options(nostack, att_syntax)
        );
    }
}

// Add character to keyboard buffer
fn kb_buffer_push(ch: i64) {
    let head = read_u64_addr(KB_HEAD_ADDR) as i64;
    let tail = read_u64_addr(KB_TAIL_ADDR) as i64;

    // Calculate next head position
    let next_head = (head + 1) % KB_BUFFER_SIZE;

    // Only add if buffer not full
    if next_head != tail {
        // Write character to buffer
        write_byte_addr(KB_BUFFER_ADDR + head, ch);
        // Update head
        write_u64_addr(KB_HEAD_ADDR, next_head as u64);
    }
}

// Read character from keyboard buffer
// Returns: character, or -1 if buffer empty
fn kb_buffer_pop() -> i64 {
    let head = read_u64_addr(KB_HEAD_ADDR) as i64;
    let tail = read_u64_addr(KB_TAIL_ADDR) as i64;
    let mut result: i64 = -1;

    // Only read if buffer not empty
    if head != tail {
        // Read character from buffer
        result = read_byte_addr(KB_BUFFER_ADDR + tail);
        // Update tail
        let next_tail = (tail + 1) % KB_BUFFER_SIZE;
        write_u64_addr(KB_TAIL_ADDR, next_tail as u64);
    }

    result
}

// Check if keyboard buffer has data
fn kb_buffer_avail() -> bool {
    let head = read_u64_addr(KB_HEAD_ADDR) as i64;
    let tail = read_u64_addr(KB_TAIL_ADDR) as i64;
    head != tail
}

// Initialize keyboard buffer
fn kb_buffer_init() {
    write_u64_addr(KB_HEAD_ADDR, 0);
    write_u64_addr(KB_TAIL_ADDR, 0);
}

// ============================================================
// I/O Port Functions
// ============================================================

fn outb(port: i64, value: i64) {
    unsafe {
        asm!(
            "out %al, %dx",
            in("dx") port,
            in("al") value,
            options(nomem, nostack, att_syntax)
        );
    }
}

fn inb(port: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "in %dx, %al",
            in("dx") port,
            lateout("al") result,
            options(nomem, nostack, att_syntax)
        );
    }
    result
}

fn io_wait() {
    outb(0x80, 0);
}

// 16-bit port I/O
fn outw(port: i64, value: i64) {
    unsafe {
        asm!(
            "outw %ax, %dx",
            in("dx") port,
            in("ax") value,
            options(nomem, nostack, att_syntax)
        );
    }
}

fn inw(port: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "inw %dx, %ax",
            in("dx") port,
            lateout("ax") result,
            options(nomem, nostack, att_syntax)
        );
    }
    result
}

// 32-bit port I/O
fn outl(port: i64, value: i64) {
    unsafe {
        asm!(
            "outl %eax, %dx",
            in("dx") port,
            in("eax") value,
            options(nomem, nostack, att_syntax)
        );
    }
}

fn inl(port: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "inl %dx, %eax",
            in("dx") port,
            lateout("eax") result,
            options(nomem, nostack, att_syntax)
        );
    }
    result
}

// PCI configuration ports
const PCI_CONFIG_ADDR: i64 = 0xCF8;
const PCI_CONFIG_DATA: i64 = 0xCFC;

// Read PCI configuration space (32-bit)
// bus: 0-255, device: 0-31, func: 0-7, offset: 0-252 (must be 4-byte aligned)
fn pci_config_read(bus: i64, device: i64, func: i64, offset: i64) -> i64 {
    // Build PCI config address: 0x80000000 | bus << 16 | device << 11 | func << 8 | offset
    let addr = 0x80000000 + (bus * 65536) + (device * 2048) + (func * 256) + offset;
    outl(PCI_CONFIG_ADDR, addr);
    inl(PCI_CONFIG_DATA)
}

// Write PCI configuration space (32-bit)
// bus: 0-255, device: 0-31, func: 0-7, offset: 0-252 (must be 4-byte aligned)
fn pci_config_write(bus: i64, device: i64, func: i64, offset: i64, value: i64) {
    let addr = 0x80000000 + (bus * 65536) + (device * 2048) + (func * 256) + offset;
    outl(PCI_CONFIG_ADDR, addr);
    outl(PCI_CONFIG_DATA, value);
}

// Test PCI config ports (L1.5)
// Reads vendor/device ID from bus 0, device 0 (host bridge)
fn test_pci_ports() {
    // [PCI]
    serial_out(91);   // [
    serial_out(80);   // P
    serial_out(67);   // C
    serial_out(73);   // I
    serial_out(93);   // ]
    serial_out(32);   // space

    // Read vendor/device ID from PCI 0:0.0
    let vendor_device = pci_config_read(0, 0, 0, 0);

    // Extract vendor ID (lower 16 bits)
    let vendor = vendor_device % 65536;

    // 0xFFFF means no device, but we should have host bridge
    if vendor != 0xFFFF {
        // OK vendor=
        serial_out(79);   // O
        serial_out(75);   // K
        serial_out(32);   // space
        serial_hex(vendor as u64);
        serial_newline();
    } else {
        // No device
        serial_out(78);   // N
        serial_out(79);   // O
        serial_out(78);   // N
        serial_out(69);   // E
        serial_newline();
    }
}

// ============================================================
// Memory Operations (L2)
// ============================================================

// L2.1: Copy memory block from src to dst
fn memcpy(dst: i64, src: i64, len: i64) {
    let mut i: i64 = 0;
    while i < len {
        let byte = read_byte_addr(src + i);
        write_byte_addr(dst + i, byte);
        i = i + 1;
    }
}

// L2.2: Fill memory block with value
fn memset(dst: i64, value: i64, len: i64) {
    let mut i: i64 = 0;
    while i < len {
        write_byte_addr(dst + i, value);
        i = i + 1;
    }
}

// L2.3: Compare memory blocks
// Returns: 0 if equal, difference of first non-matching byte otherwise
fn memcmp(a: i64, b: i64, len: i64) -> i64 {
    let mut i: i64 = 0;
    let mut result: i64 = 0;
    while i < len && result == 0 {
        let byte_a = read_byte_addr(a + i);
        let byte_b = read_byte_addr(b + i);
        if byte_a != byte_b {
            result = byte_a - byte_b;
        }
        i = i + 1;
    }
    result
}

// L2.4: Zero memory block (wrapper for memset)
fn memzero(dst: i64, len: i64) {
    memset(dst, 0, len);
}

// Test memory operations (L2.5/L2.6)
// Uses addresses in safe memory region above kernel
const MEM_TEST_ADDR_A: i64 = 0x200000;  // 2MB - test buffer A
const MEM_TEST_ADDR_B: i64 = 0x210000;  // 2MB + 64KB - test buffer B

fn test_memory_ops() {
    // [MEM]
    serial_out(91);   // [
    serial_out(77);   // M
    serial_out(69);   // E
    serial_out(77);   // M
    serial_out(93);   // ]
    serial_out(32);   // space

    // Test 1: memset 512 bytes and verify
    memset(MEM_TEST_ADDR_A, 0xAB, 512);
    let mut ok: bool = true;
    let mut i: i64 = 0;
    while i < 512 {
        if read_byte_addr(MEM_TEST_ADDR_A + i) != 0xAB {
            ok = false;
        }
        i = i + 1;
    }

    if ok {
        // set OK
        serial_out(115); // s
        serial_out(101); // e
        serial_out(116); // t
        serial_out(32);  // space
        serial_out(79);  // O
        serial_out(75);  // K
        serial_out(32);  // space
    } else {
        // set FAIL
        serial_out(115); // s
        serial_out(101); // e
        serial_out(116); // t
        serial_out(32);  // space
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
        serial_newline();
        return;
    }

    // Test 2: memcpy 512 bytes and verify
    memzero(MEM_TEST_ADDR_B, 512);
    memcpy(MEM_TEST_ADDR_B, MEM_TEST_ADDR_A, 512);

    if memcmp(MEM_TEST_ADDR_A, MEM_TEST_ADDR_B, 512) == 0 {
        // cpy OK
        serial_out(99);  // c
        serial_out(112); // p
        serial_out(121); // y
        serial_out(32);  // space
        serial_out(79);  // O
        serial_out(75);  // K
        serial_out(32);  // space
    } else {
        // cpy FAIL
        serial_out(99);  // c
        serial_out(112); // p
        serial_out(121); // y
        serial_out(32);  // space
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
        serial_newline();
        return;
    }

    // Test 3: memcmp difference detection
    write_byte_addr(MEM_TEST_ADDR_B + 256, 0xFF);  // Change one byte
    if memcmp(MEM_TEST_ADDR_A, MEM_TEST_ADDR_B, 512) != 0 {
        // cmp OK
        serial_out(99);  // c
        serial_out(109); // m
        serial_out(112); // p
        serial_out(32);  // space
        serial_out(79);  // O
        serial_out(75);  // K
        serial_out(32);  // space
    } else {
        // cmp FAIL
        serial_out(99);  // c
        serial_out(109); // m
        serial_out(112); // p
        serial_out(32);  // space
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
        serial_newline();
        return;
    }

    // Test 4: Large buffer test (64KB)
    memset(MEM_TEST_ADDR_A, 0x55, 65536);
    memcpy(MEM_TEST_ADDR_B, MEM_TEST_ADDR_A, 65536);

    // Spot check: first, middle, last bytes
    let first_ok = read_byte_addr(MEM_TEST_ADDR_B) == 0x55;
    let mid_ok = read_byte_addr(MEM_TEST_ADDR_B + 32768) == 0x55;
    let last_ok = read_byte_addr(MEM_TEST_ADDR_B + 65535) == 0x55;

    if first_ok && mid_ok && last_ok {
        // 64K OK
        serial_out(54);  // 6
        serial_out(52);  // 4
        serial_out(75);  // K
        serial_out(32);  // space
        serial_out(79);  // O
        serial_out(75);  // K
    } else {
        // 64K FAIL
        serial_out(54);  // 6
        serial_out(52);  // 4
        serial_out(75);  // K
        serial_out(32);  // space
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
    }

    serial_newline();
}

// ============================================================
// Volatile Operations (L3)
// ============================================================

// L3.5: Test volatile operations (uses compiler built-ins)
fn test_volatile_ops() {
    // [VOL]
    serial_out(91);   // [
    serial_out(86);   // V
    serial_out(79);   // O
    serial_out(76);   // L
    serial_out(93);   // ]
    serial_out(32);   // space

    // Test volatile write/read at 0x600000 (safe memory region)
    test_volatile_u8();
    test_volatile_u16();
    test_volatile_u32();

    serial_newline();
}

// L3.0: Test volatile u8 read/write
fn test_volatile_u8() {
    let ptr = 0x600000 as *mut u8;
    unsafe {
        volatile_write_u8(ptr, 0xAB);
        let val: u8 = volatile_read_u8(ptr);
        let expected: u8 = 0xAB;
        if val == expected {
            serial_out(56);  // 8
            serial_out(79);  // O
            serial_out(75);  // K
            serial_out(32);  // space
        } else {
            serial_out(56);  // 8
            serial_out(70);  // F
            serial_out(32);  // space
        }
    }
}

// L3.1/L3.2: Test volatile u16 read/write
fn test_volatile_u16() {
    let ptr = 0x600000 as *mut u16;
    unsafe {
        volatile_write_u16(ptr, 0xBEEF);
        let val: u16 = volatile_read_u16(ptr);
        let expected: u16 = 0xBEEF;
        if val == expected {
            serial_out(49);  // 1
            serial_out(54);  // 6
            serial_out(79);  // O
            serial_out(75);  // K
            serial_out(32);  // space
        } else {
            serial_out(49);  // 1
            serial_out(54);  // 6
            serial_out(70);  // F
            serial_out(32);  // space
        }
    }
}

// L3.3/L3.4: Test volatile u32 read/write
fn test_volatile_u32() {
    let ptr = 0x600000 as *mut u32;
    unsafe {
        volatile_write_u32(ptr, 0xDEADBEEF);
        let val: u32 = volatile_read_u32(ptr);
        let expected: u32 = 0xDEADBEEF;
        if val == expected {
            serial_out(51);  // 3
            serial_out(50);  // 2
            serial_out(79);  // O
            serial_out(75);  // K
        } else {
            serial_out(51);  // 3
            serial_out(50);  // 2
            serial_out(70);  // F
        }
    }
}

// ============================================================
// Struct Testing (L4)
// ============================================================

// L4.5: Test struct as function parameter
fn point_sum(p: Point) -> i64 {
    p.x + p.y
}

// L4.6: Test struct as return value
fn make_point(x: i64, y: i64) -> Point {
    Point { x: x, y: y }
}

// L4: Main struct test function
fn test_struct_ops() {
    // [STR]
    serial_out(91);   // [
    serial_out(83);   // S
    serial_out(84);   // T
    serial_out(82);   // R
    serial_out(93);   // ]
    serial_out(32);   // space

    // L4.2: Test struct instantiation
    let p = Point { x: 10, y: 20 };

    // L4.3: Test struct field read
    let px = p.x;
    let py = p.y;
    if px == 10 {
        if py == 20 {
            serial_out(105);  // i
            serial_out(79);   // O
            serial_out(75);   // K
            serial_out(32);   // space
        } else {
            serial_out(105);  // i
            serial_out(70);   // F
            serial_out(32);   // space
        }
    } else {
        serial_out(105);  // i
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L4.4: Test struct field write (L7 fix: now works!)
    let mut p2 = Point { x: 0, y: 0 };
    p2.x = 30;
    p2.y = 40;
    let p2x = p2.x;
    let p2y = p2.y;
    if p2x == 30 {
        if p2y == 40 {
            serial_out(119);  // w
            serial_out(79);   // O
            serial_out(75);   // K
            serial_out(32);   // space
        } else {
            serial_out(119);  // w
            serial_out(70);   // F
            serial_out(32);   // space
        }
    } else {
        serial_out(119);  // w
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L4.5: Test struct as function parameter
    let p3 = Point { x: 5, y: 7 };
    let sum = point_sum(p3);
    if sum == 12 {
        serial_out(112);  // p
        serial_out(79);   // O
        serial_out(75);   // K
        serial_out(32);   // space
    } else {
        serial_out(112);  // p
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L4.6: Test struct as return value
    let p4 = make_point(100, 200);
    if p4.x == 100 {
        if p4.y == 200 {
            serial_out(114);  // r
            serial_out(79);   // O
            serial_out(75);   // K
            serial_out(32);   // space
        } else {
            serial_out(114);  // r
            serial_out(70);   // F
            serial_out(32);   // space
        }
    } else {
        serial_out(114);  // r
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L4.7: Test nested structs (L9 fix: all nested access works!)
    let origin = Point { x: 0, y: 0 };
    let size = Point { x: 100, y: 50 };
    let rect = Rect { origin: origin, size: size };

    // Test first nested struct
    let ox = rect.origin.x;
    let oy = rect.origin.y;

    // Test second nested struct
    let sx = rect.size.x;
    let sy = rect.size.y;

    // Test first nested: should work
    if ox == 0 {
        if oy == 0 {
            serial_out(110);  // n
            serial_out(49);   // 1
            serial_out(79);   // O
            serial_out(75);   // K
            serial_out(32);   // space
        } else {
            serial_out(110);  // n
            serial_out(49);   // 1
            serial_out(70);   // F
            serial_out(32);   // space
        }
    } else {
        serial_out(110);  // n
        serial_out(49);   // 1
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // Test second nested: now fixed!
    if sx == 100 {
        serial_out(110);  // n
        serial_out(50);   // 2
        serial_out(79);   // O
        serial_out(75);   // K
    } else {
        serial_out(110);  // n
        serial_out(50);   // 2
        serial_out(70);   // F
    }

    // Test three-level nesting: canvas.line.end.y
    let start = Point { x: 10, y: 20 };
    let end = Point { x: 30, y: 40 };
    let line = Line { start: start, end: end };
    let canvas = Canvas { line: line, color: 255 };

    // Access three-level nested field: canvas.line.end.y (should be 40)
    let ey = canvas.line.end.y;
    if ey == 40 {
        serial_out(110);  // n
        serial_out(51);   // 3
        serial_out(79);   // O
        serial_out(75);   // K
    } else {
        serial_out(110);  // n
        serial_out(51);   // 3
        serial_out(70);   // F
    }

    // L9.4: Test nested field write
    // Create a mutable rect and modify a nested field
    let mut r2 = Rect { origin: Point { x: 1, y: 2 }, size: Point { x: 3, y: 4 } };
    r2.origin.x = 99;  // Modify nested field
    let wx = r2.origin.x;
    if wx == 99 {
        serial_out(32);   // space
        serial_out(119);  // w
        serial_out(79);   // O
        serial_out(75);   // K
    } else {
        serial_out(32);   // space
        serial_out(119);  // w
        serial_out(70);   // F
    }

    serial_newline();
}

// ============================================================
// L5: Array Testing
// ============================================================

// L5.5: Helper function that takes array as parameter
// This tests passing arrays to functions (L8.1 fix)
fn sum_array_4(arr: [i64; 4]) -> i64 {
    let sum = arr[0] + arr[1] + arr[2] + arr[3];
    sum
}

// L8.3: Function that returns an array
fn make_array_4() -> [i64; 4] {
    let arr: [i64; 4] = [100, 200, 300, 400];
    arr
}

// L5: Main array test function
fn test_array_ops() {
    // [ARR]
    serial_out(91);   // [
    serial_out(65);   // A
    serial_out(82);   // R
    serial_out(82);   // R
    serial_out(93);   // ]
    serial_out(32);   // space

    // L5.1: Test static array declaration
    // L5.2: Test array element read
    let arr: [i64; 4] = [10, 20, 30, 40];
    let v0 = arr[0];
    let v1 = arr[1];
    let v2 = arr[2];
    let v3 = arr[3];

    if v0 == 10 {
        if v1 == 20 {
            if v2 == 30 {
                if v3 == 40 {
                    // "decl OK"
                    serial_out(100);  // d
                    serial_out(79);   // O
                    serial_out(75);   // K
                    serial_out(32);   // space
                } else {
                    serial_out(100);  // d
                    serial_out(70);   // F
                    serial_out(51);   // 3
                    serial_out(32);   // space
                }
            } else {
                serial_out(100);  // d
                serial_out(70);   // F
                serial_out(50);   // 2
                serial_out(32);   // space
            }
        } else {
            serial_out(100);  // d
            serial_out(70);   // F
            serial_out(49);   // 1
            serial_out(32);   // space
        }
    } else {
        serial_out(100);  // d
        serial_out(70);   // F
        serial_out(48);   // 0
        serial_out(32);   // space
    }

    // L5.3: Test array element write
    let mut arr2: [i64; 4] = [0, 0, 0, 0];
    arr2[0] = 100;
    arr2[1] = 200;
    arr2[2] = 300;
    arr2[3] = 400;
    let w0 = arr2[0];
    let w1 = arr2[1];
    let w2 = arr2[2];
    let w3 = arr2[3];

    if w0 == 100 {
        if w1 == 200 {
            if w2 == 300 {
                if w3 == 400 {
                    // "wOK" - write works
                    serial_out(119);  // w
                    serial_out(79);   // O
                    serial_out(75);   // K
                    serial_out(32);   // space
                } else {
                    serial_out(119);  // w
                    serial_out(70);   // F
                    serial_out(51);   // 3
                    serial_out(32);   // space
                }
            } else {
                serial_out(119);  // w
                serial_out(70);   // F
                serial_out(50);   // 2
                serial_out(32);   // space
            }
        } else {
            serial_out(119);  // w
            serial_out(70);   // F
            serial_out(49);   // 1
            serial_out(32);   // space
        }
    } else {
        // "wN" - write not supported (like struct field write)
        serial_out(119);  // w
        serial_out(78);   // N
        serial_out(32);   // space
    }

    // L5.5: Test array as function parameter (L8.1 fix)
    // Previously: LLVM error "Call parameter type does not match"
    // Now: Arrays passed by pointer, should work!
    let test_arr: [i64; 4] = [10, 20, 30, 40];
    let sum_result = sum_array_4(test_arr);
    if sum_result == 100 {
        // "pOK" - parameter works!
        serial_out(112);  // p
        serial_out(79);   // O
        serial_out(75);   // K
        serial_out(32);   // space
    } else {
        // "pF" - parameter failed
        serial_out(112);  // p
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L5.6: Test larger arrays
    // Test an 8-element array (64 bytes)
    let big: [i64; 8] = [11, 22, 33, 44, 55, 66, 77, 88];
    let b0 = big[0];
    let b7 = big[7];
    if b0 == 11 {
        if b7 == 88 {
            // "8OK" - 8-element array works
            serial_out(56);   // 8
            serial_out(79);   // O
            serial_out(75);   // K
            serial_out(32);   // space
        } else {
            serial_out(56);   // 8
            serial_out(70);   // F
            serial_out(55);   // 7
            serial_out(32);   // space
        }
    } else {
        serial_out(56);   // 8
        serial_out(70);   // F
        serial_out(48);   // 0
        serial_out(32);   // space
    }

    // L8.2: Test array repeat syntax [value; count]
    let zeros: [i64; 4] = [0; 4];
    let ones: [i64; 8] = [1; 8];
    if zeros[0] == 0 {
        if zeros[3] == 0 {
            if ones[0] == 1 {
                if ones[7] == 1 {
                    // "rOK" - repeat works
                    serial_out(114);  // r
                    serial_out(79);   // O
                    serial_out(75);   // K
                    serial_out(32);   // space
                } else {
                    serial_out(114);  // r
                    serial_out(70);   // F
                    serial_out(52);   // 4
                    serial_out(32);   // space
                }
            } else {
                serial_out(114);  // r
                serial_out(70);   // F
                serial_out(51);   // 3
                serial_out(32);   // space
            }
        } else {
            serial_out(114);  // r
            serial_out(70);   // F
            serial_out(50);   // 2
            serial_out(32);   // space
        }
    } else {
        serial_out(114);  // r
        serial_out(70);   // F
        serial_out(49);   // 1
        serial_out(32);   // space
    }

    // L8.3: Test array return from function
    let returned_arr = make_array_4();
    if returned_arr[0] == 100 {
        if returned_arr[3] == 400 {
            // "fOK" - function return works
            serial_out(102);  // f
            serial_out(79);   // O
            serial_out(75);   // K
            serial_out(32);   // space
        } else {
            serial_out(102);  // f
            serial_out(70);   // F
            serial_out(50);   // 2
            serial_out(32);   // space
        }
    } else {
        serial_out(102);  // f
        serial_out(70);   // F
        serial_out(49);   // 1
        serial_out(32);   // space
    }

    // L8.6: Test arr.len() intrinsic
    let len_arr: [i64; 4] = [1, 2, 3, 4];
    let len8_arr: [i64; 8] = [0; 8];
    let len4 = len_arr.len();
    let len8 = len8_arr.len();
    if len4 == 4 {
        if len8 == 8 {
            // "lOK" - len() works
            serial_out(108);  // l
            serial_out(79);   // O
            serial_out(75);   // K
            serial_out(32);   // space
        } else {
            serial_out(108);  // l
            serial_out(70);   // F
            serial_out(50);   // 2
            serial_out(32);   // space
        }
    } else {
        serial_out(108);  // l
        serial_out(70);   // F
        serial_out(49);   // 1
        serial_out(32);   // space
    }

    // L5.4: Test array in struct
    let arr4: [i64; 4] = [5, 10, 15, 20];
    let buf = Buffer4 { data: arr4, len: 4 };
    let buf_len = buf.len;
    // Try to access array element through struct
    if buf_len == 4 {
        // Length field access works
        serial_out(115);  // s
        serial_out(79);   // O
        serial_out(75);   // K
        serial_out(32);   // space
    } else {
        serial_out(115);  // s
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L8.4: Test struct.array[i] access (L8 fix: now works!)
    let el0 = buf.data[0];  // Should be 5
    let el2 = buf.data[2];  // Should be 15
    if el0 == 5 {
        if el2 == 15 {
            serial_out(97);   // a
            serial_out(79);   // O
            serial_out(75);   // K
        } else {
            serial_out(97);   // a
            serial_out(70);   // F
        }
    } else {
        serial_out(97);   // a
        serial_out(70);   // F
    }

    serial_newline();
}

// ============================================================
// L6: Enum Testing
// ============================================================

// L6: Main enum test function
fn test_enum_ops() {
    // [ENM]
    serial_out(91);   // [
    serial_out(69);   // E
    serial_out(78);   // N
    serial_out(77);   // M
    serial_out(93);   // ]
    serial_out(32);   // space

    // L10.1: Test enum instantiation
    let state: ProcState = ProcState::Ready;

    // Output "eOK" if enum instantiation works
    serial_out(101);  // e
    serial_out(79);   // O
    serial_out(75);   // K
    serial_out(32);   // space

    // L10.2: Test enum comparison (positive)
    if state == ProcState::Ready {
        serial_out(99);   // c
        serial_out(79);   // O
        serial_out(75);   // K
        serial_out(32);   // space
    } else {
        serial_out(99);   // c
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L10.2: Test enum comparison (negative)
    if state == ProcState::Waiting {
        serial_out(110);  // n
        serial_out(70);   // F
    } else {
        serial_out(110);  // n
        serial_out(79);   // O
        serial_out(75);   // K
        serial_out(32);   // space
    }

    // L10.3: Test match with enum
    let result = match state {
        ProcState::Unused => 0,
        ProcState::Ready => 1,
        ProcState::Running => 2,
        ProcState::Waiting => 3,
        ProcState::Zombie => 4,
        ProcState::Stopped => 5,
    };
    if result == 1 {
        serial_out(109);  // m
        serial_out(79);   // O
        serial_out(75);   // K
        serial_out(32);   // space
    } else {
        serial_out(109);  // m
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L10.4: Test Option with payload
    let opt: Option<i64> = Option::Some(42);
    let val = match opt {
        Option::Some(x) => x,
        Option::None => 0,
    };
    if val == 42 {
        serial_out(111);  // o
        serial_out(79);   // O
        serial_out(75);   // K
        serial_out(32);   // space
    } else {
        serial_out(111);  // o
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L10.4: Test Option::None
    let none_opt: Option<i64> = Option::None;
    let none_val = match none_opt {
        Option::Some(x) => x,
        Option::None => 99,
    };
    if none_val == 99 {
        serial_out(78);   // N
        serial_out(79);   // O
        serial_out(75);   // K
        serial_out(32);   // space
    } else {
        serial_out(78);   // N
        serial_out(70);   // F
        serial_out(32);   // space
    }

    // L10.5: Test Result::Ok
    let res_ok: Result<i64, i64> = Result::Ok(100);
    let ok_val = match res_ok {
        Result::Ok(v) => v,
        Result::Err(_) => 0,
    };
    if ok_val == 100 {
        serial_out(82);   // R
        serial_out(79);   // O
        serial_out(75);   // K
    } else {
        serial_out(82);   // R
        serial_out(70);   // F
    }

    // L12.1: Test match on integer literals
    let test_int: i64 = 42;
    let int_result = match test_int {
        0 => 0,
        1 => 1,
        42 => 42,
        _ => -1,
    };
    if int_result == 42 {
        serial_out(32);   // space
        serial_out(73);   // I
        serial_out(79);   // O
        serial_out(75);   // K
    } else {
        serial_out(32);   // space
        serial_out(73);   // I
        serial_out(70);   // F
    }

    serial_newline();
}

// ============================================================
// VGA Text Mode
// ============================================================

fn vga_color(fg: i64, bg: i64) -> u8 {
    let mut result: u8 = (bg * 16) as u8;
    result |= fg as u8;
    result
}

fn vga_write_char(x: i64, y: i64, ch: i64, color: u8) {
    let offset = (y * VGA_WIDTH + x) * 2;
    let addr = VGA_BUFFER + offset;
    let ptr = addr as *mut u8;

    unsafe {
        volatile_write_u8(ptr, ch as u8);
        let color_ptr = (addr + 1) as *mut u8;
        volatile_write_u8(color_ptr, color);
    }
}

fn vga_clear() {
    let color = vga_color(COLOR_WHITE, COLOR_BLACK);
    let mut i: i64 = 0;
    while i < VGA_WIDTH * VGA_HEIGHT {
        vga_write_char(i % VGA_WIDTH, i / VGA_WIDTH, 32, color);
        i = i + 1;
    }
}

fn hex_digit(n: u64) -> i64 {
    if n < 10 {
        (48 + n) as i64   // '0' - '9'
    } else {
        (65 + n - 10) as i64  // 'A' - 'F'
    }
}

fn vga_write_hex(x: i64, y: i64, value: u64, color: u8) {
    // "0x" prefix
    vga_write_char(x, y, 48, color);      // '0'
    vga_write_char(x + 1, y, 120, color); // 'x'

    // Write 16 hex digits
    let mut i: i64 = 0;
    while i < 16 {
        let shift = (60 - i * 4) as u64;
        let nibble = bit_and(shr_u64(value, shift), 0xF);
        vga_write_char(x + 2 + i, y, hex_digit(nibble), color);
        i = i + 1;
    }
}

fn vga_write_dec(x: i64, y: i64, value: u64, color: u8) -> i64 {
    if value == 0 {
        vga_write_char(x, y, 48, color);
        return 1;
    }

    // Count digits
    let mut temp = value;
    let mut count: i64 = 0;
    while temp > 0 {
        temp = temp / 10;
        count = count + 1;
    }

    // Write in reverse
    temp = value;
    let mut i: i64 = count - 1;
    while i >= 0 {
        let digit = (48 + (temp % 10)) as i64;
        vga_write_char(x + i, y, digit, color);
        temp = temp / 10;
        i = i - 1;
    }

    count
}

fn vga_write_char_color(x: i64, y: i64, ch: i64, color: i64) {
    let offset = (y * VGA_WIDTH + x) * 2;
    let addr = VGA_BUFFER + offset;
    unsafe {
        let ptr = addr as *mut u8;
        volatile_write_u8(ptr, ch as u8);
        let color_ptr = (addr + 1) as *mut u8;
        volatile_write_u8(color_ptr, color as u8);
    }
}

fn vga_write_hex_byte(x: i64, y: i64, value: u64, color: i64) {
    let high = bit_and(shr_u64(value, 4), 0xF);
    let low = bit_and(value, 0xF);

    let ch_high: i64 = if high < 10 { 48 + (high as i64) } else { 55 + (high as i64) };
    let ch_low: i64 = if low < 10 { 48 + (low as i64) } else { 55 + (low as i64) };

    vga_write_char_color(x, y, ch_high, color);
    vga_write_char_color(x + 1, y, ch_low, color);
}

// ============================================================
// Serial Port (COM1)
// ============================================================

fn serial_out(ch: i64) {
    outb(COM1, ch);
}

// Output 8 hex digits (32 bits)
fn serial_hex32(value: u64) {
    serial_out(48);  // '0'
    serial_out(120); // 'x'

    let mut val = value;

    let mut i: i64 = 0;
    while i < 8 {
        let mut nibble: u64 = 0;
        nibble = val / 0x10000000;

        let chr: i64 = if nibble < 10 {
            48 + (nibble as i64)
        } else {
            55 + (nibble as i64)
        };

        outb(COM1, chr);

        val = val * 16;
        val = val % 0x100000000;

        i = i + 1;
    }
}

fn serial_hex(value: u64) {
    serial_hex32(value % 0x100000000);
}

fn serial_hex64(value: u64) {
    serial_out(48);  // '0'
    serial_out(120); // 'x'

    let mut i: i64 = 60;
    while i >= 0 {
        let nibble = bit_and(shr_u64(value, i as u64), 0xF) as i64;
        let ch: i64 = if nibble < 10 { 48 + nibble } else { 55 + nibble };
        serial_out(ch);
        i = i - 4;
    }
}

fn serial_newline() {
    serial_out(10);
}

// Print decimal number to serial
fn serial_print_dec(value: i64) {
    if value == 0 {
        serial_out(48);
        return;
    }

    let mut num = value;
    if num < 0 {
        serial_out(45);  // '-'
        num = 0 - num;
    }

    // Count digits
    let mut temp = num;
    let mut digits: i64 = 0;
    while temp > 0 {
        temp = temp / 10;
        digits = digits + 1;
    }

    // Build divisor
    let mut divisor: i64 = 1;
    let mut d: i64 = 1;
    while d < digits {
        divisor = divisor * 10;
        d = d + 1;
    }

    // Print digits
    while divisor > 0 {
        let digit = num / divisor;
        serial_out(48 + digit);
        num = num - (digit * divisor);
        divisor = divisor / 10;
    }
}

// ============================================================
// CPU Control
// ============================================================

fn cli() {
    unsafe { asm!("cli", options(nomem, nostack)); }
}

fn sti() {
    unsafe { asm!("sti", options(nomem, nostack)); }
}

fn hlt() {
    unsafe { asm!("hlt", options(nomem, nostack)); }
}

// ============================================================
// Memory Access Helpers
// ============================================================

fn read_u32_at(base: i64, offset: i64) -> u32 {
    let addr = base + offset;
    let mut result: u32 = 0;
    unsafe {
        asm!(
            "movl (%rcx), %eax",
            in("rcx") addr,
            lateout("eax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn read_u64_at(base: i64, offset: i64) -> u64 {
    let addr = base + offset;
    let mut result: u64 = 0;
    unsafe {
        asm!(
            "movq (%rcx), %rax",
            in("rcx") addr,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn write_u64_at(base: i64, offset: i64, value: u64) {
    let addr = base + offset;
    unsafe {
        asm!(
            "movq %rax, (%rcx)",
            in("rcx") addr,
            in("rax") value,
            options(nostack, att_syntax)
        );
    }
}

fn read_u64_addr(addr: i64) -> u64 {
    let mut result: u64 = 0;
    unsafe {
        asm!(
            "movq (%rcx), %rax",
            in("rcx") addr,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn write_u64_addr(addr: i64, value: u64) {
    unsafe {
        asm!(
            "movq %rax, (%rcx)",
            in("rcx") addr,
            in("rax") value,
            options(nostack, att_syntax)
        );
    }
}

fn write_u16_addr(addr: i64, value: i64) {
    unsafe {
        asm!(
            "movw %ax, (%rcx)",
            in("rcx") addr,
            in("ax") value,
            options(nostack, att_syntax)
        );
    }
}

fn write_u32_addr(addr: i64, value: i64) {
    unsafe {
        asm!(
            "movl %eax, (%rcx)",
            in("rcx") addr,
            in("eax") value,
            options(nostack, att_syntax)
        );
    }
}

// ============================================================
// Physical Memory Manager
// ============================================================

fn pmm_init_bitmap() {
    // Initialize all bitmap entries to 0xFFFFFFFFFFFFFFFF (all pages used)
    let mut offset: i64 = 0;
    while offset < 32768 {
        write_u64_at(PMM_BITMAP_ADDR, offset, 0xFFFFFFFFFFFFFFFF);
        offset = offset + 8;
    }
}

fn pmm_init(max_addr: u64) {
    pmm_init_bitmap();

    let max_pages = max_addr / (PAGE_SIZE as u64);
    write_u64_at(PMM_STATE_ADDR, 0, max_pages);
    write_u64_at(PMM_STATE_ADDR, 8, 0);
    write_u64_at(PMM_STATE_ADDR, 16, max_addr);
}

fn pmm_mark_free(base: u64, length: u64) {
    // Mark a range of physical memory as free in the PMM bitmap
    // Each bit in the bitmap represents a 4KB page
    // 0 = free, 1 = used

    let start_page = base / (PAGE_SIZE as u64);
    let end_page = (base + length) / (PAGE_SIZE as u64);

    // Optimized: mark entire qwords as free when possible
    let start_qword = (start_page + 63) / 64;  // First full qword
    let end_qword = end_page / 64;              // Last full qword

    // Mark full qwords as 0 (all pages free)
    let mut qword = start_qword;
    while qword < end_qword {
        let bitmap_offset = (qword * 8) as i64;
        write_u64_at(PMM_BITMAP_ADDR, bitmap_offset, 0);
        qword = qword + 1;
    }

    // Count pages freed
    let full_qwords = if end_qword > start_qword { end_qword - start_qword } else { 0 };
    let pages_freed = full_qwords * 64;

    // Update free count
    let current_free = read_u64_at(PMM_STATE_ADDR, 8) as u64;
    write_u64_at(PMM_STATE_ADDR, 8, current_free + pages_freed);

}

// Unused hint address (kept for potential future optimization)
const PMM_HINT_ADDR: i64 = 0x408020;

fn pmm_alloc_page() -> u64 {
    // Simple linear search from qword 32 (where free pages start)
    // Pages 0-2047 are reserved, pages 2048+ are free
    let mut idx: u64 = 32;

    while idx < 512 {
        let bitmap_offset = (idx * 8) as i64;
        let entry = read_u64_at(PMM_BITMAP_ADDR, bitmap_offset);

        // Fast path: if entry is 0, all 64 pages are free
        if entry == 0 {
            write_u64_at(PMM_BITMAP_ADDR, bitmap_offset, 1);
            let current_free = read_u64_at(PMM_STATE_ADDR, 8);
            if current_free > 0 {
                write_u64_at(PMM_STATE_ADDR, 8, current_free - 1);
            }
            return (idx * 64) * (PAGE_SIZE as u64);
        }

        // Check if entry has any free pages (not all 1s)
        let entry_plus_one = entry + 1;
        if entry_plus_one != 0 {
            // Find first free bit
            let mut bit: u64 = 0;
            while bit < 64 {
                let mask = shl_u64(1, bit);
                if bit_and(entry, mask) == 0 {
                    // Found free page - mark as used
                    write_u64_at(PMM_BITMAP_ADDR, bitmap_offset, bit_or(entry, mask));
                    let current_free = read_u64_at(PMM_STATE_ADDR, 8);
                    if current_free > 0 {
                        write_u64_at(PMM_STATE_ADDR, 8, current_free - 1);
                    }
                    return (idx * 64 + bit) * (PAGE_SIZE as u64);
                }
                bit = bit + 1;
            }
        }
        idx = idx + 1;
    }

    0  // Out of memory
}

fn pmm_free_page(addr: u64) {
    if addr == 0 {
        return;
    }

    let page_size = PAGE_SIZE as u64;
    let page = addr / page_size;
    let idx = page / 64;
    let bit = page % 64;

    if idx >= 4096 {
        return;
    }

    let bitmap_offset = (idx * 8) as i64;
    let current = read_u64_at(PMM_BITMAP_ADDR, bitmap_offset) as u64;
    let mask = shl_u64(1, bit);

    if bit_and(current, mask) != 0 {
        write_u64_at(PMM_BITMAP_ADDR, bitmap_offset, bit_and(current, bit_not(mask)));

        let current_free = read_u64_at(PMM_STATE_ADDR, 8) as u64;
        write_u64_at(PMM_STATE_ADDR, 8, current_free + 1);
    }
}

fn pmm_get_free_pages() -> u64 {
    read_u64_at(PMM_STATE_ADDR, 8) as u64
}

// ============================================================
// Multiboot Parsing
// ============================================================

fn parse_multiboot(mb_info_addr: i64) -> u64 {
    // Use fixed 128MB (pmm_mark_free now uses chunked approach)
    let usable_start: u64 = 0x800000;   // 8MB
    let usable_end: u64 = 0x8000000;    // 128MB
    pmm_mark_free(usable_start, usable_end - usable_start);

    usable_end
}

// ============================================================
// Multiboot Module Loading
// ============================================================

// Global storage for init module info
const INIT_MODULE_START: i64 = 0x600;     // Store init start addr
const INIT_MODULE_END: i64 = 0x608;       // Store init end addr
const INIT_MODULE_PRESENT: i64 = 0x610;   // Flag: 1 if init found

// Load modules from multiboot info into RAMFS
fn load_multiboot_modules(mb_info_addr: i64) {
    if mb_info_addr == 0 {
        return;
    }

    let flags = read_u32_at(mb_info_addr, 0) as i64;

    // Check if modules flag is set (bit 3)
    let has_mods = flags & MB_FLAG_MODS;
    if has_mods == 0 {
        serial_out(78);  // N
        serial_out(79);  // O
        serial_out(77);  // M
        serial_out(79);  // O
        serial_out(68);  // D
        serial_newline();
        return;
    }

    let mods_count = read_u32_at(mb_info_addr, MB_MODS_COUNT) as i64;
    let mods_addr = read_u32_at(mb_info_addr, MB_MODS_ADDR) as i64;

    // Print module count and address for debugging
    serial_out(77);  // M
    serial_out(79);  // O
    serial_out(68);  // D
    serial_out(83);  // S
    serial_out(58);  // :
    serial_out(32);  // space
    serial_print_dec(mods_count);
    serial_out(32);  // space
    serial_out(64);  // @
    serial_hex32(mods_addr as u64);
    serial_newline();

    // Process each module
    let mut i: i64 = 0;
    while i < mods_count {
        let mod_entry = mods_addr + (i * 16);  // Each entry is 16 bytes

        let mod_start = read_u32_at(mod_entry, MOD_START) as i64;
        let mod_end = read_u32_at(mod_entry, MOD_END) as i64;
        let mod_size = mod_end - mod_start;

        // Print module info using serial_hex (which masks to 32 bits)
        serial_out(32);  // space
        serial_out(91);  // [
        serial_print_dec(i);
        serial_out(93);  // ]
        serial_out(32);  // space
        serial_hex(mod_start as u64);
        serial_out(32);  // space
        serial_out(45);  // -
        serial_out(32);  // space
        serial_hex(mod_end as u64);
        serial_out(32);  // space
        serial_out(40);  // (
        serial_print_dec(mod_size);
        serial_out(41);  // )
        serial_newline();

        // Store first module as init
        if i == 0 {
            write_u64_addr(INIT_MODULE_START, mod_start as u64);
            write_u64_addr(INIT_MODULE_END, mod_end as u64);
            write_u64_addr(INIT_MODULE_PRESENT, 1);

            // Copy module to RAMFS as "init"
            copy_module_to_ramfs(mod_start, mod_size);
        }

        // Store second module as vfs
        if i == 1 {
            copy_vfs_module_to_ramfs(mod_start, mod_size);
        }

        // Store third module as console
        if i == 2 {
            copy_console_module_to_ramfs(mod_start, mod_size);
        }

        // Store fourth module as shell (Phase 3)
        if i == 3 {
            copy_shell_module_to_ramfs(mod_start, mod_size);
        }

        i = i + 1;
    }
}

// Copy module bytes to RAMFS file named "init"
fn copy_module_to_ramfs(src_addr: i64, size: i64) {
    // Create "init" file in RAMFS
    // "init" = 105, 110, 105, 116
    let file_idx = ramfs_create_file_internal(105, 110, 105, 116, 0, 0, 0, 0);
    if file_idx < 0 {
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        return;
    }

    // Get data block address for this file
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
    let dest_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

    // Copy bytes from module to RAMFS
    let mut offset: i64 = 0;
    while offset < size {
        let byte = read_byte_addr(src_addr + offset);
        write_byte_addr(dest_addr + offset, byte);
        offset = offset + 1;
    }

    // Set file size
    ramfs_set_file_size(file_idx, size);

    // Print confirmation
    serial_out(73);  // I
    serial_out(78);  // N
    serial_out(73);  // I
    serial_out(84);  // T
    serial_out(58);  // :
    serial_out(32);  // space
    serial_print_dec(size);
    serial_out(66);  // B
    serial_newline();
}

// Copy module bytes to RAMFS file named "vfs"
fn copy_vfs_module_to_ramfs(src_addr: i64, size: i64) {
    // Create "vfs" file in RAMFS
    // "vfs" = 118, 102, 115
    let file_idx = ramfs_create_file_internal(118, 102, 115, 0, 0, 0, 0, 0);
    if file_idx < 0 {
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        return;
    }

    // Get data block address for this file
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
    let dest_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

    // Copy bytes from module to RAMFS
    let mut offset: i64 = 0;
    while offset < size {
        let byte = read_byte_addr(src_addr + offset);
        write_byte_addr(dest_addr + offset, byte);
        offset = offset + 1;
    }

    // Set file size
    ramfs_set_file_size(file_idx, size);

    // Print confirmation
    serial_out(86);  // V
    serial_out(70);  // F
    serial_out(83);  // S
    serial_out(58);  // :
    serial_out(32);  // space
    serial_print_dec(size);
    serial_out(66);  // B
    serial_newline();
}

// Copy module bytes to RAMFS file named "console"
fn copy_console_module_to_ramfs(src_addr: i64, size: i64) {
    // Create "console" file in RAMFS
    // "console" = 99, 111, 110, 115, 111, 108, 101
    let file_idx = ramfs_create_file_internal(99, 111, 110, 115, 111, 108, 101, 0);
    if file_idx < 0 {
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        return;
    }

    // Get data block address for this file
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
    let dest_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

    // Copy bytes from module to RAMFS
    let mut offset: i64 = 0;
    while offset < size {
        let byte = read_byte_addr(src_addr + offset);
        write_byte_addr(dest_addr + offset, byte);
        offset = offset + 1;
    }

    // Set file size
    ramfs_set_file_size(file_idx, size);

    // Print confirmation
    serial_out(67);  // C
    serial_out(79);  // O
    serial_out(78);  // N
    serial_out(58);  // :
    serial_out(32);  // space
    serial_print_dec(size);
    serial_out(66);  // B
    serial_newline();
}

// Copy module bytes to RAMFS file named "shell" (Phase 3)
fn copy_shell_module_to_ramfs(src_addr: i64, size: i64) {
    // Create "shell" file in RAMFS
    // "shell" = 115, 104, 101, 108, 108
    let file_idx = ramfs_create_file_internal(115, 104, 101, 108, 108, 0, 0, 0);
    if file_idx < 0 {
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        return;
    }

    // Get data block address for this file
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
    let dest_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

    // Copy bytes from module to RAMFS
    let mut offset: i64 = 0;
    while offset < size {
        let byte = read_byte_addr(src_addr + offset);
        write_byte_addr(dest_addr + offset, byte);
        offset = offset + 1;
    }

    // Set file size
    ramfs_set_file_size(file_idx, size);

    // Print confirmation
    serial_out(83);  // S
    serial_out(72);  // H
    serial_out(76);  // L
    serial_out(58);  // :
    serial_out(32);  // space
    serial_print_dec(size);
    serial_out(66);  // B
    serial_newline();
}

// Execute init from RAMFS
// Init is loaded at its native ELF address (0x800000) since it's PID 1
fn exec_init() -> i64 {
    let present = read_u64_addr(INIT_MODULE_PRESENT);
    if present != 1 {
        return 0 - 1;
    }

    // Execute "init" from RAMFS
    // "init" packed: 0x74696E69
    let name: u64 = 0x74696E69;  // "init" in little-endian

    // Init is special: load at ELF_LOAD_BASE (0x800000) directly
    // since it's the first userspace process (PID 1)
    elf_exec_native(name)
}

// Execute VFS server from RAMFS (Phase 1: VFS in userspace)
// VFS Server loads at 0x900000 and becomes PID 2
fn exec_vfs() -> i64 {
    // Execute "vfs" from RAMFS
    // "vfs\0" packed: 0x00736676 (little-endian: 'v'=0x76, 'f'=0x66, 's'=0x73, '\0'=0x00)
    let name: u64 = 0x00736676;

    // Find file in RAMFS
    let file_idx = ramfs_find_file(name);
    if file_idx < 0 {
        serial_out(86);  // V
        serial_out(78);  // N
        serial_out(70);  // F (not found)
        serial_newline();
        return -1;
    }

    // VFS Server loads at 0x900000 (after Init at 0x800000)
    elf_exec_native(name)
}

// Execute Console server from RAMFS (Phase 2: Console in userspace)
// Console Server loads at 0xA00000 and becomes PID 3
fn exec_console() -> i64 {
    // Execute "console" from RAMFS
    // "console" packed: little-endian c=0x63, o=0x6F, n=0x6E, s=0x73, o=0x6F, l=0x6C, e=0x65
    let name: u64 = 0x656C6F736E6F63;  // "console" in little-endian

    // Find file in RAMFS
    let file_idx = ramfs_find_file(name);
    if file_idx < 0 {
        serial_out(67);  // C
        serial_out(78);  // N
        serial_out(70);  // F (not found)
        serial_newline();
        return -1;
    }

    // Console Server loads at 0xA00000
    elf_exec_native(name)
}

// Execute Shell server from RAMFS (Phase 3: Shell in userspace)
// Shell Server loads at 0xB00000 and becomes PID 4
fn exec_shell() -> i64 {
    // Execute "shell" from RAMFS
    // "shell" packed: little-endian s=0x73, h=0x68, e=0x65, l=0x6C, l=0x6C
    let name: u64 = 0x6C6C656873;  // "shell" in little-endian

    // Find file in RAMFS
    let file_idx = ramfs_find_file(name);
    if file_idx < 0 {
        serial_out(83);  // S
        serial_out(78);  // N
        serial_out(70);  // F (not found)
        serial_newline();
        return -1;
    }

    // Shell Server loads at 0xB00000
    elf_exec_native(name)
}

// ============================================================
// Memory Management Initialization
// ============================================================

fn init_memory(mb_info_addr: i64) -> bool {
    let green = vga_color(COLOR_GREEN, COLOR_BLACK);
    let white = vga_color(COLOR_WHITE, COLOR_BLACK);
    let yellow = vga_color(COLOR_YELLOW, COLOR_BLACK);

    // Line 2: "PMM init..."
    vga_write_char(0, 2, 80, white);   // P
    vga_write_char(1, 2, 77, white);   // M
    vga_write_char(2, 2, 77, white);   // M
    vga_write_char(3, 2, 32, white);   // space
    vga_write_char(4, 2, 105, white);  // i
    vga_write_char(5, 2, 110, white);  // n
    vga_write_char(6, 2, 105, white);  // i
    vga_write_char(7, 2, 116, white);  // t

    pmm_init(0x40000000);

    let max_addr = parse_multiboot(mb_info_addr);

    // Line 3: "Max: 0x..."
    vga_write_char(0, 3, 77, white);   // M
    vga_write_char(1, 3, 97, white);   // a
    vga_write_char(2, 3, 120, white);  // x
    vga_write_char(3, 3, 58, white);   // :
    vga_write_char(4, 3, 32, white);   // space
    vga_write_hex(5, 3, max_addr, yellow);

    serial_out(77);  // M
    serial_out(97);  // a
    serial_out(120); // x
    serial_out(58);  // :
    serial_out(32);  // space
    serial_hex(max_addr);
    serial_newline();

    let free_pages = pmm_get_free_pages();
    let free_mb = (free_pages * (PAGE_SIZE as u64)) / (1024 * 1024);

    // Line 4: "Free: XXX MB"
    vga_write_char(0, 4, 70, white);   // F
    vga_write_char(1, 4, 114, white);  // r
    vga_write_char(2, 4, 101, white);  // e
    vga_write_char(3, 4, 101, white);  // e
    vga_write_char(4, 4, 58, white);   // :
    vga_write_char(5, 4, 32, white);   // space
    let d1 = vga_write_dec(6, 4, free_mb, green);
    vga_write_char(6 + d1, 4, 32, white);
    vga_write_char(7 + d1, 4, 77, white);  // M
    vga_write_char(8 + d1, 4, 66, white);  // B

    let test_page = pmm_alloc_page();

    // Line 5: "Alloc: 0x..."
    vga_write_char(0, 5, 65, white);   // A
    vga_write_char(1, 5, 108, white);  // l
    vga_write_char(2, 5, 108, white);  // l
    vga_write_char(3, 5, 111, white);  // o
    vga_write_char(4, 5, 99, white);   // c
    vga_write_char(5, 5, 58, white);   // :
    vga_write_char(6, 5, 32, white);   // space
    vga_write_hex(7, 5, test_page, green);

    pmm_free_page(test_page);

    let test_page2 = pmm_alloc_page();

    // Line 6: "Again: 0x..."
    vga_write_char(0, 6, 65, white);   // A
    vga_write_char(1, 6, 103, white);  // g
    vga_write_char(2, 6, 97, white);   // a
    vga_write_char(3, 6, 105, white);  // i
    vga_write_char(4, 6, 110, white);  // n
    vga_write_char(5, 6, 58, white);   // :
    vga_write_char(6, 6, 32, white);   // space
    vga_write_hex(7, 6, test_page2, green);

    let ok = test_page == test_page2;

    // Line 8: "MM OK" or "MM FAIL"
    if ok {
        vga_write_char(0, 8, 77, green);   // M
        vga_write_char(1, 8, 77, green);   // M
        vga_write_char(2, 8, 32, white);   // space
        vga_write_char(3, 8, 79, green);   // O
        vga_write_char(4, 8, 75, green);   // K

        serial_out(77);
        serial_out(77);
        serial_out(32);
        serial_out(79);
        serial_out(75);
        serial_newline();
    } else {
        let red = vga_color(COLOR_RED, COLOR_BLACK);
        vga_write_char(0, 8, 77, red);
        vga_write_char(1, 8, 77, red);
        vga_write_char(2, 8, 32, white);
        vga_write_char(3, 8, 70, red);
        vga_write_char(4, 8, 65, red);
        vga_write_char(5, 8, 73, red);
        vga_write_char(6, 8, 76, red);
    }

    ok
}

// ============================================================
// PIC (8259 Programmable Interrupt Controller)
// ============================================================

fn pic_init() {
    // Save masks
    let mask1 = inb(PIC1_DATA);
    let mask2 = inb(PIC2_DATA);

    // ICW1: init + ICW4 needed
    outb(PIC1_CMD, 0x11);
    io_wait();
    outb(PIC2_CMD, 0x11);
    io_wait();

    // ICW2: vector offsets
    outb(PIC1_DATA, 32);  // IRQ 0-7 -> INT 32-39
    io_wait();
    outb(PIC2_DATA, 40);  // IRQ 8-15 -> INT 40-47
    io_wait();

    // ICW3: cascading
    outb(PIC1_DATA, 4);   // Slave on IRQ2
    io_wait();
    outb(PIC2_DATA, 2);   // Cascade identity
    io_wait();

    // ICW4: 8086 mode
    outb(PIC1_DATA, 1);
    io_wait();
    outb(PIC2_DATA, 1);
    io_wait();

    // Enable only timer (IRQ0) and keyboard (IRQ1)
    outb(PIC1_DATA, 0xFC);
    outb(PIC2_DATA, 0xFF);
}

fn pic_send_eoi(irq: i64) {
    if irq >= 8 {
        outb(PIC2_CMD, PIC_EOI);
    }
    outb(PIC1_CMD, PIC_EOI);
}

// ============================================================
// PIT (Programmable Interval Timer)
// ============================================================

fn timer_init() {
    // Initialize tick counter
    write_u64_addr(TICK_COUNT_ADDR, 0);

    // PIT command: channel 0, lobyte/hibyte, mode 3 (square wave)
    outb(PIT_CMD, 0x36);

    // Send divisor (PIT_DIVISOR = 11932, low byte = 0x9C, high byte = 0x2E)
    let divisor_low = PIT_DIVISOR & 0xFF;
    let divisor_high = (PIT_DIVISOR / 256) & 0xFF;
    outb(PIT_CHANNEL0, divisor_low);
    outb(PIT_CHANNEL0, divisor_high);
}

fn timer_get_ticks() -> u64 {
    read_u64_addr(TICK_COUNT_ADDR)
}

// ============================================================
// IDT (Interrupt Descriptor Table)
// ============================================================

fn idt_set_gate(index: i64, handler: i64) {
    let entry_addr = IDT_ADDR + (index * IDT_ENTRY_SIZE);

    // Extract handler address parts using division/modulo
    // This avoids potential issues with bit operations
    let handler_u64 = handler as u64;
    let offset_low = (handler_u64 % 65536) as i64;        // bits 0-15
    let offset_mid = ((handler_u64 / 65536) % 65536) as i64;  // bits 16-31
    let offset_high = (handler_u64 / 0x100000000) as i64;     // bits 32-63

    // Type attributes byte: 0x8E = Present + DPL0 + IntGate
    // At byte 5, IST at byte 4 = 0
    // As u16 little-endian: 0x8E00 (byte4=0x00, byte5=0x8E)
    let type_attr: i64 = 0x8E00;

    // Write IDT entry (16 bytes)
    write_u16_addr(entry_addr + 0, offset_low);           // offset_low
    write_u16_addr(entry_addr + 2, KERNEL_CS);            // selector
    write_u16_addr(entry_addr + 4, type_attr);            // IST=0, type
    write_u16_addr(entry_addr + 6, offset_mid);           // offset_mid
    write_u32_addr(entry_addr + 8, offset_high);          // offset_high
    write_u32_addr(entry_addr + 12, 0);                   // reserved

}

fn idt_clear() {
    let mut i: i64 = 0;
    while i < IDT_ENTRIES * IDT_ENTRY_SIZE {
        write_u64_addr(IDT_ADDR + i, 0);
        i = i + 8;
    }
}

fn idt_set_gate_dpl(index: i64, handler: i64, dpl: i64) {
    let entry_addr = IDT_ADDR + (index * IDT_ENTRY_SIZE);

    // Extract handler address parts using division/modulo
    let handler_u64 = handler as u64;
    let offset_low = (handler_u64 % 65536) as i64;
    let offset_mid = ((handler_u64 / 65536) % 65536) as i64;
    let offset_high = (handler_u64 / 0x100000000) as i64;

    // Type attributes byte: Present + DPL + IntGate
    // 0x8E = Present(1) + DPL0(00) + 0 + IntGate(1110)
    // 0xEE = Present(1) + DPL3(11) + 0 + IntGate(1110)
    let type_attr: i64 = if dpl == 3 { 0xEE00 } else { 0x8E00 };

    // Write IDT entry (16 bytes)
    write_u16_addr(entry_addr + 0, offset_low);
    write_u16_addr(entry_addr + 2, KERNEL_CS);
    write_u16_addr(entry_addr + 4, type_attr);
    write_u16_addr(entry_addr + 6, offset_mid);
    write_u32_addr(entry_addr + 8, offset_high);
    write_u32_addr(entry_addr + 12, 0);
}

fn idt_init() {
    // Clear all entries
    idt_clear();

    // Get ISR stub table address
    let stub_table = get_isr_stub_ptr();

    // Set up all 48 handlers (32 exceptions + 16 IRQs)
    let mut i: i64 = 0;
    while i < 48 {
        let handler = read_u64_addr(stub_table + (i * 8));
        idt_set_gate(i, handler as i64);
        i = i + 1;
    }

    // Set up syscall handler at INT 0x80 (entry 128) with DPL=3
    let syscall_ptr = get_syscall_stub_ptr();
    let syscall_handler = read_u64_addr(syscall_ptr);
    idt_set_gate_dpl(128, syscall_handler as i64, 3);

    // Load IDT
    idt_load();
}

fn get_isr_stub_ptr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea isr_stub_table(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn get_syscall_stub_ptr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea isr_syscall_ptr(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn idt_load() {
    // Set up IDTR at IDTR_ADDR
    let limit = (IDT_ENTRIES * IDT_ENTRY_SIZE - 1) as i64;
    write_u16_addr(IDTR_ADDR, limit);

    // Write base (64-bit)
    unsafe {
        asm!(
            "movq %rax, 2(%rcx)",
            in("rcx") IDTR_ADDR,
            in("rax") IDT_ADDR,
            options(nostack, att_syntax)
        );
    }

    // Load IDT
    unsafe {
        asm!(
            "lidt (%rax)",
            in("rax") IDTR_ADDR,
            options(nostack, att_syntax)
        );
    }
}

// ============================================================
// Interrupt Handler (called from assembly)
// ============================================================

fn read_stack_u64(base: i64, offset: i64) -> u64 {
    read_u64_addr(base + offset)
}

fn read_cr2() -> u64 {
    let mut result: u64 = 0;
    unsafe {
        asm!(
            "mov %cr2, %rax",
            lateout("rax") result,
            options(nomem, nostack, att_syntax)
        );
    }
    result
}

fn serial_hex64(value: u64) {
    serial_out(48);  // '0'
    serial_out(120); // 'x'

    let mut i: i64 = 60;
    while i >= 0 {
        let nibble = bit_and(shr_u64(value, i as u64), 0xF) as i64;
        let ch: i64 = if nibble < 10 { 48 + nibble } else { 55 + nibble };
        serial_out(ch);
        i = i - 4;
    }
}

// ISR handler - called from assembly (isr_common)
// Sets SWITCH_RSP_ADDR to new RSP if context switch needed, 0 otherwise
pub fn isr_handler(frame_ptr: i64) {
    // Clear switch RSP at start
    write_u64_addr(SWITCH_RSP_ADDR, 0);

    // Stack layout:
    //   [0]   = DS
    //   [8]   = R15
    //   [16]  = R14
    //   [24]  = R13
    //   [32]  = R12
    //   [40]  = R11
    //   [48]  = R10
    //   [56]  = R9
    //   [64]  = R8
    //   [72]  = RBP
    //   [80]  = RDI
    //   [88]  = RSI
    //   [96]  = RDX
    //   [104] = RCX
    //   [112] = RBX
    //   [120] = RAX
    //   [128] = interrupt number
    //   [136] = error code
    //   [144] = RIP

    let int_num = read_stack_u64(frame_ptr, 128) as i64;

    // L14: Interrupt dispatch using match
    // Categories: 0-31 = CPU exceptions, 32-47 = IRQs, 128 = syscall
    match int_num {
        128 => {
            // System call (INT 0x80)
            // Syscall ABI: RAX = syscall number, RDI = arg1, RSI = arg2, RDX = arg3
            let syscall_num = read_stack_u64(frame_ptr, 120) as i64;  // RAX
            let arg1 = read_stack_u64(frame_ptr, 80) as i64;          // RDI
            let arg2 = read_stack_u64(frame_ptr, 88) as i64;          // RSI
            let arg3 = read_stack_u64(frame_ptr, 96) as i64;          // RDX

            let result = handle_syscall(syscall_num, arg1, arg2, arg3, frame_ptr);

            // Store result in RAX on the stack (will be restored by iretq)
            write_u64_addr(frame_ptr + 120, result as u64);
        },
        32 => {
            // Timer interrupt (IRQ 0) - needs special handling for context switch
            handle_irq(0);

            let current = get_current_pid();
            let current_state = pcb_get_state(current);
            if current_state == ProcState::Running {
                pcb_set_rsp(current, frame_ptr);
            }

            let new_rsp = schedule_pick_next();
            if new_rsp != 0 {
                write_u64_addr(SWITCH_RSP_ADDR, new_rsp as u64);
            }
        },
        33 => handle_irq(1),  // Keyboard interrupt (IRQ 1)
        _ => {
            // Handle remaining cases by category
            if int_num < 32 {
                // CPU Exception (0-31)
                let error_code = read_stack_u64(frame_ptr, 136);
                let rip = read_stack_u64(frame_ptr, 144);
                handle_exception(int_num, error_code, rip);
            } else if int_num < 48 {
                // Other hardware IRQs (34-47)
                handle_irq(int_num - 32);
            }
        },
    }
}

// ============================================================
// System Call Handler
// ============================================================

fn handle_syscall(num: i64, arg1: i64, arg2: i64, arg3: i64, frame_ptr: i64) -> i64 {
    // L14: Syscall dispatch using match expression
    match num {
        0 => syscall_yield(frame_ptr),          // SYS_YIELD
        1 => syscall_getpid(),                  // SYS_GETPID
        2 => syscall_print(arg1),               // SYS_PRINT
        3 => syscall_send(arg1, arg2),          // SYS_SEND
        4 => syscall_recv(arg1),                // SYS_RECV
        5 => syscall_exit(),                    // SYS_EXIT
        6 => syscall_open(arg1),                // SYS_OPEN
        7 => syscall_read(arg1, arg2),          // SYS_READ
        8 => syscall_write(arg1, arg2),         // SYS_WRITE
        9 => syscall_close(arg1),               // SYS_CLOSE
        10 => syscall_fstat(arg1),              // SYS_FSTAT
        11 => syscall_cap_create(arg1, arg2, arg3), // SYS_CAP_CREATE
        12 => syscall_cap_derive(arg1, arg2),   // SYS_CAP_DERIVE
        13 => syscall_cap_grant(arg1, arg2),    // SYS_CAP_GRANT
        14 => syscall_cap_revoke(arg1),         // SYS_CAP_REVOKE
        15 => syscall_cap_list(arg1),           // SYS_CAP_LIST
        16 => syscall_kb_read(),                // SYS_KB_READ
        17 => syscall_kb_avail(),               // SYS_KB_AVAIL
        18 => syscall_exec(arg1),               // SYS_EXEC
        19 => syscall_kill(arg1, arg2),         // SYS_KILL
        20 => syscall_wait(arg1, arg2, frame_ptr),    // SYS_WAIT (arg2=flags)
        21 => syscall_getppid(),                // SYS_GETPPID
        22 => syscall_shmget(arg1, arg2),       // SYS_SHMGET
        23 => syscall_shmat(arg1),              // SYS_SHMAT
        24 => syscall_shmdt(arg1),              // SYS_SHMDT
        25 => syscall_disk_read(arg1, arg2, arg3), // SYS_DISK_READ
        26 => syscall_disk_info(arg1),          // SYS_DISK_INFO
        27 => syscall_disk_write(arg1, arg2, arg3), // SYS_DISK_WRITE
        28 => syscall_pci_read(arg1, arg2),     // SYS_PCI_READ
        29 => syscall_pci_write(arg1, arg2, arg3), // SYS_PCI_WRITE
        30 => syscall_pci_enumerate(arg1, arg2), // SYS_PCI_ENUMERATE
        31 => syscall_irq_register(arg1, arg2), // SYS_IRQ_REGISTER
        32 => syscall_irq_unregister(arg1),     // SYS_IRQ_UNREGISTER
        33 => syscall_irq_ack(arg1),            // SYS_IRQ_ACK
        34 => syscall_time(),                   // SYS_TIME
        35 => syscall_sleep(arg1),              // SYS_SLEEP
        36 => syscall_vga_putchar(arg1, arg2, arg3, frame_ptr), // SYS_VGA_PUTCHAR
        37 => syscall_vga_setcursor(arg1, arg2), // SYS_VGA_SETCURSOR
        38 => syscall_vga_clear(arg1, arg2, arg3), // SYS_VGA_CLEAR
        39 => syscall_vga_scroll(arg1, arg2, arg3), // SYS_VGA_SCROLL
        40 => syscall_ramfs_file_count(),       // SYS_RAMFS_FILE_COUNT
        41 => syscall_ramfs_file_info(arg1),    // SYS_RAMFS_FILE_INFO
        42 => syscall_ramfs_read_byte(arg1, arg2), // SYS_RAMFS_READ_BYTE
        43 => syscall_ramfs_file_size(arg1),    // SYS_RAMFS_FILE_SIZE
        44 => syscall_proc_count(),             // SYS_PROC_COUNT
        45 => syscall_proc_state(arg1),         // SYS_PROC_STATE
        46 => syscall_ramfs_read_name(arg1, arg2), // SYS_RAMFS_READ_NAME
        // Network syscalls (50-66)
        50 => syscall_net_socket(arg1, arg2, arg3), // SYS_NET_SOCKET
        51 => syscall_net_bind(arg1, arg2, arg3),   // SYS_NET_BIND
        52 => syscall_net_listen(arg1, arg2),       // SYS_NET_LISTEN
        53 => syscall_net_accept(arg1),             // SYS_NET_ACCEPT
        54 => syscall_net_connect(arg1, arg2, arg3), // SYS_NET_CONNECT
        55 => syscall_net_send(arg1, arg2, arg3),   // SYS_NET_SEND
        56 => syscall_net_recv(arg1, arg2, arg3),   // SYS_NET_RECV
        57 => syscall_net_close(arg1),              // SYS_NET_CLOSE
        58 => syscall_net_config(arg1, arg2, arg3), // SYS_NET_CONFIG
        59 => syscall_net_status(arg1),             // SYS_NET_STATUS
        60 => syscall_net_resolve(arg1),            // SYS_NET_RESOLVE
        61 => syscall_net_ping(arg1, arg2),         // SYS_NET_PING
        62 => syscall_net_arp(arg1, arg2),          // SYS_NET_ARP
        63 => syscall_net_dhcp(),                   // SYS_NET_DHCP
        64 => syscall_net_getip(),                  // SYS_NET_GETIP
        65 => syscall_net_getmac(arg1),             // SYS_NET_GETMAC
        66 => syscall_net_poll(),                   // SYS_NET_POLL
        // Graphics syscalls (70-78)
        70 => syscall_fb_info(arg1),                 // SYS_FB_INFO
        71 => syscall_fb_pixel(arg1, arg2, arg3),    // SYS_FB_PIXEL
        72 => syscall_fb_rect(arg1, arg2, arg3, read_stack_u64(frame_ptr, 40) as i64, read_stack_u64(frame_ptr, 48) as i64), // SYS_FB_RECT (5 args)
        73 => syscall_fb_swap(),                     // SYS_FB_SWAP
        74 => syscall_fb_clear(arg1),                // SYS_FB_CLEAR
        75 => syscall_fb_blit(arg1, arg2, arg3, read_stack_u64(frame_ptr, 40) as i64, read_stack_u64(frame_ptr, 48) as i64), // SYS_FB_BLIT
        76 => syscall_fb_map(),                      // SYS_FB_MAP
        77 => syscall_fb_char(arg1, arg2, arg3, read_stack_u64(frame_ptr, 40) as i64), // SYS_FB_CHAR (x, y, char, color)
        78 => syscall_fb_text(arg1, arg2, arg3, read_stack_u64(frame_ptr, 40) as i64), // SYS_FB_TEXT (x, y, text_addr, color)
        // TLS syscalls (80-83)
        80 => syscall_tls_connect(arg1, arg2, arg3), // SYS_TLS_CONNECT
        81 => syscall_tls_send(arg1, arg2, arg3),    // SYS_TLS_SEND
        82 => syscall_tls_recv(arg1, arg2, arg3),    // SYS_TLS_RECV
        83 => syscall_tls_close(arg1),               // SYS_TLS_CLOSE
        90 => syscall_mouse_pos(),                   // SYS_MOUSE_POS
        91 => syscall_mouse_btn(),                   // SYS_MOUSE_BTN
        92 => syscall_mouse_set(arg1, arg2),         // SYS_MOUSE_SET
        _ => -1,                                // Unknown syscall
    }
}

// SYS_KB_READ - Read character from keyboard buffer
// Returns: ASCII character, or -1 if buffer empty
fn syscall_kb_read() -> i64 {
    // Debug: show buffer state before pop
    let head = read_u64_addr(KB_HEAD_ADDR) as i64;
    let tail = read_u64_addr(KB_TAIL_ADDR) as i64;

    let ch = kb_buffer_pop();
    // Debug: print buffer state and result
    if head != tail {
        // Buffer had data
        serial_out(66);  // B
        serial_out(58);  // :
        serial_hex64(head as u64);
        serial_out(47);  // /
        serial_hex64(tail as u64);
        serial_out(61);  // =
        if ch > 0 {
            serial_out(ch);
        } else {
            serial_out(63);  // ?
        }
        serial_newline();
    }
    ch
}

// SYS_KB_AVAIL - Check if keyboard buffer has data
// Returns: 1 if data available, 0 otherwise
fn syscall_kb_avail() -> i64 {
    if kb_buffer_avail() {
        1
    } else {
        0
    }
}

// SYS_EXEC - Execute ELF binary by filename
// arg1: filename as packed bytes (8 chars in u64)
// Returns: new PID on success, negative error on failure
fn syscall_exec(name_lo: i64) -> i64 {
    // Execute the ELF binary using memory-mapped loading (demand paging)
    // This loads pages on-demand instead of copying the entire ELF upfront
    elf_exec_mmap(name_lo as u64)
}

// SYS_YIELD - Yield CPU to scheduler
fn syscall_yield(frame_ptr: i64) -> i64 {
    let current = get_current_pid();

    // Save current RSP
    let current_state = pcb_get_state(current);
    if current_state == ProcState::Running {
        pcb_set_rsp(current, frame_ptr);
    }

    // Get next process RSP
    let new_rsp = schedule_pick_next();
    if new_rsp != 0 {
        write_u64_addr(SWITCH_RSP_ADDR, new_rsp as u64);
    }

    0
}

// SYS_GETPID - Get current process ID
fn syscall_getpid() -> i64 {
    get_current_pid()
}

// SYS_PRINT - Print character to serial
fn syscall_print(ch: i64) -> i64 {
    serial_out(ch);
    0
}

// SYS_EXIT - Exit current process
// Extended for Phase 11: sets ZOMBIE state and notifies parent
fn syscall_exit() -> i64 {
    syscall_exit_code(0)
}

// Exit with specific exit code
fn syscall_exit_code(exit_code: i64) -> i64 {
    let current = get_current_pid();
    let parent = pcb_get_parent(current);

    // Set exit code
    pcb_set_exit_code(current, exit_code);

    serial_out(80);  // P
    serial_out(current + 48);  // Process number
    serial_out(88);  // X
    serial_newline();

    // Check if parent exists and should be notified
    if parent > 0 && proc_is_valid(parent) {
        // Become zombie - wait for parent to reap
        pcb_set_state(current, ProcState::Zombie);

        // Send SIGCHLD to parent
        pcb_add_signal(parent, SIGCHLD);

        // If parent is waiting, wake it up
        let parent_state = pcb_get_state(parent);
        if parent_state == ProcState::Waiting {
            pcb_set_state(parent, ProcState::Ready);
        }
    } else {
        // No parent to notify, go directly to UNUSED
        pcb_set_state(current, ProcState::Unused);

        // Clean up child count for parent if any
        if parent >= 0 && proc_is_valid(parent) {
            let children = pcb_get_child_count(parent);
            if children > 0 {
                pcb_set_child_count(parent, children - 1);
            }
        }
    }

    // Yield to next process
    let new_rsp = schedule_pick_next();
    if new_rsp != 0 {
        write_u64_addr(SWITCH_RSP_ADDR, new_rsp as u64);
    }

    0
}

// ============================================================
// Signal Syscalls (Phase 11)
// ============================================================

// SYS_KILL - Send signal to a process
// arg1: target PID
// arg2: signal number
// Returns: 0 on success, negative error code on failure
fn syscall_kill(target_pid: i64, signum: i64) -> i64 {
    let current = get_current_pid();

    // Validate signal number
    if signum <= 0 || signum >= SIG_MAX {
        return SIG_ERR_INVALID;
    }

    // Validate target PID
    if target_pid < 0 || target_pid >= MAX_PROCS {
        return SIG_ERR_NO_PROC;
    }

    // Check if process exists
    if !proc_is_valid(target_pid) {
        return SIG_ERR_NO_PROC;
    }

    serial_out(75);  // K
    serial_out(73);  // I
    serial_out(76);  // L
    serial_out(76);  // L
    serial_out(58);  // :
    serial_out(48 + target_pid);
    serial_out(47);  // /
    serial_out(48 + signum);
    serial_newline();

    // Handle SIGKILL specially - immediate termination
    if signum == SIGKILL {
        let target_state = pcb_get_state(target_pid);
        // Can't kill zombie or unused process
        if target_state == ProcState::Zombie || target_state == ProcState::Unused {
            return SIG_ERR_NO_PROC;
        }

        // Force immediate termination
        pcb_set_exit_code(target_pid, 128 + SIGKILL);

        let parent = pcb_get_parent(target_pid);
        if parent > 0 && proc_is_valid(parent) {
            pcb_set_state(target_pid, ProcState::Zombie);
            pcb_add_signal(parent, SIGCHLD);
            let parent_state = pcb_get_state(parent);
            if parent_state == ProcState::Waiting {
                pcb_set_state(parent, ProcState::Ready);
            }
        } else {
            pcb_set_state(target_pid, ProcState::Unused);
        }
        return 0;
    }

    // Handle SIGSTOP - stop process
    if signum == SIGSTOP {
        let target_state = pcb_get_state(target_pid);
        if target_state == ProcState::Ready || target_state == ProcState::Running {
            pcb_set_state(target_pid, ProcState::Stopped);
        }
        return 0;
    }

    // Handle SIGCONT - continue stopped process
    if signum == SIGCONT {
        let target_state = pcb_get_state(target_pid);
        if target_state == ProcState::Stopped {
            pcb_set_state(target_pid, ProcState::Ready);
        }
        return 0;
    }

    // For other signals, add to pending signals
    pcb_add_signal(target_pid, signum);

    0
}

// SYS_WAIT - Wait for child process to terminate
// arg1: PID to wait for (-1 for any child)
// arg2: flags (WAIT_NOHANG=1 for non-blocking)
// frame_ptr: current stack frame for context switch
// Returns: PID of exited child, 0 if NOHANG and no zombie, or negative error
fn syscall_wait(wait_pid: i64, flags: i64, frame_ptr: i64) -> i64 {
    let current = get_current_pid();
    let children = pcb_get_child_count(current);

    // Check if we have any children
    if children == 0 {
        return SIG_ERR_NO_CHILD;
    }

    // Look for zombie child
    let mut found_pid: i64 = -1;
    let mut i: i64 = 0;
    let num_procs = get_num_procs();

    while i < num_procs {
        let state = pcb_get_state(i);
        let parent = pcb_get_parent(i);

        // Check if this is our zombie child
        if state == ProcState::Zombie && parent == current {
            // If wait_pid is -1 (any child) or matches
            if wait_pid < 0 || wait_pid == i {
                found_pid = i;
                i = num_procs;  // Exit loop
            }
        }
        i = i + 1;
    }

    // Found a zombie child - reap it
    if found_pid >= 0 {
        // Get exit code
        let exit_code = pcb_get_exit_code(found_pid);

        // Clean up zombie
        pcb_set_state(found_pid, ProcState::Unused);

        // Decrement child count
        let new_children = children - 1;
        pcb_set_child_count(current, new_children);

        // Clear SIGCHLD
        pcb_clear_signal(current, SIGCHLD);

        serial_out(87);  // W
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(84);  // T
        serial_out(58);  // :
        serial_out(48 + found_pid);
        serial_newline();

        // Return exit code in high bits, PID in low bits
        // Since we can't do bitwise easily: return just the PID for now
        return found_pid;
    }

    // No zombie found - check WAIT_NOHANG flag
    if flags == WAIT_NOHANG {
        // Non-blocking: return 0 to indicate no child exited yet
        return 0;
    }

    // Blocking wait: put process in WAITING state
    pcb_set_state(current, ProcState::Waiting);
    pcb_set_rsp(current, frame_ptr);

    // Context switch to another process
    let new_rsp = schedule_pick_next();
    if new_rsp != 0 {
        write_u64_addr(SWITCH_RSP_ADDR, new_rsp as u64);
    }

    // When we return from wait, the child PID should be available
    // For now, return -1 to indicate we're waiting
    SIG_ERR_NO_CHILD
}

// SYS_GETPPID - Get parent process ID
fn syscall_getppid() -> i64 {
    let current = get_current_pid();
    pcb_get_parent(current)
}

// ============================================================
// Shared Memory Syscalls (Phase 11)
// ============================================================

// Initialize shared memory table
fn shm_init() {
    let mut i: i64 = 0;
    while i < SHM_MAX_REGIONS {
        let entry = SHM_TABLE_ADDR + (i * SHM_ENTRY_SIZE);
        write_u64_addr(entry + SHM_KEY, 0);
        write_u64_addr(entry + SHM_ADDR, 0);
        write_u64_addr(entry + SHM_SIZE, 0);
        write_u64_addr(entry + SHM_REFCOUNT, 0);
        i = i + 1;
    }
}

// Find shared memory region by key
fn shm_find_by_key(key: i64) -> i64 {
    let mut result: i64 = -1;
    let mut i: i64 = 0;
    while i < SHM_MAX_REGIONS {
        let entry = SHM_TABLE_ADDR + (i * SHM_ENTRY_SIZE);
        let entry_key = read_u64_addr(entry + SHM_KEY) as i64;
        if entry_key == key && key != 0 {
            result = i;
            i = SHM_MAX_REGIONS;  // Exit loop
        }
        i = i + 1;
    }
    result
}

// Find free shared memory slot
fn shm_find_free() -> i64 {
    let mut result: i64 = -1;
    let mut i: i64 = 0;
    while i < SHM_MAX_REGIONS {
        let entry = SHM_TABLE_ADDR + (i * SHM_ENTRY_SIZE);
        let key = read_u64_addr(entry + SHM_KEY) as i64;
        if key == 0 {
            result = i;
            i = SHM_MAX_REGIONS;  // Exit loop
        }
        i = i + 1;
    }
    result
}

// SYS_SHMGET - Get or create shared memory region
// arg1: key (unique identifier)
// arg2: size (requested size, will be aligned to SHM_REGION_SIZE)
// Returns: shared memory ID (index), or negative error
fn syscall_shmget(key: i64, size: i64) -> i64 {
    // Check if key already exists
    if key > 0 {
        let existing = shm_find_by_key(key);
        if existing >= 0 {
            return existing;
        }
    }

    // Find free slot
    let slot = shm_find_free();
    if slot < 0 {
        return SHM_ERR_FULL;
    }

    // Validate size
    if size <= 0 || size > SHM_REGION_SIZE {
        return SHM_ERR_INVALID;
    }

    // Calculate address for this region
    let addr = SHM_BASE_ADDR + (slot * SHM_REGION_SIZE);

    // Initialize the shared memory entry
    let entry = SHM_TABLE_ADDR + (slot * SHM_ENTRY_SIZE);
    write_u64_addr(entry + SHM_KEY, key as u64);
    write_u64_addr(entry + SHM_ADDR, addr as u64);
    write_u64_addr(entry + SHM_SIZE, size as u64);
    write_u64_addr(entry + SHM_REFCOUNT, 0);

    // Zero the shared memory region
    let mut i: i64 = 0;
    while i < size {
        write_byte_addr(addr + i, 0);
        i = i + 1;
    }

    serial_out(83);  // S
    serial_out(72);  // H
    serial_out(77);  // M
    serial_out(58);  // :
    serial_out(48 + slot);
    serial_newline();

    slot
}

// SYS_SHMAT - Attach to shared memory region
// arg1: shared memory ID
// Returns: address of shared memory, or negative error
fn syscall_shmat(shm_id: i64) -> i64 {
    if shm_id < 0 || shm_id >= SHM_MAX_REGIONS {
        return SHM_ERR_INVALID;
    }

    let entry = SHM_TABLE_ADDR + (shm_id * SHM_ENTRY_SIZE);
    let key = read_u64_addr(entry + SHM_KEY) as i64;

    // Check if valid
    if key == 0 {
        return SHM_ERR_INVALID;
    }

    // Increment reference count
    let refcount = read_u64_addr(entry + SHM_REFCOUNT) as i64;
    write_u64_addr(entry + SHM_REFCOUNT, (refcount + 1) as u64);

    // Return address
    read_u64_addr(entry + SHM_ADDR) as i64
}

// SYS_SHMDT - Detach from shared memory region
// arg1: shared memory address
// Returns: 0 on success, negative error
fn syscall_shmdt(addr: i64) -> i64 {
    // Find which region this address belongs to
    let mut found: i64 = -1;
    let mut i: i64 = 0;
    while i < SHM_MAX_REGIONS {
        let entry = SHM_TABLE_ADDR + (i * SHM_ENTRY_SIZE);
        let entry_addr = read_u64_addr(entry + SHM_ADDR) as i64;
        let key = read_u64_addr(entry + SHM_KEY) as i64;
        if entry_addr == addr && key != 0 {
            found = i;
            i = SHM_MAX_REGIONS;  // Exit loop
        }
        i = i + 1;
    }

    if found < 0 {
        return SHM_ERR_INVALID;
    }

    // Decrement reference count
    let entry = SHM_TABLE_ADDR + (found * SHM_ENTRY_SIZE);
    let refcount = read_u64_addr(entry + SHM_REFCOUNT) as i64;
    if refcount > 0 {
        write_u64_addr(entry + SHM_REFCOUNT, (refcount - 1) as u64);
    }

    0
}

// ============================================================
// Memory-Mapped Files (Phase 13) - Demand Paging for ELFs
// ============================================================

// Initialize memory mapping table
fn mmap_init() {
    // Zero out all mapping entries
    let mut i: i64 = 0;
    while i < MMAP_MAX_ENTRIES {
        let entry = MMAP_TABLE_ADDR + (i * MMAP_ENTRY_SIZE);
        write_u64_addr(entry + MMAP_VADDR_START, 0);
        write_u64_addr(entry + MMAP_VADDR_END, 0);
        write_u64_addr(entry + MMAP_FILE_IDX, 0);
        write_u64_addr(entry + MMAP_FILE_OFFSET, 0);
        write_u64_addr(entry + MMAP_FLAGS, 0);
        write_u64_addr(entry + MMAP_PID, 0);
        write_u64_addr(entry + MMAP_PAGES_LOADED, 0);
        write_u64_addr(entry + MMAP_RESERVED, 0);
        i = i + 1;
    }
}

// Find a free mapping entry
// Returns: entry index, or -1 if none available
fn mmap_find_free() -> i64 {
    let mut i: i64 = 0;
    let mut result: i64 = -1;
    while i < MMAP_MAX_ENTRIES {
        let entry = MMAP_TABLE_ADDR + (i * MMAP_ENTRY_SIZE);
        let flags = read_u64_addr(entry + MMAP_FLAGS) as i64;
        if (flags % 2) == 0 {  // Check if MMAP_FLAG_VALID (bit 0) is clear
            if result == -1 {
                result = i;
            }
        }
        i = i + 1;
    }
    result
}

// Create a new memory mapping
// vaddr: virtual address to map (page-aligned)
// size: size of mapping in bytes
// file_idx: RAMFS file index
// file_offset: offset in file where data starts
// flags: MMAP_FLAG_READ | MMAP_FLAG_WRITE | MMAP_FLAG_EXEC
// pid: process that owns this mapping
// Returns: mapping index, or negative error
fn mmap_create(vaddr: i64, size: i64, file_idx: i64, file_offset: i64, flags: i64, pid: i64) -> i64 {
    // Validate parameters
    if vaddr <= 0 || size <= 0 {
        return MMAP_ERR_INVALID;
    }

    // Find free entry
    let idx = mmap_find_free();
    if idx < 0 {
        return MMAP_ERR_FULL;
    }

    // Page-align the addresses
    // Use division/multiplication for page alignment instead of bitwise AND
    let vaddr_aligned = (vaddr / MMAP_PAGE_SIZE) * MMAP_PAGE_SIZE;  // Align down to page
    let vaddr_end = ((vaddr + size + MMAP_PAGE_SIZE - 1) / MMAP_PAGE_SIZE) * MMAP_PAGE_SIZE;  // Align up

    // Setup the mapping entry
    let entry = MMAP_TABLE_ADDR + (idx * MMAP_ENTRY_SIZE);
    write_u64_addr(entry + MMAP_VADDR_START, vaddr_aligned as u64);
    write_u64_addr(entry + MMAP_VADDR_END, vaddr_end as u64);
    write_u64_addr(entry + MMAP_FILE_IDX, file_idx as u64);
    write_u64_addr(entry + MMAP_FILE_OFFSET, file_offset as u64);
    write_u64_addr(entry + MMAP_FLAGS, (flags + MMAP_FLAG_VALID) as u64);
    write_u64_addr(entry + MMAP_PID, pid as u64);
    write_u64_addr(entry + MMAP_PAGES_LOADED, 0);  // No pages loaded yet

    // Debug output
    serial_out(77);  // M
    serial_out(77);  // M
    serial_out(65);  // A
    serial_out(80);  // P
    serial_out(58);  // :
    serial_hex32(vaddr_aligned as u64);
    serial_out(45);  // -
    serial_hex32(vaddr_end as u64);
    serial_newline();

    // Unmap all pages in this range to trigger page faults
    // This is critical for demand paging - we need to clear the identity mapping
    let mut page_addr = vaddr_aligned;
    while page_addr < vaddr_end {
        mmap_unmap_page(page_addr as u64);
        page_addr = page_addr + MMAP_PAGE_SIZE;
    }

    idx
}

// Find mapping entry that contains the given virtual address for a specific PID
// Returns: entry index, or -1 if not found
fn mmap_find(vaddr: i64, pid: i64) -> i64 {
    let vaddr_u = vaddr as u64;
    let mut i: i64 = 0;
    let mut result: i64 = -1;
    let mut found_any: i64 = 0;
    while i < MMAP_MAX_ENTRIES {
        let entry = MMAP_TABLE_ADDR + (i * MMAP_ENTRY_SIZE);
        let flags = read_u64_addr(entry + MMAP_FLAGS);

        if (flags % 2) != 0 {  // Check if MMAP_FLAG_VALID (bit 0) is set
            let entry_pid = read_u64_addr(entry + MMAP_PID) as i64;
            let vstart = read_u64_addr(entry + MMAP_VADDR_START);
            let vend = read_u64_addr(entry + MMAP_VADDR_END);

            // Debug: print first few valid entries
            if found_any < 3 {
                serial_out(91);  // [
                serial_print_dec(entry_pid);
                serial_out(58);  // :
                serial_hex32(vstart);
                serial_out(93);  // ]
                found_any = found_any + 1;
            }

            if entry_pid == pid && vaddr_u >= vstart && vaddr_u < vend {
                if result == -1 {
                    result = i;
                }
            }
        }
        i = i + 1;
    }
    if found_any > 0 {
        serial_newline();
    }
    result
}

// Remove all mappings for a specific process (called on process exit)
fn mmap_remove_process(pid: i64) {
    let mut i: i64 = 0;
    while i < MMAP_MAX_ENTRIES {
        let entry = MMAP_TABLE_ADDR + (i * MMAP_ENTRY_SIZE);
        let flags = read_u64_addr(entry + MMAP_FLAGS);
        let entry_pid = read_u64_addr(entry + MMAP_PID) as i64;

        if (flags % 2) != 0 && entry_pid == pid {  // Check MMAP_FLAG_VALID
            // Clear this entry
            write_u64_addr(entry + MMAP_FLAGS, 0);
            write_u64_addr(entry + MMAP_VADDR_START, 0);
            write_u64_addr(entry + MMAP_VADDR_END, 0);
        }
        i = i + 1;
    }
}

// Handle a page fault for a memory-mapped region
// Loads the page from the file and maps it
// vaddr: faulting virtual address
// pid: process that caused the fault
// Returns: 0 on success (page loaded), -1 if not a mapped region
fn mmap_handle_fault(vaddr: i64, pid: i64) -> i64 {
    // Debug: print PID we're looking for
    serial_out(80);  // P
    serial_out(73);  // I
    serial_out(68);  // D
    serial_out(58);  // :
    serial_print_dec(pid);
    serial_newline();

    // Find the mapping for this address
    let idx = mmap_find(vaddr, pid);
    if idx < 0 {
        serial_out(78);  // N
        serial_out(70);  // F
        serial_out(78);  // N (NFN = Not Found)
        serial_out(68);  // D
        serial_newline();
        return -1;  // Not a mapped region
    }

    let entry = MMAP_TABLE_ADDR + (idx * MMAP_ENTRY_SIZE);
    let vstart = read_u64_addr(entry + MMAP_VADDR_START) as i64;
    let file_idx = read_u64_addr(entry + MMAP_FILE_IDX) as i64;
    let file_offset = read_u64_addr(entry + MMAP_FILE_OFFSET) as i64;
    let flags = read_u64_addr(entry + MMAP_FLAGS) as i64;

    // Calculate which page within the mapping
    let page_vaddr = (vaddr / MMAP_PAGE_SIZE) * MMAP_PAGE_SIZE;  // Page-aligned address
    let page_offset_in_mapping = page_vaddr - vstart;
    let file_read_offset = file_offset + page_offset_in_mapping;

    // Debug output
    serial_out(80);  // P
    serial_out(70);  // F
    serial_out(76);  // L
    serial_out(68);  // D
    serial_out(58);  // :
    serial_hex32(page_vaddr as u64);
    serial_newline();

    // Debug: show PMM state before alloc
    let free_before = read_u64_at(PMM_STATE_ADDR, 8);
    serial_out(70);  // F
    serial_out(82);  // R
    serial_out(69);  // E
    serial_out(69);  // E
    serial_out(58);  // :
    serial_print_dec(free_before as i64);
    serial_newline();

    // Allocate a physical page for this virtual page
    let phys_page = pmm_alloc_page();
    if phys_page == 0 {
        serial_out(79);  // O
        serial_out(79);  // O
        serial_out(77);  // M (OOM)
        serial_newline();
        return -1;  // OOM
    }
    serial_out(65);  // A
    serial_out(76);  // L
    serial_out(76);  // L
    serial_out(79);  // O
    serial_out(67);  // C (ALLOC)
    serial_out(58);  // :
    serial_hex32(phys_page);
    serial_newline();

    // Load data from file into the physical page
    // Read MMAP_PAGE_SIZE bytes from the file
    let mut i: i64 = 0;
    while i < MMAP_PAGE_SIZE {
        let byte = ramfs_read_byte(file_idx, file_read_offset + i);
        if byte >= 0 {
            write_byte_addr((phys_page as i64) + i, byte);
        } else {
            // Past end of file, zero-fill
            write_byte_addr((phys_page as i64) + i, 0);
        }
        i = i + 1;
    }

    // Map the page in the page tables
    // Determine page flags based on mapping flags
    // Page flags: bit 0 = present, bit 1 = writable, bit 2 = user
    let mut page_flags: u64 = 5;  // PAGE_PRESENT (1) + PAGE_USER (4) = 5
    if (flags % (MMAP_FLAG_WRITE * 2)) >= MMAP_FLAG_WRITE {  // Check WRITE flag using modulo
        page_flags = page_flags + 2;  // PAGE_WRITE
    }

    // Map the page using direct page table manipulation
    let map_result = mmap_map_page(page_vaddr as u64, phys_page as u64, page_flags);
    if !map_result {
        serial_out(77);  // M
        serial_out(65);  // A
        serial_out(80);  // P
        serial_out(69);  // E (Map Error)
        serial_newline();
        // Free the physical page we allocated
        pmm_free_page(phys_page);
        return -1;
    }

    // Mark this page as loaded (simplified tracking - just count pages)
    let page_num = page_offset_in_mapping / MMAP_PAGE_SIZE;
    let loaded = read_u64_addr(entry + MMAP_PAGES_LOADED);
    write_u64_addr(entry + MMAP_PAGES_LOADED, loaded + 1);

    serial_out(80);  // P
    serial_out(71);  // G
    serial_out(79);  // O
    serial_out(75);  // K (Page OK)
    serial_newline();

    0  // Success
}

// ============================================================
// Kernel Page Table Pool Functions
// ============================================================

// State addresses for the kernel page table pool
// Uses first 16 bytes of pool for state tracking
const KPTPOOL_INIT_FLAG_ADDR: i64 = 0x4A0000;  // 1 = initialized
const KPTPOOL_NEXT_PAGE_ADDR: i64 = 0x4A0008;  // Next free page address

// Initialize the kernel page table pool
// Must be called early in boot, before any MMIO mapping
fn kptpool_init() {
    // Check if already initialized
    let init_flag = read_u64_addr(KPTPOOL_INIT_FLAG_ADDR);
    if init_flag == 1 {
        return;
    }

    // Zero out the entire pool
    let mut offset: i64 = 0;
    while offset < KPTPOOL_SIZE {
        write_u64_addr(KPTPOOL_BASE + offset, 0);
        offset = offset + 8;
    }

    // Start allocating from the second page (first 4KB used for tracking)
    write_u64_addr(KPTPOOL_NEXT_PAGE_ADDR, (KPTPOOL_BASE + 0x1000) as u64);
    write_u64_addr(KPTPOOL_INIT_FLAG_ADDR, 1);

    serial_out(75);  // K
    serial_out(80);  // P
    serial_out(84);  // T
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

// Allocate a page from the kernel page table pool
// Returns: physical address of the page, or 0 if pool exhausted
fn kptpool_alloc() -> u64 {
    // Check if initialized, init if not
    let init_flag = read_u64_addr(KPTPOOL_INIT_FLAG_ADDR);
    if init_flag != 1 {
        kptpool_init();
    }

    let pool_end = (KPTPOOL_BASE + KPTPOOL_SIZE) as u64;
    let next_page = read_u64_addr(KPTPOOL_NEXT_PAGE_ADDR);

    if next_page >= pool_end {
        // Pool exhausted - fall back to PMM
        return pmm_alloc_page() as u64;
    }

    // Allocate this page and advance pointer
    let page = next_page as u64;
    write_u64_addr(KPTPOOL_NEXT_PAGE_ADDR, next_page + 0x1000);

    // Zero the page
    let mut offset: i64 = 0;
    while offset < 0x1000 {
        write_u64_addr((page as i64) + offset, 0);
        offset = offset + 8;
    }

    page
}

// ============================================================
// Kernel Heap Functions
// ============================================================

// Heap state - mirrors structure in mm/heap.gl but managed locally
const HEAP_START_ADDR: u64 = 0x1000000;     // 16MB - heap start
const HEAP_MAX_ADDR: u64 = 0x5000000;       // 80MB - heap max (64MB heap space)
const HEAP_INITIAL_PAGES: u64 = 16;         // 64KB initial heap
const HEAP_STATE_ADDR: i64 = 0x4B0000;      // Heap state storage

// Heap state offsets
const HEAP_STATE_START: i64 = 0;       // HEAP_START
const HEAP_STATE_END: i64 = 8;         // HEAP_END
const HEAP_STATE_MAX: i64 = 16;        // HEAP_MAX
const HEAP_STATE_BUMP: i64 = 24;       // HEAP_BUMP
const HEAP_STATE_FREE_LIST: i64 = 32;  // FREE_LIST
const HEAP_STATE_TOTAL: i64 = 40;      // TOTAL_ALLOCATED
const HEAP_STATE_COUNT: i64 = 48;      // ALLOC_COUNT
const HEAP_STATE_PAGES: i64 = 56;      // HEAP_PAGES
const HEAP_STATE_INIT: i64 = 64;       // Initialized flag

const HEAP_ALIGNMENT: u64 = 16;
const HEAP_MIN_ALLOC: u64 = 32;
const HEAP_ALLOC_MAGIC: u64 = 0xDEADBEEFCAFEBABE;

// Initialize kernel heap with dynamic expansion support
fn init_heap() -> bool {
    // Check if already initialized
    let init_flag = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_INIT);
    if init_flag == 1 {
        return true;
    }

    serial_out(72);  // H
    serial_out(69);  // E
    serial_out(65);  // A
    serial_out(80);  // P
    serial_out(32);  // space
    serial_out(73);  // I
    serial_out(78);  // N
    serial_out(73);  // I
    serial_out(84);  // T
    serial_newline();

    // Initialize heap state
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_START, HEAP_START_ADDR);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_MAX, HEAP_MAX_ADDR);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_END, HEAP_START_ADDR);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_BUMP, HEAP_START_ADDR);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_FREE_LIST, 0);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_TOTAL, 0);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_COUNT, 0);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_PAGES, 0);

    // Map initial pages (64KB = 16 pages)
    let mut addr = HEAP_START_ADDR;
    let mut i: u64 = 0;
    while i < HEAP_INITIAL_PAGES {
        let phys = pmm_alloc_page();
        if phys == 0 {
            serial_out(79);  // O
            serial_out(79);  // O
            serial_out(77);  // M
            serial_newline();
            return false;
        }

        // Map with write permission (PAGE_PRESENT | PAGE_WRITE = 3)
        if !mmap_map_page(addr, phys, 3) {
            serial_out(77);  // M
            serial_out(65);  // A
            serial_out(80);  // P
            serial_out(70);  // F
            serial_newline();
            return false;
        }

        // Zero the page
        let mut offset: u64 = 0;
        while offset < 4096 {
            write_u64_addr((addr + offset) as i64, 0);
            offset = offset + 8;
        }

        addr = addr + 4096;
        i = i + 1;
    }

    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_END, addr);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_PAGES, HEAP_INITIAL_PAGES);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_INIT, 1);

    serial_out(72);  // H
    serial_out(69);  // E
    serial_out(65);  // A
    serial_out(80);  // P
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_out(32);  // space
    serial_print_dec((HEAP_INITIAL_PAGES * 4) as i64);  // KB
    serial_out(75);  // K
    serial_out(66);  // B
    serial_newline();

    true
}

// Align size up to alignment boundary
fn heap_align_up(size: u64, align: u64) -> u64 {
    bit_and(size + align - 1, bit_not(align - 1))
}

// Extend heap by allocating more pages
fn heap_extend(min_size: u64) -> bool {
    let heap_end = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_END);
    let heap_max = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_MAX);
    let heap_pages = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_PAGES);

    // Calculate pages needed (at least 16 pages = 64KB at a time for efficiency)
    let min_extend = if min_size < 65536 { 65536 } else { min_size };
    let needed = heap_align_up(min_extend, 4096);
    let pages_needed = needed / 4096;

    // Check we won't exceed maximum
    if heap_end + needed > heap_max {
        return false;
    }

    // Allocate and map pages
    let mut i: u64 = 0;
    let mut alloc_ok: u64 = 0;
    while i < pages_needed {
        let phys = pmm_alloc_page();
        if phys == 0 {
            // Update heap end with what we managed to allocate
            if alloc_ok > 0 {
                write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_END, heap_end + (alloc_ok * 4096));
                write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_PAGES, heap_pages + alloc_ok);
            }
            return false;  // Out of physical memory
        }

        let virt = heap_end + (i * 4096);
        // Map with write permission (PAGE_PRESENT | PAGE_WRITE = 3)
        if !mmap_map_page(virt, phys, 3) {
            // Update heap end with what we managed to allocate
            if alloc_ok > 0 {
                write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_END, heap_end + (alloc_ok * 4096));
                write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_PAGES, heap_pages + alloc_ok);
            }
            return false;  // Failed to map page
        }

        // Zero the page
        let mut offset: u64 = 0;
        while offset < 4096 {
            write_u64_addr((virt + offset) as i64, 0);
            offset = offset + 8;
        }

        alloc_ok = alloc_ok + 1;
        i = i + 1;
    }

    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_END, heap_end + needed);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_PAGES, heap_pages + pages_needed);
    true
}

// Allocate memory from heap
pub fn heap_alloc(size: u64) -> u64 {
    if size == 0 {
        return 0;
    }

    // Check initialization
    let init_flag = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_INIT);
    if init_flag != 1 {
        return 0;
    }

    // Calculate actual size needed (header + aligned size)
    let header_size: u64 = 16;
    let actual_size = heap_align_up(size + header_size, HEAP_ALIGNMENT);
    let min_size = if actual_size < HEAP_MIN_ALLOC { HEAP_MIN_ALLOC } else { actual_size };

    let mut heap_bump = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_BUMP);
    let heap_end = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_END);

    // Check if we need to extend heap
    if heap_bump + min_size > heap_end {
        if !heap_extend(min_size) {
            return 0;  // Out of memory
        }
    }

    // Re-read after potential extension
    let heap_end_new = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_END);
    if heap_bump + min_size > heap_end_new {
        return 0;  // Still not enough space
    }

    let block_addr = heap_bump;
    heap_bump = heap_bump + min_size;
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_BUMP, heap_bump);

    // Write allocation header (size + magic)
    write_u64_addr(block_addr as i64, min_size);
    write_u64_addr((block_addr + 8) as i64, HEAP_ALLOC_MAGIC);

    // Update statistics
    let total = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_TOTAL);
    let count = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_COUNT);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_TOTAL, total + min_size);
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_COUNT, count + 1);

    block_addr + 16  // Return pointer after header
}

// Free allocated memory
pub fn heap_free(ptr: u64) {
    if ptr == 0 {
        return;
    }

    let block_addr = ptr - 16;

    // Validate magic number
    let magic = read_u64_addr((block_addr + 8) as i64);
    if magic != HEAP_ALLOC_MAGIC {
        return;  // Invalid or double free
    }

    // Get block size
    let block_size = read_u64_addr(block_addr as i64);

    // Clear magic to prevent double-free
    write_u64_addr((block_addr + 8) as i64, 0);

    // Add to free list
    let free_list = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_FREE_LIST);
    write_u64_addr(block_addr as i64, block_size);  // Keep size
    write_u64_addr((block_addr + 8) as i64, free_list);  // Next pointer
    write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_FREE_LIST, block_addr);

    // Update statistics
    let total = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_TOTAL);
    let count = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_COUNT);
    if total >= block_size {
        write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_TOTAL, total - block_size);
    }
    if count > 0 {
        write_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_COUNT, count - 1);
    }
}

// Get heap statistics
pub fn heap_get_size() -> u64 {
    let start = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_START);
    let end = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_END);
    end - start
}

pub fn heap_get_used() -> u64 {
    let start = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_START);
    let bump = read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_BUMP);
    bump - start
}

pub fn heap_get_pages() -> u64 {
    read_u64_addr(HEAP_STATE_ADDR + HEAP_STATE_PAGES)
}

// Test heap with large allocations
fn test_heap_allocs() {
    serial_out(72);  // H
    serial_out(69);  // E
    serial_out(65);  // A
    serial_out(80);  // P
    serial_out(32);  // space
    serial_out(84);  // T
    serial_out(69);  // E
    serial_out(83);  // S
    serial_out(84);  // T
    serial_newline();

    // Test 1: Small allocation (1KB)
    let ptr1 = heap_alloc(1024);
    serial_out(49);  // 1
    serial_out(75);  // K
    serial_out(58);  // :
    serial_out(32);  // space
    if ptr1 != 0 {
        serial_hex(ptr1);
        serial_out(32);  // space
        serial_out(79);  // O
        serial_out(75);  // K
    } else {
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
    }
    serial_newline();

    // Test 2: 64KB allocation (forces heap extension)
    let ptr2 = heap_alloc(65536);
    serial_out(54);  // 6
    serial_out(52);  // 4
    serial_out(75);  // K
    serial_out(58);  // :
    serial_out(32);  // space
    if ptr2 != 0 {
        serial_hex(ptr2);
        serial_out(32);  // space
        serial_out(79);  // O
        serial_out(75);  // K
    } else {
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
    }
    serial_newline();

    // Test 3: 1MB allocation
    let ptr3 = heap_alloc(1048576);
    serial_out(49);  // 1
    serial_out(77);  // M
    serial_out(58);  // :
    serial_out(32);  // space
    if ptr3 != 0 {
        serial_hex(ptr3);
        serial_out(32);  // space
        serial_out(79);  // O
        serial_out(75);  // K
    } else {
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
    }
    serial_newline();

    // Test 4: 4MB allocation
    let ptr4 = heap_alloc(4194304);
    serial_out(52);  // 4
    serial_out(77);  // M
    serial_out(58);  // :
    serial_out(32);  // space
    if ptr4 != 0 {
        serial_hex(ptr4);
        serial_out(32);  // space
        serial_out(79);  // O
        serial_out(75);  // K
    } else {
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
    }
    serial_newline();

    // Print heap stats
    let heap_size = heap_get_size();
    let heap_used = heap_get_used();
    let heap_pages = heap_get_pages();

    serial_out(72);  // H
    serial_out(83);  // S
    serial_out(73);  // I
    serial_out(90);  // Z
    serial_out(69);  // E
    serial_out(58);  // :
    serial_out(32);  // space
    serial_print_dec((heap_size / 1024) as i64);
    serial_out(75);  // K
    serial_out(66);  // B
    serial_newline();

    serial_out(72);  // H
    serial_out(85);  // U
    serial_out(83);  // S
    serial_out(69);  // E
    serial_out(68);  // D
    serial_out(58);  // :
    serial_out(32);  // space
    serial_print_dec((heap_used / 1024) as i64);
    serial_out(75);  // K
    serial_out(66);  // B
    serial_newline();

    serial_out(72);  // H
    serial_out(80);  // P
    serial_out(65);  // A
    serial_out(71);  // G
    serial_out(69);  // E
    serial_out(83);  // S
    serial_out(58);  // :
    serial_out(32);  // space
    serial_print_dec(heap_pages as i64);
    serial_newline();

    // Free allocations
    heap_free(ptr1);
    heap_free(ptr2);
    heap_free(ptr3);
    heap_free(ptr4);

    serial_out(72);  // H
    serial_out(69);  // E
    serial_out(65);  // A
    serial_out(80);  // P
    serial_out(32);  // space
    serial_out(68);  // D
    serial_out(79);  // O
    serial_out(78);  // N
    serial_out(69);  // E
    serial_newline();
}

// Map a virtual page to a physical page for demand paging
// This is a simplified version that works with the existing page tables
fn mmap_map_page(vaddr: u64, paddr: u64, flags: u64) -> bool {
    // Get the current PML4 address from CR3
    let mut pml4: u64 = 0;
    unsafe {
        asm!(
            "movq %cr3, %rax",
            lateout("rax") pml4,
            options(nomem, nostack, att_syntax)
        );
    }
    let pml4_addr = paddr_and(pml4, 0x000FFFFFFFFFF000);  // Mask to get physical address

    // Calculate page table indices using division (instead of bit shift)
    // vaddr >> 39 = vaddr / (2^39) = vaddr / 0x8000000000
    // vaddr >> 30 = vaddr / (2^30) = vaddr / 0x40000000
    // vaddr >> 21 = vaddr / (2^21) = vaddr / 0x200000
    // vaddr >> 12 = vaddr / (2^12) = vaddr / 0x1000
    let pml4_idx = (vaddr / 0x8000000000) % 512;
    let pdpt_idx = (vaddr / 0x40000000) % 512;
    let pd_idx = (vaddr / 0x200000) % 512;
    let pt_idx = (vaddr / 0x1000) % 512;

    // Walk page tables, creating entries as needed
    // Level 4: PML4 -> PDPT
    let pml4e = read_u64_addr((pml4_addr + pml4_idx * 8) as i64);
    let mut pdpt_addr: u64 = 0;
    if (pml4e % 2) == 0 {  // Check if PRESENT bit (bit 0) is clear
        // Need to allocate PDPT
        let new_pdpt = kptpool_alloc();
        if new_pdpt == 0 {
            return false;
        }
        // Zero the new table
        let mut j: i64 = 0;
        while j < 512 {
            write_u64_addr((new_pdpt as i64) + j * 8, 0);
            j = j + 1;
        }
        // Install in PML4
        write_u64_addr((pml4_addr + pml4_idx * 8) as i64, new_pdpt + 7);  // Present, RW, User (1+2+4=7)
        pdpt_addr = new_pdpt;
    } else {
        pdpt_addr = paddr_and(pml4e, 0x000FFFFFFFFFF000);
    }

    // Level 3: PDPT -> PD
    let pdpte = read_u64_addr((pdpt_addr + pdpt_idx * 8) as i64);
    let mut pd_addr: u64 = 0;
    if (pdpte % 2) == 0 {  // Check if PRESENT bit is clear
        let new_pd = kptpool_alloc();
        if new_pd == 0 {
            return false;
        }
        let mut j: i64 = 0;
        while j < 512 {
            write_u64_addr((new_pd as i64) + j * 8, 0);
            j = j + 1;
        }
        write_u64_addr((pdpt_addr + pdpt_idx * 8) as i64, new_pd + 7);
        pd_addr = new_pd;
    } else {
        pd_addr = paddr_and(pdpte, 0x000FFFFFFFFFF000);
    }

    // Level 2: PD -> PT
    let pde = read_u64_addr((pd_addr + pd_idx * 8) as i64);
    let mut pt_addr: u64 = 0;
    if (pde % 2) == 0 {  // Check if PRESENT bit is clear
        let new_pt = kptpool_alloc();
        if new_pt == 0 {
            return false;
        }
        let mut j: i64 = 0;
        while j < 512 {
            write_u64_addr((new_pt as i64) + j * 8, 0);
            j = j + 1;
        }
        write_u64_addr((pd_addr + pd_idx * 8) as i64, new_pt + 7);
        pt_addr = new_pt;
    } else {
        pt_addr = paddr_and(pde, 0x000FFFFFFFFFF000);
    }

    // Level 1: PT entry (flags should already include PRESENT bit)
    let entry = paddr_and(paddr, 0x000FFFFFFFFFF000) + flags;
    write_u64_addr((pt_addr + pt_idx * 8) as i64, entry);

    // Invalidate TLB for this address
    unsafe {
        asm!(
            "invlpg (%rdi)",
            in("rdi") vaddr,
            options(nostack, att_syntax)
        );
    }

    true
}

// Helper: mask physical address (AND operation for u64)
fn paddr_and(a: u64, b: u64) -> u64 {
    let a_lo = a % 0x100000000;
    let a_hi = a / 0x100000000;
    let b_lo = b % 0x100000000;
    let b_hi = b / 0x100000000;

    let mut result_lo: u64 = 0;
    let mut result_hi: u64 = 0;

    // Compute bitwise AND using arithmetic
    // For simplicity, just use the fact that the mask is well-known
    // 0x000FFFFFFFFFF000 = mask for 52-bit physical address, page-aligned
    // High part mask: 0x000FFFFF, Low part mask: 0xFFFFF000

    result_hi = a_hi % 0x100000;  // Keep only bits 0-19 of high part
    result_lo = (a_lo / 0x1000) * 0x1000;  // Clear bits 0-11 of low part

    result_hi * 0x100000000 + result_lo
}

// Unmap a virtual page (clear the page table entry)
// This is needed to trigger page faults for demand paging
// Handles both regular 4KB pages and 2MB huge pages (splits huge pages as needed)
fn mmap_unmap_page(vaddr: u64) {
    // Get the current PML4 address from CR3
    let mut pml4: u64 = 0;
    unsafe {
        asm!(
            "movq %cr3, %rax",
            lateout("rax") pml4,
            options(nomem, nostack, att_syntax)
        );
    }
    let pml4_addr = paddr_and(pml4, 0x000FFFFFFFFFF000);

    // Calculate page table indices
    let pml4_idx = (vaddr / 0x8000000000) % 512;
    let pdpt_idx = (vaddr / 0x40000000) % 512;
    let pd_idx = (vaddr / 0x200000) % 512;
    let pt_idx = (vaddr / 0x1000) % 512;

    // Walk page tables to find the PT entry
    let pml4e = read_u64_addr((pml4_addr + pml4_idx * 8) as i64);
    if (pml4e % 2) == 0 {
        return;  // Not mapped at PML4 level
    }

    let pdpt_addr = paddr_and(pml4e, 0x000FFFFFFFFFF000);
    let pdpte = read_u64_addr((pdpt_addr + pdpt_idx * 8) as i64);
    if (pdpte % 2) == 0 {
        return;  // Not mapped at PDPT level
    }

    let pd_addr = paddr_and(pdpte, 0x000FFFFFFFFFF000);
    let pde = read_u64_addr((pd_addr + pd_idx * 8) as i64);
    if (pde % 2) == 0 {
        return;  // Not mapped at PD level
    }

    // Check if this is a 2MB huge page (PS bit = bit 7)
    // pde / 128 gives us the value with PS bit in position 0
    let is_huge = ((pde / 128) % 2) != 0;

    let mut pt_addr: u64 = 0;
    if is_huge {
        // Need to split the 2MB huge page into a 4KB page table
        // Allocate a new page table
        let new_pt = kptpool_alloc();
        if new_pt == 0 {
            return;  // OOM, can't split
        }

        // Get the physical base of the 2MB page
        // For 2MB pages, physical address is in bits 21-51
        let huge_phys_base = paddr_and(pde, 0x000FFFFFFFE00000);

        // Fill the new page table with 512 4KB entries mapping the same 2MB region
        // Each entry maps physical: huge_phys_base + (i * 4096)
        let mut i: i64 = 0;
        while i < 512 {
            let page_phys = huge_phys_base + (i as u64 * 0x1000);
            // Page flags: Present + Write + User (same as the huge page, minus PS bit)
            // Original flags: 0x87 = Present(1) + Write(2) + User(4) + PS(0x80)
            // New flags: 0x07 = Present(1) + Write(2) + User(4)
            write_u64_addr((new_pt as i64) + i * 8, page_phys + 7);
            i = i + 1;
        }

        // Replace the PD entry to point to the new page table (remove PS bit)
        write_u64_addr((pd_addr + pd_idx * 8) as i64, new_pt + 7);

        pt_addr = new_pt;
    } else {
        // Regular 4KB page table entry
        pt_addr = paddr_and(pde, 0x000FFFFFFFFFF000);
    }

    // Clear the page table entry (set to 0, removing the Present bit)
    write_u64_addr((pt_addr + pt_idx * 8) as i64, 0);

    // Invalidate TLB for this address
    unsafe {
        asm!(
            "invlpg (%rdi)",
            in("rdi") vaddr,
            options(nostack, att_syntax)
        );
    }
}

// ============================================================
// ATA PIO Driver (Phase 12)
// ============================================================

// Initialize ATA driver state
fn ata_init_state() {
    write_u64_addr(ATA_STATE_ADDR + ATA_PRESENT, 0);
    write_u64_addr(ATA_STATE_ADDR + ATA_TOTAL_SECTORS, 0);
    write_u64_addr(ATA_STATE_ADDR + ATA_LAST_ERROR, 0);
}

// Read ATA status register
fn ata_read_status() -> i64 {
    inb(ATA_PRIMARY_IO + ATA_STATUS)
}

// Read ATA alternate status (doesn't clear IRQ)
fn ata_read_alt_status() -> i64 {
    inb(ATA_PRIMARY_CTRL + ATA_ALT_STATUS)
}

// Wait for BSY flag to clear (drive not busy)
// Returns: 0 on success, ATA_ERR_TIMEOUT on timeout
fn ata_wait_not_busy() -> i64 {
    let mut timeout: i64 = 100000;
    let mut result: i64 = ATA_ERR_TIMEOUT;
    while timeout > 0 && result != ATA_OK {
        let status = ata_read_status() as u64;
        // BSY is bit 7 (0x80)
        if bit_and(status, ATA_SR_BSY as u64) == 0 {
            result = ATA_OK;
        }
        timeout = timeout - 1;
    }
    result
}

// Wait for DRQ flag (data ready to transfer)
// Returns: 0 on success, negative error code
fn ata_wait_drq() -> i64 {
    let mut timeout: i64 = 100000;
    let mut result: i64 = ATA_ERR_TIMEOUT;
    while timeout > 0 && result == ATA_ERR_TIMEOUT {
        let status = ata_read_status() as u64;

        // Check ERR bit (bit 0)
        if bit_and(status, ATA_SR_ERR as u64) != 0 {
            result = ATA_ERR_IO;
        } else if bit_and(status, ATA_SR_DRQ as u64) != 0 {
            // Check DRQ bit (bit 3 = 0x08)
            result = ATA_OK;
        }

        timeout = timeout - 1;
    }
    result
}

// Select drive (master or slave)
fn ata_select_drive(drive: i64) {
    outb(ATA_PRIMARY_IO + ATA_DRIVE, drive);
    // 400ns delay (read status 4 times)
    ata_read_alt_status();
    ata_read_alt_status();
    ata_read_alt_status();
    ata_read_alt_status();
}

// Software reset ATA controller
fn ata_soft_reset() {
    outb(ATA_PRIMARY_CTRL + ATA_DEV_CTRL, 4);  // Set SRST bit
    io_wait();
    io_wait();
    io_wait();
    io_wait();
    outb(ATA_PRIMARY_CTRL + ATA_DEV_CTRL, 0);  // Clear SRST bit
    io_wait();
    io_wait();
    io_wait();
    io_wait();
}

// Detect if primary master drive is present
// Returns: 1 if present, 0 if not
fn ata_detect_drive() -> i64 {
    let mut present: i64 = 0;

    // Software reset
    ata_soft_reset();

    // Select master drive
    ata_select_drive(ATA_MASTER);

    // Wait for drive to be ready
    let wait_result = ata_wait_not_busy();
    if wait_result == ATA_OK {
        // Check drive signature
        let lba_mid = inb(ATA_PRIMARY_IO + ATA_LBA_MID);
        let lba_hi = inb(ATA_PRIMARY_IO + ATA_LBA_HI);

        // ATA drive: both should be 0
        // ATAPI: 0x14, 0xEB
        if lba_mid == 0 && lba_hi == 0 {
            // Could be an ATA drive, try IDENTIFY
            present = 1;
        }
    }

    present
}

// Read 16-bit word from ATA data port
fn ata_read_data_word() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "in %dx, %ax",
            in("dx") ATA_PRIMARY_IO + ATA_DATA,
            lateout("ax") result,
            options(nomem, nostack, att_syntax)
        );
    }
    result
}

// Write 16-bit word to ATA data port
fn ata_write_data_word(word: i64) {
    unsafe {
        asm!(
            "out %ax, %dx",
            in("dx") ATA_PRIMARY_IO + ATA_DATA,
            in("ax") word,
            options(nomem, nostack, att_syntax)
        );
    }
}

// Send IDENTIFY command and read drive info
// Returns: total sectors, or negative error
fn ata_identify() -> i64 {
    // Select master drive
    ata_select_drive(ATA_MASTER);

    // Zero out sector count and LBA registers
    outb(ATA_PRIMARY_IO + ATA_SECCOUNT, 0);
    outb(ATA_PRIMARY_IO + ATA_LBA_LO, 0);
    outb(ATA_PRIMARY_IO + ATA_LBA_MID, 0);
    outb(ATA_PRIMARY_IO + ATA_LBA_HI, 0);

    // Send IDENTIFY command
    outb(ATA_PRIMARY_IO + ATA_COMMAND, ATA_CMD_IDENTIFY);

    // Check status
    let status = ata_read_status();
    if status == 0 {
        return ATA_ERR_NO_DRIVE;
    }

    // Wait for BSY to clear
    let wait_result = ata_wait_not_busy();
    if wait_result != ATA_OK {
        return wait_result;
    }

    // Check mid/hi LBA - non-zero means not ATA
    let lba_mid = inb(ATA_PRIMARY_IO + ATA_LBA_MID);
    let lba_hi = inb(ATA_PRIMARY_IO + ATA_LBA_HI);
    if lba_mid != 0 || lba_hi != 0 {
        return ATA_ERR_NO_DRIVE;
    }

    // Wait for DRQ
    let drq_result = ata_wait_drq();
    if drq_result != ATA_OK {
        return drq_result;
    }

    // Read 256 words (512 bytes) of IDENTIFY data
    let mut i: i64 = 0;
    while i < 256 {
        let word = ata_read_data_word();
        let addr = ATA_IDENTIFY_ADDR + (i * 2);
        // Store as 16-bit value
        let byte_lo = bit_and(word as u64, 0xFF) as i64;
        let byte_hi = shr_u64(word as u64, 8) as i64;
        write_byte_addr(addr, byte_lo);
        write_byte_addr(addr + 1, byte_hi);
        i = i + 1;
    }

    // Extract total LBA28 sectors from words 60-61
    let word60_lo = read_byte_addr(ATA_IDENTIFY_ADDR + 120) as i64;
    let word60_hi = read_byte_addr(ATA_IDENTIFY_ADDR + 121) as i64;
    let word61_lo = read_byte_addr(ATA_IDENTIFY_ADDR + 122) as i64;
    let word61_hi = read_byte_addr(ATA_IDENTIFY_ADDR + 123) as i64;

    let total_sectors = word60_lo + (word60_hi * 256) +
                        (word61_lo * 65536) + (word61_hi * 16777216);

    total_sectors
}

// Read sectors from disk using PIO mode (LBA28)
// lba: starting sector (28-bit)
// count: number of sectors to read (1-255)
// buffer: destination address
// Returns: bytes read, or negative error
fn ata_read_sectors(lba: i64, count: i64, buffer: i64) -> i64 {
    // Validate parameters
    if count <= 0 || count > 255 {
        return ATA_ERR_INVALID;
    }

    // Check drive is present
    let present = read_u64_addr(ATA_STATE_ADDR + ATA_PRESENT) as i64;
    if present == 0 {
        return ATA_ERR_NO_DRIVE;
    }

    // Wait for drive ready
    let wait_result = ata_wait_not_busy();
    if wait_result != ATA_OK {
        return wait_result;
    }

    // Select drive and set LBA mode (bits 24-27 of LBA + drive select)
    let lba_high_bits = lba / 16777216;  // bits 24-27
    let drive_byte = ATA_MASTER + lba_high_bits;
    outb(ATA_PRIMARY_IO + ATA_DRIVE, drive_byte);

    // Set sector count
    outb(ATA_PRIMARY_IO + ATA_SECCOUNT, count);

    // Set LBA address (bits 0-23) using bit operations
    let lba_lo = bit_and(lba as u64, 0xFF) as i64;
    let lba_mid_val = bit_and(shr_u64(lba as u64, 8), 0xFF) as i64;
    let lba_hi_val = bit_and(shr_u64(lba as u64, 16), 0xFF) as i64;

    outb(ATA_PRIMARY_IO + ATA_LBA_LO, lba_lo);
    outb(ATA_PRIMARY_IO + ATA_LBA_MID, lba_mid_val);
    outb(ATA_PRIMARY_IO + ATA_LBA_HI, lba_hi_val);

    // Send READ SECTORS command
    outb(ATA_PRIMARY_IO + ATA_COMMAND, ATA_CMD_READ_PIO);

    // Read each sector
    let mut sector: i64 = 0;
    let mut total_bytes: i64 = 0;
    let mut error: i64 = 0;

    while sector < count && error == 0 {
        // Wait for DRQ
        let drq_result = ata_wait_drq();
        if drq_result != ATA_OK {
            error = drq_result;
        } else {
            // Read 256 words (512 bytes)
            let sector_offset = sector * ATA_SECTOR_SIZE;
            let mut word_idx: i64 = 0;
            while word_idx < 256 {
                let word = ata_read_data_word();
                let byte_offset = buffer + sector_offset + (word_idx * 2);
                let byte_lo = bit_and(word as u64, 0xFF) as i64;
                let byte_hi = shr_u64(word as u64, 8) as i64;
                write_byte_addr(byte_offset, byte_lo);
                write_byte_addr(byte_offset + 1, byte_hi);
                word_idx = word_idx + 1;
            }
            total_bytes = total_bytes + ATA_SECTOR_SIZE;
            sector = sector + 1;
        }
    }

    if error != 0 {
        write_u64_addr(ATA_STATE_ADDR + ATA_LAST_ERROR, error as u64);
        return error;
    }

    total_bytes
}

// Write sectors to disk using PIO mode (LBA28)
// lba: starting sector (28-bit)
// count: number of sectors to write (1-255)
// buffer: source address
// Returns: bytes written, or negative error
fn ata_write_sectors(lba: i64, count: i64, buffer: i64) -> i64 {
    // Validate parameters
    if count <= 0 || count > 255 {
        return ATA_ERR_INVALID;
    }

    // Check drive is present
    let present = read_u64_addr(ATA_STATE_ADDR + ATA_PRESENT) as i64;
    if present == 0 {
        return ATA_ERR_NO_DRIVE;
    }

    // Wait for drive ready
    let wait_result = ata_wait_not_busy();
    if wait_result != ATA_OK {
        return wait_result;
    }

    // Select drive and set LBA mode (bits 24-27 of LBA + drive select)
    let lba_high_bits = lba / 16777216;  // bits 24-27
    let drive_byte = ATA_MASTER + lba_high_bits;
    outb(ATA_PRIMARY_IO + ATA_DRIVE, drive_byte);

    // Set sector count
    outb(ATA_PRIMARY_IO + ATA_SECCOUNT, count);

    // Set LBA address (bits 0-23) using bit operations
    let lba_lo = bit_and(lba as u64, 0xFF) as i64;
    let lba_mid_val = bit_and(shr_u64(lba as u64, 8), 0xFF) as i64;
    let lba_hi_val = bit_and(shr_u64(lba as u64, 16), 0xFF) as i64;

    outb(ATA_PRIMARY_IO + ATA_LBA_LO, lba_lo);
    outb(ATA_PRIMARY_IO + ATA_LBA_MID, lba_mid_val);
    outb(ATA_PRIMARY_IO + ATA_LBA_HI, lba_hi_val);

    // Send WRITE SECTORS command
    outb(ATA_PRIMARY_IO + ATA_COMMAND, ATA_CMD_WRITE_PIO);

    // Write each sector
    let mut sector: i64 = 0;
    let mut total_bytes: i64 = 0;
    let mut error: i64 = 0;

    while sector < count && error == 0 {
        // Wait for DRQ
        let drq_result = ata_wait_drq();
        if drq_result != ATA_OK {
            error = drq_result;
        } else {
            // Write 256 words (512 bytes)
            let sector_offset = sector * ATA_SECTOR_SIZE;
            let mut word_idx: i64 = 0;
            while word_idx < 256 {
                let byte_offset = buffer + sector_offset + (word_idx * 2);
                let byte_lo = read_byte_addr(byte_offset);
                let byte_hi = read_byte_addr(byte_offset + 1);
                let word = byte_lo + (byte_hi * 256);
                ata_write_data_word(word);
                word_idx = word_idx + 1;
            }
            total_bytes = total_bytes + ATA_SECTOR_SIZE;
            sector = sector + 1;
        }
    }

    if error != 0 {
        write_u64_addr(ATA_STATE_ADDR + ATA_LAST_ERROR, error as u64);
        return error;
    }

    // Flush cache after write
    outb(ATA_PRIMARY_IO + ATA_COMMAND, ATA_CMD_FLUSH);
    let flush_result = ata_wait_not_busy();
    if flush_result != ATA_OK {
        return flush_result;
    }

    total_bytes
}

// Initialize ATA driver and detect drive
// Returns: total sectors if drive found, 0 otherwise
fn ata_init() -> i64 {
    ata_init_state();

    serial_out(65);  // A
    serial_out(84);  // T
    serial_out(65);  // A
    serial_out(32);  // space

    // Detect drive
    let detected = ata_detect_drive();
    if detected == 0 {
        serial_out(78);  // N
        serial_out(79);  // O
        serial_newline();
        return 0;
    }

    // Get drive info
    let sectors = ata_identify();
    if sectors <= 0 {
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        return 0;
    }

    // Store state
    write_u64_addr(ATA_STATE_ADDR + ATA_PRESENT, 1);
    write_u64_addr(ATA_STATE_ADDR + ATA_TOTAL_SECTORS, sectors as u64);

    serial_out(79);  // O
    serial_out(75);  // K
    serial_out(32);  // space

    // Print sector count
    serial_print_dec(sectors);
    serial_out(83);  // S
    serial_newline();

    sectors
}

// ============================================================
// Disk Syscalls (Phase 12)
// ============================================================

// SYS_DISK_READ - Read sectors from disk
// arg1: LBA (sector number)
// arg2: count (number of sectors, 1-128)
// arg3: destination buffer address
// Returns: bytes read, or negative error
fn syscall_disk_read(lba: i64, count: i64, buffer: i64) -> i64 {
    // Validate count (max 128 sectors = 64KB)
    if count <= 0 || count > 128 {
        return ATA_ERR_INVALID;
    }

    // Validate buffer address (must be in safe range)
    // Allow reading to ATA_BUFFER_ADDR or user-space addresses
    if buffer < ATA_BUFFER_ADDR && buffer < PROC_STACK_BASE {
        return ATA_ERR_INVALID;
    }

    ata_read_sectors(lba, count, buffer)
}

// SYS_DISK_INFO - Get disk information
// arg1: info type (0=present, 1=total_sectors, 2=last_error)
// Returns: requested info value
fn syscall_disk_info(info_type: i64) -> i64 {
    if info_type == 0 {
        read_u64_addr(ATA_STATE_ADDR + ATA_PRESENT) as i64
    } else if info_type == 1 {
        read_u64_addr(ATA_STATE_ADDR + ATA_TOTAL_SECTORS) as i64
    } else if info_type == 2 {
        read_u64_addr(ATA_STATE_ADDR + ATA_LAST_ERROR) as i64
    } else {
        ATA_ERR_INVALID
    }
}

// SYS_DISK_WRITE - Write sectors to disk
// arg1: LBA (sector number)
// arg2: count (number of sectors, 1-128)
// arg3: source buffer address
// Returns: bytes written, or negative error
fn syscall_disk_write(lba: i64, count: i64, buffer: i64) -> i64 {
    // Validate count (max 128 sectors = 64KB)
    if count <= 0 || count > 128 {
        return ATA_ERR_INVALID;
    }

    // Validate buffer address (must be in safe range)
    if buffer < ATA_BUFFER_ADDR && buffer < PROC_STACK_BASE {
        return ATA_ERR_INVALID;
    }

    ata_write_sectors(lba, count, buffer)
}

// SYS_PCI_READ - Read PCI configuration space
// arg1: bus (0-255), arg2: packed device/func/offset (device << 16 | func << 8 | offset)
// Returns: 32-bit value from config space
fn syscall_pci_read(bus: i64, packed: i64) -> i64 {
    let device = packed / 65536;
    let func = (packed / 256) % 256;
    let offset = packed % 256;

    // Validate parameters
    if bus < 0 || bus > 255 || device > 31 || func > 7 || offset > 252 {
        return -1;
    }

    pci_config_read(bus, device, func, offset)
}

// SYS_PCI_WRITE - Write PCI configuration space
// arg1: bus (0-255), arg2: packed device/func/offset, arg3: value
// Returns: 0 on success, -1 on error
fn syscall_pci_write(bus: i64, packed: i64, value: i64) -> i64 {
    let device = packed / 65536;
    let func = (packed / 256) % 256;
    let offset = packed % 256;

    // Validate parameters
    if bus < 0 || bus > 255 || device > 31 || func > 7 || offset > 252 {
        return -1;
    }

    pci_config_write(bus, device, func, offset, value);
    0
}

// SYS_PCI_ENUMERATE - Enumerate PCI devices
// arg1: buffer address to write device info
// arg2: max entries in buffer
// Each entry: 8 bytes (bus:8, device:8, func:8, class:8, vendor:16, device_id:16)
// Returns: number of devices found
fn syscall_pci_enumerate(buffer: i64, max_entries: i64) -> i64 {
    let mut count: i64 = 0;
    let mut bus: i64 = 0;

    while bus < 256 && count < max_entries {
        let mut device: i64 = 0;
        while device < 32 && count < max_entries {
            let vendor_device = pci_config_read(bus, device, 0, 0);
            let vendor = vendor_device % 65536;

            if vendor != 0xFFFF && vendor != 0 {
                // Device present
                let device_id = vendor_device / 65536;
                let class_rev = pci_config_read(bus, device, 0, 8);
                let class_code = class_rev / 16777216; // bits 24-31

                // Pack and write entry: bus | device << 8 | class << 16 | vendor << 24 | device_id << 40
                let entry_addr = buffer + (count * 8);
                let entry_lo = bus + (device * 256) + (class_code * 65536);
                let entry_hi = vendor + (device_id * 65536);
                write_u64_addr(entry_addr, (entry_lo + entry_hi * 16777216) as u64);

                count = count + 1;
            }
            device = device + 1;
        }
        bus = bus + 1;
    }

    count
}

// SYS_IRQ_REGISTER - Register to receive IRQ as signal
// arg1: IRQ number (0-15)
// arg2: signal to send (default SIGUSR1 = 10)
// Returns: 0 on success, -1 on error
fn syscall_irq_register(irq: i64, signal: i64) -> i64 {
    // Validate IRQ number
    if irq < 0 || irq > 15 {
        return -1;
    }

    // Don't allow hijacking timer or keyboard
    if irq == 0 || irq == 1 {
        return -1;
    }

    let current = get_current_pid();

    // Store handler PID in table (also store signal in upper bits)
    let entry_addr = IRQ_HANDLER_TABLE + (irq * 8);
    let packed = current + (signal * 65536);
    write_u64_addr(entry_addr, packed as u64);

    0
}

// SYS_IRQ_UNREGISTER - Unregister IRQ handler
// arg1: IRQ number (0-15)
// Returns: 0 on success, -1 on error
fn syscall_irq_unregister(irq: i64) -> i64 {
    if irq < 0 || irq > 15 {
        return -1;
    }

    let entry_addr = IRQ_HANDLER_TABLE + (irq * 8);
    let current = get_current_pid();
    let packed = read_u64_addr(entry_addr) as i64;
    let handler_pid = packed % 65536;

    // Only allow owner to unregister
    if handler_pid != current {
        return -1;
    }

    write_u64_addr(entry_addr, 0);
    0
}

// SYS_IRQ_ACK - Acknowledge IRQ (re-enable it)
// arg1: IRQ number
// Returns: 0 on success, -1 on error
fn syscall_irq_ack(irq: i64) -> i64 {
    if irq < 0 || irq > 15 {
        return -1;
    }

    // EOI is already sent in handle_irq, this is just for userspace bookkeeping
    0
}

// SYS_TIME - Get current tick count
// Returns: tick count since boot
fn syscall_time() -> i64 {
    read_u64_addr(TICK_COUNT_ADDR) as i64
}

// SYS_SLEEP - Sleep for specified ticks
// arg1: number of ticks to sleep
// Returns: 0 on success, actual ticks slept
// Note: Simple implementation - userspace should use time+yield for precise control
fn syscall_sleep(ticks: i64) -> i64 {
    if ticks <= 0 {
        return 0;
    }

    let start = read_u64_addr(TICK_COUNT_ADDR) as i64;
    let target = start + ticks;

    // Simple busy-yield loop
    // Note: In production, use a proper sleep queue in scheduler
    let mut current_time = start;
    while current_time < target {
        // Just return the elapsed ticks - caller should yield and retry
        // This makes it non-blocking
        current_time = read_u64_addr(TICK_COUNT_ADDR) as i64;
    }

    current_time - start
}

// ============================================================
// VGA Syscalls (for Console Server in userspace)
// ============================================================

// SYS_VGA_PUTCHAR - Write character at position with color
// arg1: x (column 0-79)
// arg2: y (row 0-24)
// arg3: character (ASCII)
// arg4 (from frame_ptr): color attribute
// Returns: 0 on success, -1 on error
fn syscall_vga_putchar(x: i64, y: i64, ch: i64, frame_ptr: i64) -> i64 {
    // Read arg4 (color) from r10 saved on stack
    // r10 is at offset 80 in our interrupt frame
    let color = read_u64_addr(frame_ptr + 80) as i64;

    if x < 0 || x >= VGA_WIDTH || y < 0 || y >= VGA_HEIGHT {
        return -1;
    }
    vga_write_char_color(x, y, ch, color);
    0
}

// SYS_VGA_SETCURSOR - Set hardware cursor position
// arg1: x (column 0-79)
// arg2: y (row 0-24)
// Returns: 0 on success, -1 on error
fn syscall_vga_setcursor(x: i64, y: i64) -> i64 {
    if x < 0 || x >= VGA_WIDTH || y < 0 || y >= VGA_HEIGHT {
        return -1;
    }

    let pos = (y * VGA_WIDTH + x) as u64;

    // VGA cursor position: low byte to port 0x3D5 (index 0x0F)
    //                      high byte to port 0x3D5 (index 0x0E)
    outb(0x3D4, 0x0F);
    outb(0x3D5, (pos % 256) as i64);
    outb(0x3D4, 0x0E);
    outb(0x3D5, ((pos / 256) % 256) as i64);

    0
}

// SYS_VGA_CLEAR - Clear screen region
// arg1: y_start (first row)
// arg2: y_end (last row, exclusive)
// arg3: color attribute for cleared cells
// Returns: 0 on success, -1 on error
fn syscall_vga_clear(y_start: i64, y_end: i64, color: i64) -> i64 {
    if y_start < 0 || y_end > VGA_HEIGHT || y_start >= y_end {
        return -1;
    }

    let mut y = y_start;
    while y < y_end {
        let mut x: i64 = 0;
        while x < VGA_WIDTH {
            vga_write_char_color(x, y, 32, color);  // Space character
            x = x + 1;
        }
        y = y + 1;
    }
    0
}

// SYS_VGA_SCROLL - Scroll screen region up by one line
// arg1: y_start (first row)
// arg2: y_end (last row, exclusive)
// arg3: color attribute for new blank line
// Returns: 0 on success, -1 on error
fn syscall_vga_scroll(y_start: i64, y_end: i64, color: i64) -> i64 {
    if y_start < 0 || y_end > VGA_HEIGHT || y_start >= y_end {
        return -1;
    }

    // Copy each line up
    let mut y = y_start;
    while y < y_end - 1 {
        let mut x: i64 = 0;
        while x < VGA_WIDTH {
            // Read character and attribute from line below
            let src_offset = ((y + 1) * VGA_WIDTH + x) * 2;
            let ch = read_byte_addr(VGA_BUFFER + src_offset);
            let attr = read_byte_addr(VGA_BUFFER + src_offset + 1);

            // Write to current line
            let dst_offset = (y * VGA_WIDTH + x) * 2;
            write_byte_addr(VGA_BUFFER + dst_offset, ch);
            write_byte_addr(VGA_BUFFER + dst_offset + 1, attr);
            x = x + 1;
        }
        y = y + 1;
    }

    // Clear last line
    let mut x: i64 = 0;
    while x < VGA_WIDTH {
        vga_write_char_color(x, y_end - 1, 32, color);
        x = x + 1;
    }

    0
}

// ============================================================
// RAMFS Syscalls (for VFS Server in userspace)
// ============================================================

// SYS_RAMFS_FILE_COUNT - Get number of used files in RAMFS
fn syscall_ramfs_file_count() -> i64 {
    read_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES) as i64
}

// SYS_RAMFS_FILE_INFO - Get file flags (0=unused, 1=regular)
fn syscall_ramfs_file_info(file_idx: i64) -> i64 {
    if file_idx < 0 || file_idx >= RAMFS_MAX_FILES {
        return -1;
    }
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    read_u64_addr(entry_addr + FE_FLAGS) as i64
}

// SYS_RAMFS_READ_BYTE - Read a byte from file at offset
fn syscall_ramfs_read_byte(file_idx: i64, offset: i64) -> i64 {
    ramfs_read_byte(file_idx, offset)
}

// SYS_RAMFS_FILE_SIZE - Get file size in bytes
fn syscall_ramfs_file_size(file_idx: i64) -> i64 {
    ramfs_file_size(file_idx)
}

// SYS_RAMFS_READ_NAME - Read a character from filename
// file_idx: file index, char_idx: character index (0-7)
// Returns: ASCII character, or 0 if past end
fn syscall_ramfs_read_name(file_idx: i64, char_idx: i64) -> i64 {
    if file_idx < 0 || file_idx >= RAMFS_MAX_FILES {
        return -1;
    }
    if char_idx < 0 || char_idx >= 8 {
        return 0;
    }

    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let name_packed = read_u64_addr(entry_addr + FE_NAME);

    // Extract character at char_idx from packed name (little-endian)
    // Using simple shift approach based on char_idx
    if char_idx == 0 {
        (name_packed % 256) as i64
    } else if char_idx == 1 {
        ((name_packed / 256) % 256) as i64
    } else if char_idx == 2 {
        ((name_packed / 65536) % 256) as i64
    } else if char_idx == 3 {
        ((name_packed / 16777216) % 256) as i64
    } else if char_idx == 4 {
        ((name_packed / 0x100000000) % 256) as i64
    } else if char_idx == 5 {
        ((name_packed / 0x10000000000) % 256) as i64
    } else if char_idx == 6 {
        ((name_packed / 0x1000000000000) % 256) as i64
    } else {
        ((name_packed / 0x100000000000000) % 256) as i64
    }
}

// ============================================================
// Process Info Syscalls (Phase 3: Shell in userspace)
// ============================================================

// SYS_PROC_COUNT - Get number of processes
fn syscall_proc_count() -> i64 {
    get_num_procs()
}

// SYS_PROC_STATE - Get process state by PID
// Returns: 0=unused, 1=ready, 2=running, 3=waiting, 4=zombie, 5=stopped
fn syscall_proc_state(pid: i64) -> i64 {
    if pid < 0 || pid >= MAX_PROCS {
        return -1;
    }
    let state = pcb_get_state(pid);
    match state {
        ProcState::Unused => 0,
        ProcState::Ready => 1,
        ProcState::Running => 2,
        ProcState::Waiting => 3,
        ProcState::Zombie => 4,
        ProcState::Stopped => 5,
    }
}

// Initialize IRQ handler table
fn irq_handler_table_init() {
    let mut i: i64 = 0;
    while i < 16 {
        write_u64_addr(IRQ_HANDLER_TABLE + (i * 8), 0);
        i = i + 1;
    }
}

// Check if an IRQ has a userspace handler and forward if so
// Returns true if forwarded, false otherwise
fn irq_forward_to_userspace(irq: i64) -> bool {
    let entry_addr = IRQ_HANDLER_TABLE + (irq * 8);
    let packed = read_u64_addr(entry_addr) as i64;
    let handler_pid = packed % 65536;
    let signal = packed / 65536;

    if handler_pid > 0 {
        // Send signal to handler process
        pcb_add_signal(handler_pid, signal);
        true
    } else {
        false
    }
}

// ============================================================
// File System Syscalls
// ============================================================

// SYS_OPEN - Open file by index (simplified: arg1 = file index)
// Returns: file descriptor, or -1 on error
fn syscall_open(file_idx: i64) -> i64 {
    let current = get_current_pid();

    // Validate file index
    if file_idx < 0 || file_idx >= RAMFS_MAX_FILES {
        return VFS_ERR_INVALID;
    }

    // Check file access capability (READ for now)
    if !cap_check_file(current, file_idx, CAP_RIGHT_READ) {
        serial_out(67);  // C
        serial_out(65);  // A
        serial_out(80);  // P
        serial_out(70);  // F
        serial_out(33);  // !
        serial_out(current + 48);
        serial_out(58);  // :
        serial_out(file_idx + 48);
        serial_newline();
        return CAP_ERR_DENIED;
    }

    // Check if file exists
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let flags = read_u64_addr(entry_addr + FE_FLAGS) as i64;
    if flags == FILE_UNUSED {
        return VFS_ERR_NOT_FOUND;
    }

    // Allocate file descriptor
    let fd = fd_alloc(current, file_idx);
    if fd < 0 {
        return VFS_ERR_NO_FD;
    }

    fd
}

// SYS_READ - Read byte from file descriptor
// arg1 = fd, arg2 = not used (reads current position)
// Returns: byte value (0-255), or -1 on EOF/error
fn syscall_read(fd: i64, arg2: i64) -> i64 {
    let current = get_current_pid();

    // Get file index from FD
    let file_idx = fd_get_file(current, fd);
    if file_idx < 0 {
        return -1;  // Invalid FD
    }

    // Get current offset
    let offset = fd_get_offset(current, fd);

    // Read byte from file
    let byte = ramfs_read_byte(file_idx, offset);
    if byte < 0 {
        return -1;  // EOF or error
    }

    // Advance offset
    fd_set_offset(current, fd, offset + 1);

    byte
}

// SYS_WRITE - Write byte to file descriptor (simplified: single byte)
// arg1 = fd, arg2 = byte value
// Returns: 0 on success, -1 on error
fn syscall_write(fd: i64, byte_val: i64) -> i64 {
    let current = get_current_pid();

    // Get file index from FD
    let file_idx = fd_get_file(current, fd);
    if file_idx < 0 {
        return -1;  // Invalid FD
    }

    // Check file write capability
    if !cap_check_file(current, file_idx, CAP_RIGHT_WRITE) {
        return CAP_ERR_DENIED;
    }

    // Get current offset
    let offset = fd_get_offset(current, fd);

    // Write byte to file (simplified: only supports writing within block)
    if offset >= RAMFS_BLOCK_SIZE {
        return -1;  // Block full
    }

    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
    let data_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

    // Calculate byte position within 8-byte word
    let word_offset = (offset / 8) * 8;
    let byte_pos = offset % 8;

    // Read current word, modify byte, write back
    let current_word = read_u64_addr(data_addr + word_offset);

    // Build mask and new byte position using multiplication
    let mut multiplier: u64 = 1;
    let mut bi: i64 = 0;
    while bi < byte_pos {
        multiplier = multiplier * 256;
        bi = bi + 1;
    }

    // Clear the byte at position and set new value
    let clear_mask = 255 * multiplier;
    let cleared = current_word - ((current_word / multiplier) % 256) * multiplier;
    let new_word = cleared + ((byte_val as u64) * multiplier);

    write_u64_addr(data_addr + word_offset, new_word);

    // Update file size if writing past current size
    let current_size = read_u64_addr(entry_addr + FE_SIZE) as i64;
    if offset >= current_size {
        write_u64_addr(entry_addr + FE_SIZE, (offset + 1) as u64);
    }

    // Advance offset
    fd_set_offset(current, fd, offset + 1);

    0
}

// SYS_CLOSE - Close file descriptor
// arg1 = fd
// Returns: 0 on success, -1 on error
fn syscall_close(fd: i64) -> i64 {
    let current = get_current_pid();
    fd_close(current, fd)
}

// SYS_FSTAT - Get file size
// arg1 = fd
// Returns: file size, or -1 on error
fn syscall_fstat(fd: i64) -> i64 {
    let current = get_current_pid();

    // Get file index from FD
    let file_idx = fd_get_file(current, fd);
    if file_idx < 0 {
        return -1;
    }

    ramfs_file_size(file_idx)
}

// ============================================================
// IPC Message Queue Functions
// ============================================================

fn mq_base_addr(pid: i64) -> i64 {
    MSG_QUEUE_ADDR + (pid * MSG_QUEUE_ENTRY_SIZE)
}

fn mq_init(pid: i64) {
    let base = mq_base_addr(pid);
    write_u64_addr(base + MQ_HEAD, 0);
    write_u64_addr(base + MQ_TAIL, 0);
    write_u64_addr(base + MQ_COUNT, 0);
}

fn mq_is_full(pid: i64) -> bool {
    let base = mq_base_addr(pid);
    let count = read_u64_addr(base + MQ_COUNT) as i64;
    count >= MSG_QUEUE_SIZE
}

fn mq_is_empty(pid: i64) -> bool {
    let base = mq_base_addr(pid);
    let count = read_u64_addr(base + MQ_COUNT) as i64;
    count == 0
}

fn mq_enqueue(dst_pid: i64, src_pid: i64, data: i64) -> bool {
    if mq_is_full(dst_pid) {
        return false;
    }

    let base = mq_base_addr(dst_pid);
    let tail = read_u64_addr(base + MQ_TAIL) as i64;

    // Calculate message slot address
    let msg_addr = base + MQ_MSGS + (tail * MSG_SIZE);

    // Write message: source PID and data
    write_u64_addr(msg_addr + MSG_SRC_PID, src_pid as u64);
    write_u64_addr(msg_addr + MSG_DATA, data as u64);

    // Update tail and count
    let new_tail = (tail + 1) % MSG_QUEUE_SIZE;
    write_u64_addr(base + MQ_TAIL, new_tail as u64);

    let count = read_u64_addr(base + MQ_COUNT);
    write_u64_addr(base + MQ_COUNT, count + 1);

    true
}

fn mq_dequeue(pid: i64, src_out: i64, data_out: i64) -> bool {
    if mq_is_empty(pid) {
        return false;
    }

    let base = mq_base_addr(pid);
    let head = read_u64_addr(base + MQ_HEAD) as i64;

    // Calculate message slot address
    let msg_addr = base + MQ_MSGS + (head * MSG_SIZE);

    // Read message
    let src = read_u64_addr(msg_addr + MSG_SRC_PID);
    let data = read_u64_addr(msg_addr + MSG_DATA);

    // Write to output pointers
    write_u64_addr(src_out, src);
    write_u64_addr(data_out, data);

    // Update head and count
    let new_head = (head + 1) % MSG_QUEUE_SIZE;
    write_u64_addr(base + MQ_HEAD, new_head as u64);

    let count = read_u64_addr(base + MQ_COUNT);
    write_u64_addr(base + MQ_COUNT, count - 1);

    true
}

// SYS_SEND - Send message to a process
// arg1 = destination PID, arg2 = message data
fn syscall_send(dst_pid: i64, data: i64) -> i64 {
    // Validate destination PID
    if dst_pid < 0 || dst_pid >= get_num_procs() {
        return -1;  // Invalid PID
    }

    let src_pid = get_current_pid();

    // Check capability to send to destination
    if !cap_check_ipc_send(src_pid, dst_pid) {
        return CAP_ERR_DENIED;
    }

    // Try to enqueue the message
    if mq_enqueue(dst_pid, src_pid, data) {
        0
    } else {
        -2  // Queue full
    }
}

// SYS_RECV - Receive message from queue
// arg1 = pointer to store source PID (or 0 to discard)
// Returns: message data, or -1 if no message
fn syscall_recv(src_out_ptr: i64) -> i64 {
    let current = get_current_pid();
    let mut result: i64 = -1;

    // Use stack variables for output
    let src_addr = SYSCALL_RET_ADDR + 8;   // Temp storage for src
    let data_addr = SYSCALL_RET_ADDR + 16; // Temp storage for data

    // Check if queue has messages
    if !mq_is_empty(current) {
        if mq_dequeue(current, src_addr, data_addr) {
            // Write source PID if caller wants it
            if src_out_ptr != 0 {
                let src = read_u64_addr(src_addr);
                write_u64_addr(src_out_ptr, src);
            }

            result = read_u64_addr(data_addr) as i64;
        }
    }

    result
}

// ============================================================
// Capability Syscalls
// ============================================================

// SYS_CAP_CREATE - Create a new capability (requires ROOT)
// arg1 = capability type, arg2 = target, arg3 = rights
// Returns: capability index, or error code
fn syscall_cap_create(cap_type: i64, target: i64, rights: i64) -> i64 {
    let current = get_current_pid();

    // Only ROOT can create arbitrary capabilities
    if !cap_has_root(current) {
        return CAP_ERR_DENIED;
    }

    // Validate capability type
    if cap_type < CAP_TYPE_IPC || cap_type > CAP_TYPE_ROOT {
        return CAP_ERR_INVALID;
    }

    // Create the capability
    cap_add(current, cap_type, target, rights)
}

// SYS_CAP_DERIVE - Derive a weaker capability from existing one
// arg1 = source capability index, arg2 = new rights
// Returns: new capability index, or error code
fn syscall_cap_derive(src_cap_idx: i64, new_rights: i64) -> i64 {
    let current = get_current_pid();
    cap_derive(current, src_cap_idx, new_rights)
}

// SYS_CAP_GRANT - Grant capability to another process
// arg1 = destination PID, arg2 = capability index
// Returns: 0 on success, or error code
fn syscall_cap_grant(dst_pid: i64, cap_idx: i64) -> i64 {
    // Validate destination PID
    if dst_pid < 0 || dst_pid >= get_num_procs() {
        return CAP_ERR_INVALID;
    }

    let current = get_current_pid();
    cap_grant(current, dst_pid, cap_idx)
}

// SYS_CAP_REVOKE - Revoke a capability
// arg1 = capability index
// Returns: 0 on success, or error code
fn syscall_cap_revoke(cap_idx: i64) -> i64 {
    let current = get_current_pid();
    cap_remove(current, cap_idx)
}

// SYS_CAP_LIST - Get capability info at index
// arg1 = capability index
// Returns: capability type (high byte) | target (low byte), or error code
fn syscall_cap_list(cap_idx: i64) -> i64 {
    let current = get_current_pid();

    let cap_type = cap_get_type(current, cap_idx);
    if cap_type == CAP_TYPE_UNUSED {
        return CAP_ERR_NOT_FOUND;
    }

    let target = cap_get_target(current, cap_idx);
    let rights = cap_get_rights(current, cap_idx);

    // Pack type and target into return value
    // Format: (type * 65536) + (target * 256) + rights
    (cap_type * 65536) + (target * 256) + rights
}

// ============================================================
// RAM Disk Functions
// ============================================================

// Initialize RAM disk with empty filesystem
fn ramfs_init() {
    // Clear superblock
    let mut i: i64 = 0;
    while i < 512 {
        write_u64_addr(RAMFS_SUPERBLOCK + i, 0);
        i = i + 8;
    }

    // Write superblock
    write_u64_addr(RAMFS_SUPERBLOCK + SB_MAGIC, RAMFS_MAGIC as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_VERSION, 1);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_TOTAL_BLOCKS, RAMFS_MAX_BLOCKS as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_FREE_BLOCKS, RAMFS_MAX_BLOCKS as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_TOTAL_FILES, RAMFS_MAX_FILES as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES, 0);

    // Clear file table
    let file_table_size = RAMFS_MAX_FILES * RAMFS_FILE_ENTRY_SIZE;
    i = 0;
    while i < file_table_size {
        write_u64_addr(RAMFS_FILE_TABLE + i, 0);
        i = i + 8;
    }

    // Create initial test files
    ramfs_create_file_internal(104, 101, 108, 108, 111, 0, 0, 0);  // "hello"
    ramfs_write_file_data(0, 72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 10, 0);  // "Hello World!\n"

    ramfs_create_file_internal(116, 101, 115, 116, 0, 0, 0, 0);    // "test"
    ramfs_write_file_data(1, 84, 101, 115, 116, 32, 102, 105, 108, 101, 10, 0, 0, 0, 0);  // "Test file\n"

    // Create "app" - minimal ELF test program (prints "ELF!" and loops)
    // File index will be 2
    ramfs_create_file_internal(97, 112, 112, 0, 0, 0, 0, 0);  // "app"
    ramfs_create_test_elf(2);

    serial_out(82);  // R
    serial_out(65);  // A
    serial_out(77);  // M
    serial_out(70);  // F
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

// Helper: create file with character name (max 8 chars for simplicity)
fn ramfs_create_file_internal(c0: i64, c1: i64, c2: i64, c3: i64, c4: i64, c5: i64, c6: i64, c7: i64) -> i64 {
    // Find free slot
    let used = read_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES) as i64;
    if used >= RAMFS_MAX_FILES {
        return -1;
    }

    let slot = used;
    let entry_addr = RAMFS_FILE_TABLE + (slot * RAMFS_FILE_ENTRY_SIZE);

    // Set flags to regular file
    write_u64_addr(entry_addr + FE_FLAGS, FILE_REGULAR as u64);

    // Write name as bytes (pack into 64-bit values)
    let name_lo: u64 = (c0 as u64) + ((c1 as u64) * 256) + ((c2 as u64) * 65536) + ((c3 as u64) * 16777216)
                     + ((c4 as u64) * 0x100000000) + ((c5 as u64) * 0x10000000000)
                     + ((c6 as u64) * 0x1000000000000) + ((c7 as u64) * 0x100000000000000);
    write_u64_addr(entry_addr + FE_NAME, name_lo);
    write_u64_addr(entry_addr + FE_NAME + 8, 0);  // Clear rest of name

    // Set size to 0 initially
    write_u64_addr(entry_addr + FE_SIZE, 0);

    // Allocate first data block
    let free_blocks = read_u64_addr(RAMFS_SUPERBLOCK + SB_FREE_BLOCKS) as i64;
    if free_blocks <= 0 {
        return -1;
    }

    let block_idx = (RAMFS_MAX_BLOCKS - free_blocks) as i64;
    write_u64_addr(entry_addr + FE_BLOCK, block_idx as u64);
    write_u64_addr(entry_addr + FE_BLOCKS, 1);

    // Update superblock
    write_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES, (used + 1) as u64);
    write_u64_addr(RAMFS_SUPERBLOCK + SB_FREE_BLOCKS, (free_blocks - 1) as u64);

    slot
}

// Helper: write 8 bytes to file at offset (for binary data)
fn ramfs_write_8bytes(file_idx: i64, offset: i64, b0: i64, b1: i64, b2: i64, b3: i64, b4: i64, b5: i64, b6: i64, b7: i64) {
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
    let data_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

    let val: u64 = (b0 as u64) + ((b1 as u64) * 256) + ((b2 as u64) * 65536) + ((b3 as u64) * 16777216)
                 + ((b4 as u64) * 0x100000000) + ((b5 as u64) * 0x10000000000)
                 + ((b6 as u64) * 0x1000000000000) + ((b7 as u64) * 0x100000000000000);
    write_u64_addr(data_addr + offset, val);
}

// Helper: set file size directly
fn ramfs_set_file_size(file_idx: i64, size: i64) {
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    write_u64_addr(entry_addr + FE_SIZE, size as u64);
}

// Create test ELF binary (189 bytes)
// Minimal ELF that prints "ELF!" and yields in a loop
fn ramfs_create_test_elf(file_idx: i64) {
    // ELF Header bytes 0-7:   7f 45 4c 46 02 01 01 00
    ramfs_write_8bytes(file_idx, 0,   0x7F, 0x45, 0x4C, 0x46, 0x02, 0x01, 0x01, 0x00);
    // ELF Header bytes 8-15:  00 00 00 00 00 00 00 00
    ramfs_write_8bytes(file_idx, 8,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    // ELF Header bytes 16-23: 02 00 3e 00 01 00 00 00
    ramfs_write_8bytes(file_idx, 16,  0x02, 0x00, 0x3E, 0x00, 0x01, 0x00, 0x00, 0x00);
    // ELF Header bytes 24-31: 78 00 80 00 00 00 00 00 (entry = 0x800078)
    ramfs_write_8bytes(file_idx, 24,  0x78, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00);
    // ELF Header bytes 32-39: 40 00 00 00 00 00 00 00 (phoff = 64)
    ramfs_write_8bytes(file_idx, 32,  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    // ELF Header bytes 40-47: 00 00 00 00 00 00 00 00 (shoff = 0)
    ramfs_write_8bytes(file_idx, 40,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    // ELF Header bytes 48-55: 00 00 00 00 40 00 38 00
    ramfs_write_8bytes(file_idx, 48,  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00);
    // ELF Header bytes 56-63: 01 00 00 00 00 00 00 00 (phnum = 1)
    ramfs_write_8bytes(file_idx, 56,  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // Program Header bytes 64-71: 01 00 00 00 05 00 00 00 (PT_LOAD, flags=5)
    ramfs_write_8bytes(file_idx, 64,  0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00);
    // Program Header bytes 72-79: 00 00 00 00 00 00 00 00 (offset = 0)
    ramfs_write_8bytes(file_idx, 72,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    // Program Header bytes 80-87: 00 00 80 00 00 00 00 00 (vaddr = 0x800000)
    ramfs_write_8bytes(file_idx, 80,  0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00);
    // Program Header bytes 88-95: 00 00 80 00 00 00 00 00 (paddr = 0x800000)
    ramfs_write_8bytes(file_idx, 88,  0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00);
    // Program Header bytes 96-103: bd 00 00 00 00 00 00 00 (filesz = 189)
    ramfs_write_8bytes(file_idx, 96,  0xBD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    // Program Header bytes 104-111: bd 00 00 00 00 00 00 00 (memsz = 189)
    ramfs_write_8bytes(file_idx, 104, 0xBD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
    // Program Header bytes 112-119: 00 10 00 00 00 00 00 00 (align = 0x1000)
    ramfs_write_8bytes(file_idx, 112, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // Code starts at offset 120 (0x78)
    // mov rax, 2; mov rdi, 'E'; int 0x80
    ramfs_write_8bytes(file_idx, 120, 0xB8, 0x02, 0x00, 0x00, 0x00, 0xBF, 0x45, 0x00);
    ramfs_write_8bytes(file_idx, 128, 0x00, 0x00, 0xCD, 0x80, 0xB8, 0x02, 0x00, 0x00);
    // mov rdi, 'L'; int 0x80
    ramfs_write_8bytes(file_idx, 136, 0x00, 0xBF, 0x4C, 0x00, 0x00, 0x00, 0xCD, 0x80);
    // mov rax, 2; mov rdi, 'F'; int 0x80
    ramfs_write_8bytes(file_idx, 144, 0xB8, 0x02, 0x00, 0x00, 0x00, 0xBF, 0x46, 0x00);
    ramfs_write_8bytes(file_idx, 152, 0x00, 0x00, 0xCD, 0x80, 0xB8, 0x02, 0x00, 0x00);
    // mov rdi, '!'; int 0x80
    ramfs_write_8bytes(file_idx, 160, 0x00, 0xBF, 0x21, 0x00, 0x00, 0x00, 0xCD, 0x80);
    // mov rax, 2; mov rdi, 10; int 0x80
    ramfs_write_8bytes(file_idx, 168, 0xB8, 0x02, 0x00, 0x00, 0x00, 0xBF, 0x0A, 0x00);
    ramfs_write_8bytes(file_idx, 176, 0x00, 0x00, 0xCD, 0x80, 0xB8, 0x00, 0x00, 0x00);
    // loop: mov rax, 0; int 0x80; jmp loop
    ramfs_write_8bytes(file_idx, 184, 0x00, 0xCD, 0x80, 0xEB, 0xF7, 0x00, 0x00, 0x00);

    // Set file size to 189 bytes
    ramfs_set_file_size(file_idx, 189);
}

// Helper: write initial data to file (up to 14 bytes)
fn ramfs_write_file_data(file_idx: i64, b0: i64, b1: i64, b2: i64, b3: i64, b4: i64, b5: i64, b6: i64,
                          b7: i64, b8: i64, b9: i64, b10: i64, b11: i64, b12: i64, b13: i64) {
    let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
    let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
    let data_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

    // Write data bytes
    let lo: u64 = (b0 as u64) + ((b1 as u64) * 256) + ((b2 as u64) * 65536) + ((b3 as u64) * 16777216)
                + ((b4 as u64) * 0x100000000) + ((b5 as u64) * 0x10000000000)
                + ((b6 as u64) * 0x1000000000000) + ((b7 as u64) * 0x100000000000000);
    write_u64_addr(data_addr, lo);

    let hi: u64 = (b8 as u64) + ((b9 as u64) * 256) + ((b10 as u64) * 65536) + ((b11 as u64) * 16777216)
                + ((b12 as u64) * 0x100000000) + ((b13 as u64) * 0x10000000000);
    write_u64_addr(data_addr + 8, hi);

    // Calculate actual size (count non-zero bytes until first zero)
    let mut size: i64 = 14;  // Assume full length
    if b0 == 0 { size = 0; }
    else if b1 == 0 { size = 1; }
    else if b2 == 0 { size = 2; }
    else if b3 == 0 { size = 3; }
    else if b4 == 0 { size = 4; }
    else if b5 == 0 { size = 5; }
    else if b6 == 0 { size = 6; }
    else if b7 == 0 { size = 7; }
    else if b8 == 0 { size = 8; }
    else if b9 == 0 { size = 9; }
    else if b10 == 0 { size = 10; }
    else if b11 == 0 { size = 11; }
    else if b12 == 0 { size = 12; }
    else if b13 == 0 { size = 13; }

    write_u64_addr(entry_addr + FE_SIZE, size as u64);
}

// Find file by name (first 8 chars only for simplicity)
fn ramfs_find_file(name_lo: u64) -> i64 {
    let used = read_u64_addr(RAMFS_SUPERBLOCK + SB_USED_FILES) as i64;
    let mut result: i64 = -1;
    let mut i: i64 = 0;
    while i < used {
        let entry_addr = RAMFS_FILE_TABLE + (i * RAMFS_FILE_ENTRY_SIZE);
        let flags = read_u64_addr(entry_addr + FE_FLAGS) as i64;
        if flags != FILE_UNUSED {
            let entry_name = read_u64_addr(entry_addr + FE_NAME);
            if entry_name == name_lo {
                if result < 0 {
                    result = i;
                }
            }
        }
        i = i + 1;
    }
    result
}

// Read file size
fn ramfs_file_size(file_idx: i64) -> i64 {
    let mut result: i64 = -1;
    if file_idx >= 0 && file_idx < RAMFS_MAX_FILES {
        let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
        result = read_u64_addr(entry_addr + FE_SIZE) as i64;
    }
    result
}

// Read byte from file at offset
fn ramfs_read_byte(file_idx: i64, offset: i64) -> i64 {
    let mut result: i64 = -1;

    if file_idx >= 0 && file_idx < RAMFS_MAX_FILES {
        let entry_addr = RAMFS_FILE_TABLE + (file_idx * RAMFS_FILE_ENTRY_SIZE);
        let size = read_u64_addr(entry_addr + FE_SIZE) as i64;

        if offset >= 0 && offset < size {
            let block_idx = read_u64_addr(entry_addr + FE_BLOCK) as i64;
            let data_addr = RAMFS_DATA_BLOCKS + (block_idx * RAMFS_BLOCK_SIZE);

            // Read byte directly using read_byte_addr for simplicity
            result = read_byte_addr(data_addr + offset);
        }
    }

    result
}

// ============================================================
// File Descriptor Table Functions
// ============================================================

// Get FD table base for a process
fn fd_table_addr(pid: i64) -> i64 {
    FD_TABLE_ADDR + (pid * FD_TABLE_SIZE)
}

// Initialize FD table for a process
fn fd_init(pid: i64) {
    let base = fd_table_addr(pid);
    let mut i: i64 = 0;
    while i < MAX_FDS_PER_PROC {
        let entry = base + (i * FD_ENTRY_SIZE);
        write_u64_addr(entry + FD_FILE_IDX, 0xFFFFFFFFFFFFFFFF);  // -1 = closed
        write_u64_addr(entry + FD_OFFSET, 0);
        i = i + 1;
    }
}

// Allocate a new FD for a process
fn fd_alloc(pid: i64, file_idx: i64) -> i64 {
    let base = fd_table_addr(pid);
    let mut result: i64 = -1;
    let mut i: i64 = 0;
    while i < MAX_FDS_PER_PROC {
        let entry = base + (i * FD_ENTRY_SIZE);
        let idx = read_u64_addr(entry + FD_FILE_IDX);
        if idx == 0xFFFFFFFFFFFFFFFF {
            if result < 0 {
                // Found free slot
                write_u64_addr(entry + FD_FILE_IDX, file_idx as u64);
                write_u64_addr(entry + FD_OFFSET, 0);
                result = i;
            }
        }
        i = i + 1;
    }
    result
}

// Get file index from FD
fn fd_get_file(pid: i64, fd: i64) -> i64 {
    let mut result: i64 = -1;
    if fd >= 0 && fd < MAX_FDS_PER_PROC {
        let base = fd_table_addr(pid);
        let entry = base + (fd * FD_ENTRY_SIZE);
        let idx = read_u64_addr(entry + FD_FILE_IDX);
        if idx != 0xFFFFFFFFFFFFFFFF {
            result = idx as i64;
        }
    }
    result
}

// Get current offset for FD
fn fd_get_offset(pid: i64, fd: i64) -> i64 {
    let mut result: i64 = -1;
    if fd >= 0 && fd < MAX_FDS_PER_PROC {
        let base = fd_table_addr(pid);
        let entry = base + (fd * FD_ENTRY_SIZE);
        result = read_u64_addr(entry + FD_OFFSET) as i64;
    }
    result
}

// Set offset for FD
fn fd_set_offset(pid: i64, fd: i64, offset: i64) {
    if fd >= 0 && fd < MAX_FDS_PER_PROC {
        let base = fd_table_addr(pid);
        let entry = base + (fd * FD_ENTRY_SIZE);
        write_u64_addr(entry + FD_OFFSET, offset as u64);
    }
}

// Close FD
fn fd_close(pid: i64, fd: i64) -> i64 {
    let mut result: i64 = -1;
    if fd >= 0 && fd < MAX_FDS_PER_PROC {
        let base = fd_table_addr(pid);
        let entry = base + (fd * FD_ENTRY_SIZE);
        write_u64_addr(entry + FD_FILE_IDX, 0xFFFFFFFFFFFFFFFF);
        write_u64_addr(entry + FD_OFFSET, 0);
        result = 0;
    }
    result
}

// ============================================================
// ELF64 Loader Functions
// ============================================================

// Read a 16-bit value from file (little-endian)
fn elf_read_u16(file_idx: i64, offset: i64) -> i64 {
    let b0 = ramfs_read_byte(file_idx, offset);
    let b1 = ramfs_read_byte(file_idx, offset + 1);
    if b0 < 0 || b1 < 0 {
        return -1;
    }
    b0 + (b1 * 256)
}

// Read a 32-bit value from file (little-endian)
fn elf_read_u32(file_idx: i64, offset: i64) -> i64 {
    let b0 = ramfs_read_byte(file_idx, offset);
    let b1 = ramfs_read_byte(file_idx, offset + 1);
    let b2 = ramfs_read_byte(file_idx, offset + 2);
    let b3 = ramfs_read_byte(file_idx, offset + 3);
    if b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0 {
        return -1;
    }
    b0 + (b1 * 256) + (b2 * 65536) + (b3 * 16777216)
}

// Read a 64-bit value from file (little-endian)
fn elf_read_u64(file_idx: i64, offset: i64) -> i64 {
    // Read low 32 bits
    let lo = elf_read_u32(file_idx, offset);
    // Read high 32 bits
    let hi = elf_read_u32(file_idx, offset + 4);
    if lo < 0 || hi < 0 {
        return -1;
    }
    // Combine (handle as unsigned)
    let hi_shifted = hi * 0x100000000;  // hi << 32
    lo + hi_shifted
}

// Validate ELF64 header
// Returns ELF_OK if valid, error code otherwise
fn elf_validate(file_idx: i64) -> i64 {
    // Check file exists and has minimum size
    let size = ramfs_file_size(file_idx);
    if size < 64 {
        return ELF_ERR_BAD_MAGIC;
    }

    // Check magic: 0x7F, 'E', 'L', 'F'
    let m0 = ramfs_read_byte(file_idx, 0);
    let m1 = ramfs_read_byte(file_idx, 1);
    let m2 = ramfs_read_byte(file_idx, 2);
    let m3 = ramfs_read_byte(file_idx, 3);

    if m0 != ELF_MAGIC0 || m1 != ELF_MAGIC1 || m2 != ELF_MAGIC2 || m3 != ELF_MAGIC3 {
        return ELF_ERR_BAD_MAGIC;
    }

    // Check class (must be 64-bit)
    let class = ramfs_read_byte(file_idx, EH_CLASS);
    if class != ELF_CLASS64 {
        return ELF_ERR_NOT_64BIT;
    }

    // Check endianness (must be little-endian)
    let data = ramfs_read_byte(file_idx, EH_DATA);
    if data != ELF_DATA_LE {
        return ELF_ERR_NOT_LE;
    }

    // Check type (must be executable)
    let elf_type = elf_read_u16(file_idx, EH_TYPE);
    if elf_type != ET_EXEC {
        return ELF_ERR_NOT_EXEC;
    }

    // Check machine (must be x86-64)
    let machine = elf_read_u16(file_idx, EH_MACHINE);
    if machine != EM_X86_64 {
        return ELF_ERR_BAD_ARCH;
    }

    ELF_OK
}

// Get ELF entry point
fn elf_get_entry(file_idx: i64) -> i64 {
    elf_read_u64(file_idx, EH_ENTRY)
}

// Get program header offset
fn elf_get_phoff(file_idx: i64) -> i64 {
    elf_read_u64(file_idx, EH_PHOFF)
}

// Get number of program headers
fn elf_get_phnum(file_idx: i64) -> i64 {
    elf_read_u16(file_idx, EH_PHNUM)
}

// Get program header entry size
fn elf_get_phentsize(file_idx: i64) -> i64 {
    elf_read_u16(file_idx, EH_PHENTSIZE)
}

// Load a single LOAD segment from file to memory
// Returns 0 on success, -1 on failure
fn elf_load_segment(file_idx: i64, ph_offset: i64, load_base: i64) -> i64 {
    // Read segment type
    let seg_type = elf_read_u32(file_idx, ph_offset + PH_TYPE);
    if seg_type != PT_LOAD {
        // Not a LOAD segment, skip
        return 0;
    }

    // Read segment info
    let file_offset = elf_read_u64(file_idx, ph_offset + PH_OFFSET);
    let vaddr = elf_read_u64(file_idx, ph_offset + PH_VADDR);
    let filesz = elf_read_u64(file_idx, ph_offset + PH_FILESZ);
    let memsz = elf_read_u64(file_idx, ph_offset + PH_MEMSZ);

    // Debug output
    serial_out(76);  // L
    serial_out(79);  // O
    serial_out(65);  // A
    serial_out(68);  // D
    serial_out(58);  // :
    serial_hex32(vaddr as u64);
    serial_out(32);  // space
    serial_hex32(filesz as u64);
    serial_newline();

    // Calculate destination address
    // Use load_base as offset from vaddr
    let dest_addr = load_base + (vaddr % ELF_LOAD_SIZE);

    // Copy file data to memory
    let mut i: i64 = 0;
    while i < filesz {
        let byte = ramfs_read_byte(file_idx, file_offset + i);
        if byte >= 0 {
            write_byte_addr(dest_addr + i, byte);
        }
        i = i + 1;
    }

    // Zero out BSS (memsz > filesz)
    while i < memsz {
        write_byte_addr(dest_addr + i, 0);
        i = i + 1;
    }

    0
}

// Load all LOAD segments from ELF file
// Returns entry point address on success, negative error on failure
fn elf_load_segments(file_idx: i64, load_base: i64) -> i64 {
    let phoff = elf_get_phoff(file_idx);
    let phnum = elf_get_phnum(file_idx);
    let phentsize = elf_get_phentsize(file_idx);

    serial_out(80);  // P
    serial_out(72);  // H
    serial_out(58);  // :
    serial_out(48 + phnum);
    serial_newline();

    // Load each program header
    let mut i: i64 = 0;
    while i < phnum {
        let ph_offset = phoff + (i * phentsize);
        let result = elf_load_segment(file_idx, ph_offset, load_base);
        if result < 0 {
            return ELF_ERR_LOAD_FAIL;
        }
        i = i + 1;
    }

    // Return entry point (adjusted for load base)
    let entry = elf_get_entry(file_idx);
    load_base + (entry % ELF_LOAD_SIZE)
}

// Execute an ELF file by name
// Creates a new user process and loads the ELF binary
// Returns new PID on success, negative error on failure
fn elf_exec(name_lo: u64) -> i64 {
    // Find file in RAMFS
    let file_idx = ramfs_find_file(name_lo);
    if file_idx < 0 {
        serial_out(69);  // E
        serial_out(78);  // N
        serial_out(70);  // F (not found)
        serial_newline();
        return ELF_ERR_NOT_FOUND;
    }

    // Validate ELF header
    let valid = elf_validate(file_idx);
    if valid != ELF_OK {
        serial_out(69);  // E
        serial_out(73);  // I (invalid)
        serial_out(48 - valid);  // error code
        serial_newline();
        return valid;
    }

    serial_out(69);  // E
    serial_out(76);  // L
    serial_out(70);  // F
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Calculate load base for this process
    let num_procs = get_num_procs();
    if num_procs >= MAX_PROCS {
        return ELF_ERR_NO_PROC;
    }
    let load_base = ELF_LOAD_BASE + (num_procs * ELF_LOAD_SIZE);

    // Load ELF segments to memory
    let entry = elf_load_segments(file_idx, load_base);
    if entry < 0 {
        return entry;
    }

    serial_out(69);  // E
    serial_out(78);  // N
    serial_out(84);  // T
    serial_out(58);  // :
    serial_hex32(entry as u64);
    serial_newline();

    // Create user process with entry point
    let pid = elf_create_process(entry);

    pid
}

// Execute an ELF file at its native address (no relocation)
// Used for Init which is loaded at 0x800000 directly
fn elf_exec_native(name_lo: u64) -> i64 {
    // Find file in RAMFS
    let file_idx = ramfs_find_file(name_lo);
    if file_idx < 0 {
        serial_out(69);  // E
        serial_out(78);  // N
        serial_out(70);  // F (not found)
        serial_newline();
        return ELF_ERR_NOT_FOUND;
    }

    // Validate ELF header
    let valid = elf_validate(file_idx);
    if valid != ELF_OK {
        serial_out(69);  // E
        serial_out(73);  // I (invalid)
        serial_out(48 - valid);  // error code
        serial_newline();
        return valid;
    }

    serial_out(69);  // E
    serial_out(76);  // L
    serial_out(70);  // F
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Load ELF segments at native addresses (no relocation)
    let entry = elf_load_segments_native(file_idx);
    if entry < 0 {
        return entry;
    }

    // Debug: print entry point value safely
    serial_out(69);  // E
    serial_out(78);  // N
    serial_out(84);  // T
    serial_out(58);  // :
    // Print as simple decimal first to avoid complex hex function
    serial_print_dec(entry);
    serial_out(32);  // space
    // Now try hex
    serial_out(72);  // H
    serial_hex32(entry as u64);
    serial_newline();

    // Create user process with entry point
    let pid = elf_create_process(entry);

    pid
}

// Load ELF segments at their native addresses (no relocation)
fn elf_load_segments_native(file_idx: i64) -> i64 {
    let phoff = elf_get_phoff(file_idx);
    let phnum = elf_get_phnum(file_idx);
    let phentsize = elf_get_phentsize(file_idx);

    serial_out(80);  // P
    serial_out(72);  // H
    serial_out(58);  // :
    serial_out(48 + phnum);
    serial_newline();

    // Load each program header
    let mut i: i64 = 0;
    while i < phnum {
        let ph_offset = phoff + (i * phentsize);
        let result = elf_load_segment_native(file_idx, ph_offset);
        if result < 0 {
            return ELF_ERR_LOAD_FAIL;
        }
        i = i + 1;
    }

    // Return entry point directly (no adjustment)
    elf_get_entry(file_idx)
}

// Load a single ELF segment at its native address
fn elf_load_segment_native(file_idx: i64, ph_offset: i64) -> i64 {
    // Read segment type
    let seg_type = elf_read_u32(file_idx, ph_offset + PH_TYPE);
    if seg_type != PT_LOAD {
        // Not a LOAD segment, skip
        return 0;
    }

    // Read segment info
    let file_offset = elf_read_u64(file_idx, ph_offset + PH_OFFSET);
    let vaddr = elf_read_u64(file_idx, ph_offset + PH_VADDR);
    let filesz = elf_read_u64(file_idx, ph_offset + PH_FILESZ);
    let memsz = elf_read_u64(file_idx, ph_offset + PH_MEMSZ);

    // Debug output
    serial_out(76);  // L
    serial_out(79);  // O
    serial_out(65);  // A
    serial_out(68);  // D
    serial_out(58);  // :
    serial_hex32(vaddr as u64);
    serial_out(32);  // space
    serial_hex32(filesz as u64);
    serial_newline();

    // Use vaddr directly (native address, no relocation)
    let dest_addr = vaddr as i64;

    // Copy file data to memory
    let mut i: i64 = 0;
    while i < filesz {
        let byte = ramfs_read_byte(file_idx, file_offset + i);
        if byte >= 0 {
            write_byte_addr(dest_addr + i, byte);
        }
        i = i + 1;
    }

    // Zero out BSS (memsz > filesz)
    while i < memsz {
        write_byte_addr(dest_addr + i, 0);
        i = i + 1;
    }

    0  // Success
}

// Create a new user process for ELF execution
// Similar to proc_create_user but uses dynamic entry point
fn elf_create_process(entry: i64) -> i64 {
    // First, search for a reusable Unused slot
    let num_procs = get_num_procs();
    let mut pid: i64 = 0 - 1;  // -1 means not found

    // Search existing slots for Unused state
    let mut i: i64 = 0;
    while i < num_procs && pid < 0 {
        let state = pcb_get_state(i);
        if state == ProcState::Unused {
            pid = i;  // Found a reusable slot
        }
        i = i + 1;
    }

    // If no reusable slot, use a new one
    let is_new_slot: i64;
    if pid < 0 {
        if num_procs >= MAX_PROCS {
            return -1;  // No slots available
        }
        pid = num_procs;
        is_new_slot = 1;
    } else {
        is_new_slot = 0;
    }

    let pcb = pcb_addr(pid);

    // Calculate user stack for this process
    let user_stack_base = PROC_STACK_BASE + (pid * PROC_STACK_SIZE);
    let user_stack_top = user_stack_base + PROC_STACK_SIZE;

    // Calculate kernel stack for this process
    let kernel_stack_base = KSTACK_BASE + (pid * KSTACK_SIZE);
    let kernel_stack_top = kernel_stack_base + KSTACK_SIZE;

    // Initialize the process stack for user mode
    let initial_rsp = init_process_stack_user(user_stack_top, kernel_stack_top, entry);

    // Get parent PID (current process executing exec)
    let parent_pid = get_current_pid();

    // Fill PCB
    write_u64_addr(pcb + PCB_PID, pid as u64);
    write_u64_addr(pcb + PCB_STATE, proc_state_to_i64(ProcState::Ready) as u64);
    write_u64_addr(pcb + PCB_RSP, initial_rsp as u64);
    write_u64_addr(pcb + PCB_STACK_BASE, user_stack_base as u64);
    write_u64_addr(pcb + PCB_KSTACK_BASE, kernel_stack_base as u64);
    write_u64_addr(pcb + PCB_FLAGS, PROC_FLAG_USER as u64);

    // Initialize extended PCB fields (Phase 11)
    write_u64_addr(pcb + PCB_PARENT_PID, parent_pid as u64);
    write_u64_addr(pcb + PCB_EXIT_CODE, 0);
    write_u64_addr(pcb + PCB_PENDING_SIG, 0);
    write_u64_addr(pcb + PCB_CHILD_COUNT, 0);

    // Increment parent's child count
    let parent_children = pcb_get_child_count(parent_pid);
    pcb_set_child_count(parent_pid, parent_children + 1);

    // Initialize FD table for new process
    fd_init(pid);

    // Initialize capability table for new process
    cap_init(pid);

    // Give basic capabilities (can be restricted later)
    cap_add(pid, CAP_TYPE_ROOT, 0, CAP_RIGHT_ALL);

    // Only increment process count if using a new slot
    if is_new_slot == 1 {
        write_u64_addr(NUM_PROCS_ADDR, (num_procs + 1) as u64);
    }

    serial_out(69);  // E
    serial_out(88);  // X
    serial_out(69);  // E
    serial_out(67);  // C
    serial_out(58);  // :
    serial_out(48 + pid);
    serial_newline();

    pid
}

// ============================================================
// Memory-Mapped ELF Loading (Phase 13)
// ============================================================
// These functions use demand paging instead of copying ELF data upfront.
// Pages are loaded on-demand when accessed via page faults.

// Load a single LOAD segment using memory mapping (no immediate copy)
// Returns 0 on success, negative error on failure
fn elf_load_segment_mmap(file_idx: i64, ph_offset: i64, load_base: i64, pid: i64) -> i64 {
    // Read segment type
    let seg_type = elf_read_u32(file_idx, ph_offset + PH_TYPE);
    if seg_type != PT_LOAD {
        // Not a LOAD segment, skip
        return 0;
    }

    // Read segment info
    let file_offset = elf_read_u64(file_idx, ph_offset + PH_OFFSET);
    let vaddr = elf_read_u64(file_idx, ph_offset + PH_VADDR);
    let filesz = elf_read_u64(file_idx, ph_offset + PH_FILESZ);
    let memsz = elf_read_u64(file_idx, ph_offset + PH_MEMSZ);
    let pflags = elf_read_u32(file_idx, ph_offset + PH_FLAGS);

    // Calculate destination address
    let dest_addr = load_base + (vaddr % ELF_LOAD_SIZE);

    // Debug output
    serial_out(77);  // M
    serial_out(76);  // L
    serial_out(79);  // O
    serial_out(65);  // A
    serial_out(68);  // D
    serial_out(58);  // :
    serial_hex32(dest_addr as u64);
    serial_out(32);  // space
    serial_hex32(memsz as u64);
    serial_newline();

    // Convert ELF flags to mmap flags
    let mut mmap_flags: i64 = MMAP_FLAG_READ;  // Always readable
    if ((pflags / 2) % 2) != 0 {  // PF_W (bit 1)
        mmap_flags = mmap_flags + MMAP_FLAG_WRITE;
    }
    if (pflags % 2) != 0 {  // PF_X (bit 0)
        mmap_flags = mmap_flags + MMAP_FLAG_EXEC;
    }

    // Create memory mapping for this segment
    // The actual data will be loaded on page fault
    let result = mmap_create(dest_addr, memsz, file_idx, file_offset, mmap_flags, pid);
    if result < 0 {
        serial_out(77);  // M
        serial_out(69);  // E (Mmap Error)
        serial_newline();
        return -1;
    }

    // For BSS section (memsz > filesz), we need to handle zero-fill
    // This is handled in mmap_handle_fault when reading past file end

    0
}

// Load all LOAD segments using memory mapping
// Returns entry point address on success, negative error on failure
fn elf_load_segments_mmap(file_idx: i64, load_base: i64, pid: i64) -> i64 {
    let phoff = elf_get_phoff(file_idx);
    let phnum = elf_get_phnum(file_idx);
    let phentsize = elf_get_phentsize(file_idx);

    serial_out(77);  // M
    serial_out(80);  // P
    serial_out(72);  // H
    serial_out(58);  // :
    serial_out(48 + phnum);
    serial_newline();

    // Create mappings for each program header
    let mut i: i64 = 0;
    while i < phnum {
        let ph_offset = phoff + (i * phentsize);
        let result = elf_load_segment_mmap(file_idx, ph_offset, load_base, pid);
        if result < 0 {
            return ELF_ERR_LOAD_FAIL;
        }
        i = i + 1;
    }

    // Return entry point (adjusted for load base)
    let entry = elf_get_entry(file_idx);
    load_base + (entry % ELF_LOAD_SIZE)
}

// Execute an ELF file using memory-mapped loading (demand paging)
// Creates a new user process with lazy loading of ELF segments
// Returns new PID on success, negative error on failure
fn elf_exec_mmap(name_lo: u64) -> i64 {
    // Find file in RAMFS
    let file_idx = ramfs_find_file(name_lo);
    if file_idx < 0 {
        serial_out(69);  // E
        serial_out(78);  // N
        serial_out(70);  // F (not found)
        serial_newline();
        return ELF_ERR_NOT_FOUND;
    }

    // Validate ELF header
    let valid = elf_validate(file_idx);
    if valid != ELF_OK {
        serial_out(69);  // E
        serial_out(73);  // I (invalid)
        serial_out(48 - valid);  // error code
        serial_newline();
        return valid;
    }

    serial_out(77);  // M
    serial_out(69);  // E
    serial_out(76);  // L
    serial_out(70);  // F (MELF = Memory-mapped ELF)
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Calculate load base for this process
    let num_procs = get_num_procs();
    if num_procs >= MAX_PROCS {
        return ELF_ERR_NO_PROC;
    }
    let load_base = ELF_LOAD_BASE + (num_procs * ELF_LOAD_SIZE);

    // We need to create the process FIRST so we have a PID for the mappings
    // Get entry point from ELF header
    let entry_raw = elf_get_entry(file_idx);
    let entry = load_base + (entry_raw % ELF_LOAD_SIZE);

    // Create user process with entry point
    let pid = elf_create_process(entry);
    if pid < 0 {
        return pid;
    }

    // Now create memory mappings for the ELF segments
    let mapped_entry = elf_load_segments_mmap(file_idx, load_base, pid);
    if mapped_entry < 0 {
        // Failed to create mappings - clean up process
        // Note: ideally we'd have a proc_destroy here, but for now just mark unused
        mmap_remove_process(pid);
        return mapped_entry;
    }

    serial_out(77);  // M
    serial_out(69);  // E
    serial_out(78);  // N
    serial_out(84);  // T
    serial_out(58);  // :
    serial_hex32(entry as u64);
    serial_newline();

    pid
}

// ============================================================
// Capability Table Functions
// ============================================================

// Get capability table base address for a process
fn cap_table_addr(pid: i64) -> i64 {
    CAP_TABLE_ADDR + (pid * CAP_TABLE_SIZE)
}

// Initialize capability table for a process
fn cap_init(pid: i64) {
    let base = cap_table_addr(pid);
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        write_u64_addr(entry + CAP_TYPE, CAP_TYPE_UNUSED as u64);
        write_u64_addr(entry + CAP_TARGET, 0);
        write_u64_addr(entry + CAP_RIGHTS, 0);
        i = i + 1;
    }
}

// Find a free capability slot for a process
fn cap_find_free(pid: i64) -> i64 {
    let base = cap_table_addr(pid);
    let mut result: i64 = -1;
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        let cap_type = read_u64_addr(entry + CAP_TYPE) as i64;
        if cap_type == CAP_TYPE_UNUSED {
            if result < 0 {
                result = i;
            }
        }
        i = i + 1;
    }
    result
}

// Add a capability to a process's table
fn cap_add(pid: i64, cap_type: i64, target: i64, rights: i64) -> i64 {
    let slot = cap_find_free(pid);
    if slot < 0 {
        return CAP_ERR_FULL;
    }

    let base = cap_table_addr(pid);
    let entry = base + (slot * CAP_ENTRY_SIZE);
    write_u64_addr(entry + CAP_TYPE, cap_type as u64);
    write_u64_addr(entry + CAP_TARGET, target as u64);
    write_u64_addr(entry + CAP_RIGHTS, rights as u64);

    slot  // Return capability index
}

// Remove a capability from a process
fn cap_remove(pid: i64, cap_idx: i64) -> i64 {
    let mut result: i64 = CAP_ERR_NOT_FOUND;
    if cap_idx >= 0 && cap_idx < MAX_CAPS_PER_PROC {
        let base = cap_table_addr(pid);
        let entry = base + (cap_idx * CAP_ENTRY_SIZE);
        write_u64_addr(entry + CAP_TYPE, CAP_TYPE_UNUSED as u64);
        write_u64_addr(entry + CAP_TARGET, 0);
        write_u64_addr(entry + CAP_RIGHTS, 0);
        result = CAP_ERR_NONE;
    }
    result
}

// Get capability type at index
fn cap_get_type(pid: i64, cap_idx: i64) -> i64 {
    let mut result: i64 = CAP_TYPE_UNUSED;
    if cap_idx >= 0 && cap_idx < MAX_CAPS_PER_PROC {
        let base = cap_table_addr(pid);
        let entry = base + (cap_idx * CAP_ENTRY_SIZE);
        result = read_u64_addr(entry + CAP_TYPE) as i64;
    }
    result
}

// Get capability target at index
fn cap_get_target(pid: i64, cap_idx: i64) -> i64 {
    let mut result: i64 = 0;
    if cap_idx >= 0 && cap_idx < MAX_CAPS_PER_PROC {
        let base = cap_table_addr(pid);
        let entry = base + (cap_idx * CAP_ENTRY_SIZE);
        result = read_u64_addr(entry + CAP_TARGET) as i64;
    }
    result
}

// Get capability rights at index
fn cap_get_rights(pid: i64, cap_idx: i64) -> i64 {
    let mut result: i64 = 0;
    if cap_idx >= 0 && cap_idx < MAX_CAPS_PER_PROC {
        let base = cap_table_addr(pid);
        let entry = base + (cap_idx * CAP_ENTRY_SIZE);
        result = read_u64_addr(entry + CAP_RIGHTS) as i64;
    }
    result
}

// Check if process has ROOT capability
fn cap_has_root(pid: i64) -> bool {
    let base = cap_table_addr(pid);
    let mut has_root: bool = false;
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        let cap_type = read_u64_addr(entry + CAP_TYPE) as i64;
        if cap_type == CAP_TYPE_ROOT {
            has_root = true;
        }
        i = i + 1;
    }
    has_root
}

// Check if process has IPC capability to send to target
fn cap_check_ipc_send(pid: i64, target_pid: i64) -> bool {
    // ROOT capability allows all IPC
    if cap_has_root(pid) {
        return true;
    }

    let base = cap_table_addr(pid);
    let mut allowed: bool = false;
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        let cap_type = read_u64_addr(entry + CAP_TYPE) as i64;
        let target = read_u64_addr(entry + CAP_TARGET) as i64;
        let rights = read_u64_addr(entry + CAP_RIGHTS) as i64;

        if cap_type == CAP_TYPE_IPC && target == target_pid {
            // Check SEND right using modulo to avoid bitwise issues
            if (rights / CAP_RIGHT_SEND) % 2 == 1 {
                allowed = true;
            }
        }
        i = i + 1;
    }
    allowed
}

// Check if process has FILE capability for a file
fn cap_check_file(pid: i64, file_idx: i64, required_rights: i64) -> bool {
    // ROOT capability allows all file access
    if cap_has_root(pid) {
        return true;
    }

    let base = cap_table_addr(pid);
    let mut allowed: bool = false;
    let mut i: i64 = 0;
    while i < MAX_CAPS_PER_PROC {
        let entry = base + (i * CAP_ENTRY_SIZE);
        let cap_type = read_u64_addr(entry + CAP_TYPE) as i64;
        let target = read_u64_addr(entry + CAP_TARGET) as i64;
        let rights = read_u64_addr(entry + CAP_RIGHTS) as i64;

        if cap_type == CAP_TYPE_FILE && target == file_idx {
            // Check if required rights are present
            // For READ (1): check bit 0
            // For WRITE (2): check bit 1
            let mut has_rights: bool = true;

            if required_rights == CAP_RIGHT_READ {
                if rights % 2 != 1 {
                    has_rights = false;
                }
            } else if required_rights == CAP_RIGHT_WRITE {
                if (rights / 2) % 2 != 1 {
                    has_rights = false;
                }
            }

            if has_rights {
                allowed = true;
            }
        }
        i = i + 1;
    }
    allowed
}

// Derive a new capability from an existing one (with same or fewer rights)
fn cap_derive(pid: i64, src_cap_idx: i64, new_rights: i64) -> i64 {
    // Check source capability exists and has DERIVE right
    let src_type = cap_get_type(pid, src_cap_idx);
    if src_type == CAP_TYPE_UNUSED {
        return CAP_ERR_NOT_FOUND;
    }

    let src_rights = cap_get_rights(pid, src_cap_idx);

    // Check DERIVE right (bit 4)
    if (src_rights / 16) % 2 != 1 {
        return CAP_ERR_DENIED;
    }

    // New rights must be subset of source rights (excluding DERIVE)
    // Since we can't use bitwise AND easily, we check individually
    let base_rights = src_rights % 16;  // Rights without DERIVE/DELEGATE
    let requested = new_rights % 16;

    // For simplicity, allow if new_rights <= base_rights
    // This isn't perfect subset checking but works for common cases
    if requested > base_rights {
        return CAP_ERR_DENIED;
    }

    // Create new capability
    let target = cap_get_target(pid, src_cap_idx);
    cap_add(pid, src_type, target, new_rights)
}

// Grant a capability to another process (transfer via IPC)
fn cap_grant(src_pid: i64, dst_pid: i64, cap_idx: i64) -> i64 {
    // Check source capability exists and has DELEGATE right
    let cap_type = cap_get_type(src_pid, cap_idx);
    if cap_type == CAP_TYPE_UNUSED {
        return CAP_ERR_NOT_FOUND;
    }

    let rights = cap_get_rights(src_pid, cap_idx);

    // Check DELEGATE right (bit 5)
    if (rights / 32) % 2 != 1 {
        return CAP_ERR_DENIED;
    }

    // Copy capability to destination (without DELEGATE right)
    let target = cap_get_target(src_pid, cap_idx);
    let new_rights = rights % 32;  // Remove DELEGATE right

    cap_add(dst_pid, cap_type, target, new_rights)
}

fn handle_exception(num: i64, error_code: u64, rip: u64) {
    // Print to serial
    serial_out(69);  // E
    serial_out(88);  // X
    serial_out(67);  // C
    serial_out(58);  // :
    serial_out(48 + ((num / 10) % 10));
    serial_out(48 + (num % 10));
    serial_newline();

    // Print error code (use serial_hex32 for reliability)
    serial_out(69); serial_out(82); serial_out(82); serial_out(58); // ERR:
    serial_hex32(error_code);
    serial_newline();

    // Print RIP
    serial_out(82); serial_out(73); serial_out(80); serial_out(58); // RIP:
    serial_hex32(rip);
    serial_newline();

    // Page fault: try demand paging first, then print debug info if it fails
    if num == 14 {
        serial_out(80);  // P
        serial_out(70);  // F
        serial_out(33);  // ! (PF! = Page Fault)
        let cr2 = read_cr2();
        let fault_addr = cr2 as i64;

        // Check if this is a non-present page (P bit = 0)
        // If so, try to handle via memory-mapped files (demand paging)
        let p = error_code % 2;  // bit 0 - present

        if p == 0 {
            // Page not present - try demand paging
            let current_pid = get_current_pid();
            let result = mmap_handle_fault(fault_addr, current_pid);

            if result == 0 {
                // Successfully loaded the page - return to retry the instruction
                // The page fault handler in isr.asm will iret back to the faulting instruction
                serial_out(68);  // D
                serial_out(80);  // P
                serial_out(79);  // O
                serial_out(75);  // K (Demand Paging OK)
                serial_newline();
                return;  // Return from exception handler - instruction will be retried
            }
        }

        // If we get here, it's a real page fault (not demand paging)
        // Print debug info
        serial_out(67); serial_out(82); serial_out(50); serial_out(58); // CR2:
        let cr2_lo = cr2 % 0x100000000;
        serial_hex32(cr2_lo);
        serial_newline();

        // Print error code bits
        serial_out(66); serial_out(73); serial_out(84); serial_out(58); // BIT:
        let w = (error_code / 2) % 2;  // bit 1 - write
        let u = (error_code / 4) % 2;  // bit 2 - user
        let r = (error_code / 8) % 2;  // bit 3 - reserved
        let i = (error_code / 16) % 2;  // bit 4 - instruction
        serial_out(80);  // P
        serial_out(48 + (p as i64));
        serial_out(87);  // W
        serial_out(48 + (w as i64));
        serial_out(85);  // U
        serial_out(48 + (u as i64));
        serial_out(82);  // R
        serial_out(48 + (r as i64));
        serial_out(73);  // I
        serial_out(48 + (i as i64));
        serial_newline();
    }

    // Display on VGA
    let red: i64 = 0x4F;
    vga_write_char_color(0, 20, 69, red);   // E
    vga_write_char_color(1, 20, 88, red);   // X
    vga_write_char_color(2, 20, 67, red);   // C
    vga_write_char_color(3, 20, 32, red);   // space
    vga_write_hex_byte(4, 20, num as u64, red);

    // Halt on fatal exceptions
    if num == 8 || num == 13 || num == 14 {
        // Debug: dump TSS.RSP0 at fault time
        serial_out(84); serial_out(82); serial_out(48); serial_out(61);  // TR0=
        let tss_rsp0 = tss_get_kernel_stack();
        serial_hex32(tss_rsp0 as u64);
        serial_newline();

        // Debug: dump TSS address
        serial_out(84); serial_out(65); serial_out(61);  // TA=
        let tss_addr = get_tss64_addr();
        serial_hex32(tss_addr as u64);
        serial_newline();

        // Debug: directly read 8 bytes at TSS+4 (RSP0 location)
        serial_out(82); serial_out(65); serial_out(87); serial_out(61);  // RAW=
        let raw_rsp0 = read_u64_addr(tss_addr + 4);
        serial_hex32(raw_rsp0);
        serial_newline();

        // Debug: read TR register
        serial_out(84); serial_out(82); serial_out(61);  // TR=
        let tr_val = read_tr();
        serial_hex32(tr_val as u64);
        serial_newline();

        // Debug: read GDT base from TSS descriptor (at GDT + 0x28)
        let gdt_base = get_gdt64_addr();
        let tss_desc_addr = gdt_base + 0x28;  // TSS selector offset
        serial_out(71); serial_out(84); serial_out(68); serial_out(61);  // GTD=
        let desc_word0 = read_u64_addr(tss_desc_addr);
        let desc_word1 = read_u64_addr(tss_desc_addr + 8);
        serial_hex32(desc_word0);
        serial_out(32);
        serial_hex32(desc_word1);
        serial_newline();

        // Extract base from TSS descriptor
        let base_lo = (desc_word0 / 0x10000) % 0x10000;  // bits 16-31
        let base_mid = (desc_word0 / 0x100000000) % 0x100;  // bits 32-39
        let base_hi = (desc_word0 / 0x1000000000000) % 0x100;  // bits 48-55
        let base_upper = desc_word1 % 0x100000000;  // bits 0-31 of second qword
        let tss_base = base_lo + (base_mid * 0x10000) + (base_hi * 0x1000000) + (base_upper * 0x100000000);
        serial_out(84); serial_out(66); serial_out(61);  // TB=
        serial_hex32(tss_base);
        serial_newline();

        serial_out(72); serial_out(65); serial_out(76); serial_out(84); // HALT
        serial_newline();
        loop {
            unsafe { asm!("cli; hlt", options(nomem, nostack)); }
        }
    }
}

fn handle_irq(irq: i64) {
    // L14: IRQ dispatch using match
    match irq {
        0 => handle_timer(),      // Timer interrupt (IRQ0)
        1 => handle_keyboard(),   // Keyboard interrupt (IRQ1)
        _ => {
            // Check if userspace handler registered
            irq_forward_to_userspace(irq);
        },
    }

    // Send EOI
    pic_send_eoi(irq);
}

fn handle_timer() {
    let ticks = read_u64_addr(TICK_COUNT_ADDR);
    write_u64_addr(TICK_COUNT_ADDR, ticks + 1);

    // Every 100 ticks (~1 second), update VGA timer display
    if (ticks + 1) % 100 == 0 {
        let seconds = ((ticks + 1) / 100) as i64;
        let green: i64 = 0x0A;
        vga_write_char_color(0, 10, 84, green);  // T
        vga_write_char_color(1, 10, 58, green);  // :

        let d2 = (seconds / 100) % 10;
        let d1 = (seconds / 10) % 10;
        let d0 = seconds % 10;
        vga_write_char_color(2, 10, 48 + d2, green);
        vga_write_char_color(3, 10, 48 + d1, green);
        vga_write_char_color(4, 10, 48 + d0, green);
        vga_write_char_color(5, 10, 115, green); // s
    }
}

fn handle_keyboard() {
    let scancode = inb(0x60);

    // Translate scancode to ASCII
    let ch = scancode_to_ascii(scancode);

    // If valid character, add to keyboard buffer
    if ch > 0 {
        kb_buffer_push(ch);
    }
}

// ============================================================
// Interrupt Initialization
// ============================================================

fn init_interrupts() {
    let white = vga_color(COLOR_WHITE, COLOR_BLACK);
    let green = vga_color(COLOR_GREEN, COLOR_BLACK);

    // Line 9: "INT init..."
    vga_write_char(0, 9, 73, white);   // I
    vga_write_char(1, 9, 78, white);   // N
    vga_write_char(2, 9, 84, white);   // T
    vga_write_char(3, 9, 32, white);   // space
    vga_write_char(4, 9, 105, white);  // i
    vga_write_char(5, 9, 110, white);  // n
    vga_write_char(6, 9, 105, white);  // i
    vga_write_char(7, 9, 116, white);  // t

    // Initialize PIC (remap IRQs to 32-47)
    pic_init();

    // Initialize PIT timer (~100 Hz)
    timer_init();

    // Initialize IDT with ISR stubs
    idt_init();

    // DEBUG: Dump IDT entry 128 to verify syscall handler setup
    {
        let entry_addr = IDT_ADDR + (128 * IDT_ENTRY_SIZE);
        serial_out(73);  // I
        serial_out(68);  // D
        serial_out(84);  // T
        serial_out(49);  // 1
        serial_out(50);  // 2
        serial_out(56);  // 8
        serial_out(58);  // :
        // Read and print key parts using 32-bit reads
        let lo = read_u32_at(entry_addr, 0) as u64;  // offset_low + selector
        let hi = read_u32_at(entry_addr, 4) as u64;  // type_attr + offset_mid
        let top = read_u32_at(entry_addr, 8) as u64; // offset_high
        serial_hex32(lo);
        serial_out(32);
        serial_hex32(hi);
        serial_out(32);
        serial_hex32(top);
        serial_newline();
        // Also print expected syscall handler address
        let syscall_ptr = get_syscall_stub_ptr();
        let syscall_handler = read_u64_addr(syscall_ptr);
        serial_out(72);  // H
        serial_out(68);  // D
        serial_out(76);  // L
        serial_out(82);  // R
        serial_out(58);  // :
        serial_hex32(syscall_handler as u64);
        serial_newline();
    }

    // DEBUG: Dump TSS info
    {
        let tss_addr = get_tss64_addr();
        let rsp0 = tss_get_kernel_stack();
        serial_out(84);  // T
        serial_out(83);  // S
        serial_out(83);  // S
        serial_out(64);  // @
        serial_hex32(tss_addr as u64);
        serial_out(32);
        serial_out(82);  // R
        serial_out(48);  // 0
        serial_out(61);  // =
        serial_hex32(rsp0 as u64);
        serial_newline();
        // Dump GDT TSS descriptor
        let gdt_base = get_gdt64_addr();
        let tss_desc_addr = gdt_base + GDT_TSS_OFFSET;
        serial_out(71);  // G
        serial_out(68);  // D
        serial_out(84);  // T
        serial_out(64);  // @
        serial_hex32(gdt_base as u64);
        serial_out(32);
        serial_out(68);  // D
        serial_out(61);  // =
        // TSS descriptor is 16 bytes
        let desc_lo = read_u64_addr(tss_desc_addr);
        let desc_hi = read_u64_addr(tss_desc_addr + 8);
        serial_hex32((desc_lo % 0x100000000) as u64);
        serial_out(32);
        serial_hex32((desc_lo / 0x100000000) as u64);
        serial_out(32);
        serial_hex32((desc_hi % 0x100000000) as u64);
        serial_newline();
    }

    // TEST: Verify page 0 is mapped by reading from address 0
    {
        let test_val = read_u64_addr(0);  // Read from address 0
        serial_out(80);  // P
        serial_out(71);  // G
        serial_out(48);  // 0
        serial_out(58);  // :
        serial_hex32((test_val % 0x100000000) as u64);
        serial_newline();
    }

    // TEST: Try syscall from kernel mode BEFORE enabling interrupts
    serial_out(84);  // T
    serial_out(69);  // E
    serial_out(83);  // S
    serial_out(84);  // T
    serial_out(58);  // :
    unsafe {
        asm!(
            "mov $$2, %rax
             mov $$42, %rdi
             int $$0x80",
            options(att_syntax)
        );
    }
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Enable interrupts
    sti();

    // Update display: "INT OK"
    vga_write_char(9, 9, 79, green);   // O
    vga_write_char(10, 9, 75, green);  // K

    serial_out(73);  // I
    serial_out(78);  // N
    serial_out(84);  // T
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Print syscall ready status
    serial_out(83);  // S
    serial_out(89);  // Y
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

// ============================================================
// TSS (Task State Segment) Management
// ============================================================

// TSS structure layout (64-bit mode, 104 bytes):
// Offset 0x00: Reserved (4 bytes)
// Offset 0x04: RSP0 (8 bytes) - Kernel stack for ring 0
// Offset 0x0C: RSP1 (8 bytes)
// Offset 0x14: RSP2 (8 bytes)
// Offset 0x1C: Reserved (8 bytes)
// Offset 0x24: IST1-IST7 (56 bytes)
// Offset 0x5C: Reserved (8 bytes)
// Offset 0x64: Reserved (2 bytes)
// Offset 0x66: IOPB offset (2 bytes)

fn tss_init() {
    let tss_addr = get_tss64_addr();

    // Clear TSS structure
    let mut i: i64 = 0;
    while i < TSS_SIZE {
        write_u64_addr(tss_addr + i, 0);
        i = i + 8;
    }

    // Set IOPB offset to beyond TSS (disable IO bitmap)
    // IOPB offset at 0x66, set to 104 (TSS_SIZE)
    write_u16_addr(tss_addr + 0x66, TSS_SIZE);

    serial_out(84);  // T
    serial_out(83);  // S
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(73);  // I
    serial_out(78);  // N
    serial_out(73);  // I
    serial_out(84);  // T
    serial_newline();
}

fn tss_set_kernel_stack(rsp0: i64) {
    let tss_addr = get_tss64_addr();
    // RSP0 is at offset 4 in TSS
    write_u64_addr(tss_addr + 4, rsp0 as u64);
}

fn tss_get_kernel_stack() -> i64 {
    let tss_addr = get_tss64_addr();
    read_u64_addr(tss_addr + 4) as i64
}

// Set up TSS descriptor in GDT at offset 0x28
// 64-bit TSS descriptor is 16 bytes (occupies 2 GDT entries)
fn gdt_setup_tss() {
    let tss_addr = get_tss64_addr();
    let base = tss_addr as u64;
    let limit = (TSS_SIZE - 1) as u64;

    // TSS Descriptor format (16 bytes for 64-bit):
    // Bytes 0-1: Limit [15:0]
    // Bytes 2-3: Base [15:0]
    // Byte 4: Base [23:16]
    // Byte 5: Type + Attributes (0x89 = Present + TSS Available)
    // Byte 6: Limit [19:16] + Flags
    // Byte 7: Base [31:24]
    // Bytes 8-11: Base [63:32]
    // Bytes 12-15: Reserved (0)

    // Get GDT base from assembly
    let gdt_base = get_gdt64_addr();
    let tss_desc_addr = gdt_base + GDT_TSS_OFFSET;

    // Low 8 bytes
    let base_low = base % 65536;
    let base_mid_low = (base / 65536) % 256;
    let base_mid_high = (base / 16777216) % 256;
    let limit_low = limit % 65536;
    let limit_high = (limit / 65536) % 16;

    // Build low descriptor (8 bytes)
    // Format: limit_low(16) | base_low(16) | base_mid_low(8) | type(8) | limit_high+flags(8) | base_mid_high(8)
    let low_qword: u64 = limit_low
        + (base_low * 65536)
        + (base_mid_low * 0x100000000)
        + (0x89 * 0x10000000000)          // Type: Present + TSS Available
        + (limit_high * 0x1000000000000)
        + (base_mid_high * 0x100000000000000);

    // High 8 bytes (base[63:32] + reserved)
    let base_high = base / 0x100000000;
    let high_qword: u64 = base_high;

    // Write TSS descriptor to GDT
    write_u64_addr(tss_desc_addr, low_qword);
    write_u64_addr(tss_desc_addr + 8, high_qword);

    serial_out(84);  // T
    serial_out(83);  // S
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(71);  // G
    serial_out(68);  // D
    serial_out(84);  // T
    serial_newline();
}

fn get_gdt64_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea gdt64(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}


fn get_tss64_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea tss64(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn read_tr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "str %ax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn tss_load_tr() {
    // Load Task Register with TSS selector (0x28)
    unsafe {
        asm!(
            "mov $$0x28, %ax; ltr %ax",
            options(nostack, att_syntax)
        );
    }

    serial_out(84);  // T
    serial_out(82);  // R
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

// ============================================================
// Process Management
// ============================================================

// Assembly function wrappers

// Placeholder - context switch now done in isr.asm
fn do_context_switch(old_rsp_ptr: i64, new_rsp: i64) {
    // Not used anymore - switch done via return value in isr_handler
}

// Initialize process stack with fake interrupt frame (KERNEL MODE)
// Returns the initial RSP to store in PCB
fn init_process_stack(stack_top: i64, entry: i64) -> i64 {
    let mut ptr = stack_top;

    // Push SS (kernel data segment)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x10);

    // Push RSP (process stack pointer after iretq)
    ptr = ptr - 8;
    write_u64_addr(ptr, (stack_top - 8) as u64);

    // Push RFLAGS (IF=1 to enable interrupts)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x202);

    // Push CS (kernel code segment)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x08);

    // Push RIP (entry point)
    ptr = ptr - 8;
    write_u64_addr(ptr, entry as u64);

    // Push error code (0)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0);

    // Push interrupt number (0)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0);

    // Push 15 GPRs (all zeros): rax, rbx, rcx, rdx, rsi, rdi, rbp, r8-r15
    // Note: isr_common pushes 15 GPRs, NOT 16!
    let mut i: i64 = 0;
    while i < 15 {
        ptr = ptr - 8;
        write_u64_addr(ptr, 0);
        i = i + 1;
    }

    // Push DS (kernel data segment)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x10);

    ptr
}

// Initialize process stack for USER MODE (ring 3)
// user_stack_top: top of user stack (ring 3)
// kernel_stack_top: top of kernel stack (ring 0, for interrupts/syscalls)
// entry: entry point in user space
// Returns: initial RSP pointing to kernel stack with fake frame
fn init_process_stack_user(user_stack_top: i64, kernel_stack_top: i64, entry: i64) -> i64 {
    // The interrupt frame goes on the kernel stack
    // When IRETQ executes, CPU will:
    // 1. Pop RIP, CS, RFLAGS, RSP, SS from kernel stack
    // 2. Load user segments and jump to entry point
    // 3. Switch to user stack (RSP from frame)

    // Debug: print stack setup info
    serial_out(83);  // S
    serial_out(84);  // T
    serial_out(75);  // K
    serial_out(58);  // :
    serial_out(32);  // space
    serial_out(75);  // K
    serial_out(61);  // =
    serial_hex32(kernel_stack_top as u64);
    serial_out(32);  // space
    serial_out(85);  // U
    serial_out(61);  // =
    serial_hex32(user_stack_top as u64);
    serial_out(32);  // space
    serial_out(69);  // E
    serial_out(61);  // =
    serial_hex32(entry as u64);
    serial_newline();

    let mut ptr = kernel_stack_top;

    // Push SS (user data segment with RPL=3)
    ptr = ptr - 8;
    write_u64_addr(ptr, USER_DS as u64);

    // Push RSP (user stack pointer)
    ptr = ptr - 8;
    write_u64_addr(ptr, (user_stack_top - 8) as u64);

    // Push RFLAGS (IF=1 to enable interrupts)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0x202);

    // Push CS (user code segment with RPL=3)
    ptr = ptr - 8;
    write_u64_addr(ptr, USER_CS as u64);

    // Push RIP (entry point)
    ptr = ptr - 8;
    write_u64_addr(ptr, entry as u64);

    // Push error code (0)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0);

    // Push interrupt number (0)
    ptr = ptr - 8;
    write_u64_addr(ptr, 0);

    // Push 15 GPRs (all zeros)
    let mut i: i64 = 0;
    while i < 15 {
        ptr = ptr - 8;
        write_u64_addr(ptr, 0);
        i = i + 1;
    }

    // Push DS (user data segment)
    ptr = ptr - 8;
    write_u64_addr(ptr, USER_DS as u64);

    // Debug: print final RSP
    serial_out(82);  // R
    serial_out(83);  // S
    serial_out(80);  // P
    serial_out(61);  // =
    serial_hex32(ptr as u64);
    serial_newline();

    ptr
}

fn asm_get_rsp() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "mov %rsp, %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn pcb_addr(pid: i64) -> i64 {
    PROC_TABLE_ADDR + (pid * PCB_SIZE)
}

fn pcb_get_pid(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_PID) as i64
}

fn pcb_get_state(pid: i64) -> ProcState {
    let addr = pcb_addr(pid);
    i64_to_proc_state(read_u64_addr(addr + PCB_STATE) as i64)
}

fn pcb_set_state(pid: i64, state: ProcState) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_STATE, proc_state_to_i64(state) as u64);
}

fn pcb_get_rsp(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_RSP) as i64
}

fn pcb_set_rsp(pid: i64, rsp: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_RSP, rsp as u64);
}

fn pcb_get_kstack(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_KSTACK_BASE) as i64
}

fn pcb_set_kstack(pid: i64, kstack: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_KSTACK_BASE, kstack as u64);
}

fn pcb_get_flags(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_FLAGS) as i64
}

fn pcb_set_flags(pid: i64, flags: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_FLAGS, flags as u64);
}

fn pcb_is_user_mode(pid: i64) -> bool {
    let flags = pcb_get_flags(pid);
    (flags % 2) == 1  // Check bit 0 using modulo (avoiding bitwise issues)
}

// ============================================================
// Extended PCB Functions (Phase 11)
// ============================================================

fn pcb_get_parent(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_PARENT_PID) as i64
}

fn pcb_set_parent(pid: i64, parent: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_PARENT_PID, parent as u64);
}

fn pcb_get_exit_code(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_EXIT_CODE) as i64
}

fn pcb_set_exit_code(pid: i64, code: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_EXIT_CODE, code as u64);
}

fn pcb_get_pending_sig(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_PENDING_SIG) as i64
}

fn pcb_set_pending_sig(pid: i64, sigs: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_PENDING_SIG, sigs as u64);
}

fn pcb_get_child_count(pid: i64) -> i64 {
    let addr = pcb_addr(pid);
    read_u64_addr(addr + PCB_CHILD_COUNT) as i64
}

fn pcb_set_child_count(pid: i64, count: i64) {
    let addr = pcb_addr(pid);
    write_u64_addr(addr + PCB_CHILD_COUNT, count as u64);
}

// Add a pending signal to process (using modulo arithmetic to avoid bitwise issues)
fn pcb_add_signal(pid: i64, signum: i64) {
    let mut result: i64 = 0;
    if signum > 0 && signum < SIG_MAX {
        let current = pcb_get_pending_sig(pid);
        // Set bit for signal using power of 2
        let sig_bit = signal_bit(signum);
        // Check if already set using modulo
        let already_set = (current / sig_bit) % 2;
        if already_set == 0 {
            result = current + sig_bit;
            pcb_set_pending_sig(pid, result);
        }
    }
}

// Check if signal is pending (using modulo arithmetic)
fn pcb_has_signal(pid: i64, signum: i64) -> bool {
    let mut result: bool = false;
    if signum > 0 && signum < SIG_MAX {
        let current = pcb_get_pending_sig(pid);
        let sig_bit = signal_bit(signum);
        let is_set = (current / sig_bit) % 2;
        result = is_set == 1;
    }
    result
}

// Clear a pending signal
fn pcb_clear_signal(pid: i64, signum: i64) {
    if signum > 0 && signum < SIG_MAX {
        let current = pcb_get_pending_sig(pid);
        let sig_bit = signal_bit(signum);
        let is_set = (current / sig_bit) % 2;
        if is_set == 1 {
            pcb_set_pending_sig(pid, current - sig_bit);
        }
    }
}

// Calculate 2^signum for signal bitmask
fn signal_bit(signum: i64) -> i64 {
    let mut result: i64 = 1;
    let mut i: i64 = 0;
    while i < signum {
        result = result * 2;
        i = i + 1;
    }
    result
}

// Check if process is valid (exists and not UNUSED)
fn proc_is_valid(pid: i64) -> bool {
    let mut result: bool = false;
    if pid >= 0 && pid < MAX_PROCS {
        let state = pcb_get_state(pid);
        result = state != ProcState::Unused;
    }
    result
}

fn get_current_pid() -> i64 {
    read_u64_addr(CURRENT_PID_ADDR) as i64
}

fn set_current_pid(pid: i64) {
    write_u64_addr(CURRENT_PID_ADDR, pid as u64);
}

fn get_num_procs() -> i64 {
    read_u64_addr(NUM_PROCS_ADDR) as i64
}

fn is_sched_enabled() -> bool {
    read_u64_addr(SCHED_ENABLED_ADDR) != 0
}

fn enable_scheduler() {
    write_u64_addr(SCHED_ENABLED_ADDR, 1);
}

// Create a new KERNEL MODE process (ring 0)
fn proc_create(entry: i64) -> i64 {
    let num_procs = get_num_procs();
    if num_procs >= MAX_PROCS {
        return -1;
    }

    let pid = num_procs;
    let pcb = pcb_addr(pid);

    // Calculate stack for this process (uses same stack for user/kernel in ring 0)
    let stack_base = PROC_STACK_BASE + (pid * PROC_STACK_SIZE);
    let stack_top = stack_base + PROC_STACK_SIZE;

    // Initialize the process stack with fake interrupt frame
    let initial_rsp = init_process_stack(stack_top, entry);

    // Fill PCB
    write_u64_addr(pcb + PCB_PID, pid as u64);
    write_u64_addr(pcb + PCB_STATE, proc_state_to_i64(ProcState::Ready) as u64);
    write_u64_addr(pcb + PCB_RSP, initial_rsp as u64);
    write_u64_addr(pcb + PCB_STACK_BASE, stack_base as u64);
    write_u64_addr(pcb + PCB_KSTACK_BASE, stack_base as u64);  // Same stack for kernel processes
    write_u64_addr(pcb + PCB_FLAGS, 0);  // Not user mode

    // Initialize extended PCB fields (Phase 11)
    write_u64_addr(pcb + PCB_PARENT_PID, 0);      // Kernel processes have no parent
    write_u64_addr(pcb + PCB_EXIT_CODE, 0);
    write_u64_addr(pcb + PCB_PENDING_SIG, 0);
    write_u64_addr(pcb + PCB_CHILD_COUNT, 0);

    // Increment process count
    write_u64_addr(NUM_PROCS_ADDR, (num_procs + 1) as u64);

    pid
}

// Create a new USER MODE process (ring 3)
fn proc_create_user(entry: i64) -> i64 {
    let num_procs = get_num_procs();
    if num_procs >= MAX_PROCS {
        return -1;
    }

    let pid = num_procs;
    let pcb = pcb_addr(pid);

    // Calculate user stack for this process
    let user_stack_base = PROC_STACK_BASE + (pid * PROC_STACK_SIZE);
    let user_stack_top = user_stack_base + PROC_STACK_SIZE;

    // Calculate kernel stack for this process (used during syscalls/interrupts)
    let kernel_stack_base = KSTACK_BASE + (pid * KSTACK_SIZE);
    let kernel_stack_top = kernel_stack_base + KSTACK_SIZE;

    // Initialize the process stack for user mode
    // The interrupt frame is on kernel stack, but RSP/SS point to user stack
    let initial_rsp = init_process_stack_user(user_stack_top, kernel_stack_top, entry);

    // Fill PCB
    write_u64_addr(pcb + PCB_PID, pid as u64);
    write_u64_addr(pcb + PCB_STATE, proc_state_to_i64(ProcState::Ready) as u64);
    write_u64_addr(pcb + PCB_RSP, initial_rsp as u64);
    write_u64_addr(pcb + PCB_STACK_BASE, user_stack_base as u64);
    write_u64_addr(pcb + PCB_KSTACK_BASE, kernel_stack_base as u64);
    write_u64_addr(pcb + PCB_FLAGS, PROC_FLAG_USER as u64);  // User mode flag

    // Initialize extended PCB fields (Phase 11)
    write_u64_addr(pcb + PCB_PARENT_PID, 0);      // Initial user processes have PID 0 as parent
    write_u64_addr(pcb + PCB_EXIT_CODE, 0);
    write_u64_addr(pcb + PCB_PENDING_SIG, 0);
    write_u64_addr(pcb + PCB_CHILD_COUNT, 0);

    // Increment process count
    write_u64_addr(NUM_PROCS_ADDR, (num_procs + 1) as u64);

    serial_out(85);  // U
    serial_out(83);  // S
    serial_out(82);  // R
    serial_out(58);  // :
    serial_out(48 + pid);
    serial_newline();

    pid
}

// ============================================================
// Scheduler
// ============================================================

// Returns the new RSP if switch needed, 0 if no switch
fn schedule_pick_next() -> i64 {
    if !is_sched_enabled() {
        return 0;
    }

    let num_procs = get_num_procs();
    if num_procs < 2 {
        return 0;
    }

    let current = get_current_pid();
    let current_state = pcb_get_state(current);

    // Find next ready process (round-robin)
    // Skip UNUSED, WAITING, ZOMBIE, and STOPPED processes
    let mut next = (current + 1) % num_procs;
    let mut checked: i64 = 0;

    while checked < num_procs {
        let state = pcb_get_state(next);
        if state == ProcState::Ready || state == ProcState::Running {
            break;
        }
        next = (next + 1) % num_procs;
        checked = checked + 1;
    }

    // No switch needed if same process
    if next == current {
        return 0;
    }

    // Update states - preserve WAITING/STOPPED/ZOMBIE states
    if current_state == ProcState::Running {
        pcb_set_state(current, ProcState::Ready);
    }
    // Don't change state if WAITING, ZOMBIE, or STOPPED
    pcb_set_state(next, ProcState::Running);

    // Save current RSP will be done by caller using frame_ptr
    // Return the new RSP
    let new_rsp = pcb_get_rsp(next);

    // Update TSS.RSP0 for the next process
    // This is critical for ring 3 -> ring 0 transitions
    if pcb_is_user_mode(next) {
        // Set kernel stack top as RSP0 in TSS
        let kstack_base = pcb_get_kstack(next);
        let kstack_top = kstack_base + KSTACK_SIZE;
        tss_set_kernel_stack(kstack_top);
    }

    // Update current PID
    set_current_pid(next);

    new_rsp
}

// ============================================================
// Test Processes
// ============================================================

// Syscall wrapper: print a character
fn sys_print(ch: i64) {
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_PRINT,
            in("rdi") ch,
            options(nostack, att_syntax)
        );
    }
}

// Syscall wrapper: get process ID
fn sys_getpid() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_GETPID,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: yield CPU
fn sys_yield() {
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_YIELD,
            options(nostack, att_syntax)
        );
    }
}

// Syscall wrapper: send message
fn sys_send(dst_pid: i64, data: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_SEND,
            in("rdi") dst_pid,
            in("rsi") data,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: receive message
fn sys_recv() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_RECV,
            in("rdi") 0,  // Don't need source PID
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: open file by index
fn sys_open(file_idx: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_OPEN,
            in("rdi") file_idx,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: read byte from file
fn sys_read(fd: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_READ,
            in("rdi") fd,
            in("rsi") 0,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: write byte to file
fn sys_write_file(fd: i64, byte_val: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_WRITE,
            in("rdi") fd,
            in("rsi") byte_val,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: close file
fn sys_close(fd: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_CLOSE,
            in("rdi") fd,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: get file size
fn sys_fstat(fd: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_FSTAT,
            in("rdi") fd,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: read keyboard character
fn sys_kb_read() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_KB_READ,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: check keyboard available
fn sys_kb_avail() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_KB_AVAIL,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: execute ELF binary
// name_lo: packed filename (first 8 chars)
// Returns: new PID on success, negative error on failure
fn sys_exec(name_lo: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_EXEC,
            in("rdi") name_lo,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: send signal to process (Phase 11)
fn sys_kill(pid: i64, signum: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_KILL,
            in("rdi") pid,
            in("rsi") signum,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: wait for child process (Phase 11)
fn sys_wait(pid: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_WAIT,
            in("rdi") pid,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: get parent PID (Phase 11)
fn sys_getppid() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_GETPPID,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: get/create shared memory (Phase 11)
fn sys_shmget(key: i64, size: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_SHMGET,
            in("rdi") key,
            in("rsi") size,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: attach to shared memory (Phase 11)
fn sys_shmat(shm_id: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_SHMAT,
            in("rdi") shm_id,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Syscall wrapper: detach from shared memory (Phase 11)
fn sys_shmdt(addr: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "int $$0x80",
            in("rax") SYS_SHMDT,
            in("rdi") addr,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

fn process_idle() {
    loop {
        hlt();
    }
}

// ============================================================
// Console Server Process (PID 3)
// VFS Server moved to genesis-runtime/src/fs/ (Phase 1)
// ============================================================

// Console Server: handles keyboard input and display
fn process_console_server() {
    // Print startup message
    sys_print(91);   // [
    sys_print(67);   // C
    sys_print(79);   // O
    sys_print(78);   // N
    sys_print(93);   // ]
    sys_print(32);   // space

    loop {
        // Console server mainly handles keyboard events
        // In this simplified version, just yield
        sys_yield();
    }
}

// Shell now in userspace (Phase 3) - see genesis-runtime/src/shell/

fn get_process_idle_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea process_idle(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// get_vfs_server_addr() removed - VFS Server now in userspace (Phase 1)

fn get_console_server_addr() -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "lea process_console_server(%rip), %rax",
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// get_process_shell_addr() removed - Shell now in userspace (Phase 3)

// ============================================================
// Process Initialization
// ============================================================

// Initialize kernel state: TSS, GDT, process table, RAMFS, etc.
// Creates PID 0 (idle) only. Init and services are created later.
fn init_kernel_state() {
    let white = vga_color(COLOR_WHITE, COLOR_BLACK);

    // Line 11: "PROC init..."
    vga_write_char(0, 11, 80, white);   // P
    vga_write_char(1, 11, 82, white);   // R
    vga_write_char(2, 11, 79, white);   // O
    vga_write_char(3, 11, 67, white);   // C
    vga_write_char(4, 11, 32, white);   // space
    vga_write_char(5, 11, 105, white);  // i
    vga_write_char(6, 11, 110, white);  // n
    vga_write_char(7, 11, 105, white);  // i
    vga_write_char(8, 11, 116, white);  // t

    // Initialize TSS (Task State Segment)
    tss_init();

    // Set up TSS descriptor in GDT
    gdt_setup_tss();

    // Load Task Register with TSS selector
    tss_load_tr();

    // Clear process table
    let mut i: i64 = 0;
    while i < MAX_PROCS * PCB_SIZE {
        write_u64_addr(PROC_TABLE_ADDR + i, 0);
        i = i + 8;
    }

    // Initialize scheduler state
    write_u64_addr(CURRENT_PID_ADDR, 0);
    write_u64_addr(NUM_PROCS_ADDR, 0);
    write_u64_addr(SCHED_ENABLED_ADDR, 0);

    // Initialize message queues for all potential processes
    let mut mq_i: i64 = 0;
    while mq_i < MAX_PROCS {
        mq_init(mq_i);
        mq_i = mq_i + 1;
    }

    // Initialize file descriptor tables for all processes
    let mut fd_i: i64 = 0;
    while fd_i < MAX_PROCS {
        fd_init(fd_i);
        fd_i = fd_i + 1;
    }

    // Initialize capability tables for all processes
    let mut cap_i: i64 = 0;
    while cap_i < MAX_PROCS {
        cap_init(cap_i);
        cap_i = cap_i + 1;
    }

    // Initialize RAM disk filesystem
    ramfs_init();

    // Initialize shared memory table (Phase 11)
    shm_init();

    // Initialize memory-mapped files table (Phase 13)
    mmap_init();

    // Initialize IRQ handler table (Pre-Runtime K2.7)
    irq_handler_table_init();

    // Create idle process (PID 0) - runs in KERNEL mode
    // Note: PID 0 starts as READY, not RUNNING
    // This prevents saving kernel stack as P0's RSP on first switch
    let idle_addr = get_process_idle_addr();
    let pid0 = proc_create(idle_addr);
    set_current_pid(pid0);

    // Initialize keyboard buffer
    kb_buffer_init();
}

// Initialize kernel-embedded services (temporary until extracted to userspace)
// Called AFTER init is loaded so Init gets PID 1
// VFS=PID 2, Console=PID 3, Shell=PID 4
fn init_kernel_services() {
    let green = vga_color(COLOR_GREEN, COLOR_BLACK);

    // VFS Server (PID 2) is loaded via exec_vfs() from RAMFS
    // after Init is loaded - see kmain()

    // Console and Shell are NOT created as userspace processes yet.
    // They will be extracted in Phase 2 (Console) and Phase 3 (Shell).
    // For now, VFS handles file operations and Init receives IPC messages.

    // ============================================================
    // Initialize Capabilities for each process
    // ============================================================

    // PID 0 (Idle): No special capabilities needed

    // PID 1 (Init): ROOT capability for service management
    cap_add(1, CAP_TYPE_ROOT, 0, CAP_RIGHT_ALL);

    // PID 2 (VFS Server): ROOT capability for file operations
    cap_add(2, CAP_TYPE_ROOT, 0, CAP_RIGHT_ALL);

    // PID 3 (Console Server): ROOT capability for VGA/keyboard operations
    cap_add(3, CAP_TYPE_ROOT, 0, CAP_RIGHT_ALL);

    // PID 4 (Shell Server): ROOT capability for commands (Phase 3)
    cap_add(4, CAP_TYPE_ROOT, 0, CAP_RIGHT_ALL);

    // Debug: Print capability initialization status
    serial_out(67);  // C
    serial_out(65);  // A
    serial_out(80);  // P
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Enable scheduler
    enable_scheduler();

    // Update display: "PROC OK"
    vga_write_char(10, 11, 79, green);  // O
    vga_write_char(11, 11, 75, green);  // K

    serial_out(80);  // P
    serial_out(82);  // R
    serial_out(79);  // O
    serial_out(67);  // C
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    let num = get_num_procs();
    serial_out(78);  // N
    serial_out(61);  // =
    serial_out(48 + num);  // number
    serial_newline();

    serial_out(85);  // U
    serial_out(83);  // S
    serial_out(69);  // E
    serial_out(82);  // R
    serial_out(32);  // space
    serial_out(77);  // M
    serial_out(79);  // O
    serial_out(68);  // D
    serial_out(69);  // E
    serial_newline();
}

// ============================================================
// Network Syscall Implementations (Phase 13: Network Stack)
// ============================================================

// Memory map for network stack:
// 0xD00000 - E1000 TX Descriptors (512B)
// 0xD00200 - E1000 TX Buffers (64KB)
// 0xD10200 - E1000 RX Descriptors (512B)
// 0xD10400 - E1000 RX Buffers (64KB)
// 0xD20400 - E1000 State (256B)
// 0xD20500 - ARP Cache (3KB)
// 0xD21000 - Network Config (4KB)
// 0xD22000 - UDP Socket Table (8KB)
// 0xD24000 - TCP Socket Table + Buffers (112KB)

// Network state address
const NET_INITIALIZED_ADDR: i64 = 0xD3C000;

// Check if network is initialized
fn net_is_ready() -> i64 {
    read_byte_addr(NET_INITIALIZED_ADDR)
}

// SYS_NET_SOCKET - Create a network socket
// arg1: domain (2 = AF_INET)
// arg2: type (1 = STREAM/TCP, 2 = DGRAM/UDP)
// arg3: protocol (0 = default)
// Returns: socket fd, or negative error
fn syscall_net_socket(domain: i64, sock_type: i64, protocol: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    // Handle simplified call where arg1 is sock_type (1=TCP, 2=UDP)
    // In that case, domain comes as the sock_type and sock_type/protocol are 0
    let actual_domain: i64 = if sock_type == 0 && protocol == 0 {
        2  // AF_INET
    } else {
        domain
    };
    let actual_type: i64 = if sock_type == 0 && protocol == 0 {
        domain  // First arg was actually the socket type
    } else {
        sock_type
    };
    net::net_socket_create(actual_domain, actual_type, 0)
}

// SYS_NET_BIND - Bind socket to address
// arg1: socket fd
// arg2: IP address (packed)
// arg3: port number
fn syscall_net_bind(fd: i64, ip: i64, port: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    net::net_socket_bind(fd, ip, port)
}

// SYS_NET_LISTEN - Listen for connections
// arg1: socket fd
// arg2: backlog
fn syscall_net_listen(fd: i64, backlog: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    net::net_socket_listen(fd, backlog)
}

// SYS_NET_ACCEPT - Accept connection
// arg1: socket fd
// Returns: new socket fd, or negative error
fn syscall_net_accept(fd: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    net::net_socket_accept(fd)
}

// SYS_NET_CONNECT - Connect to remote
// arg1: socket fd
// arg2: remote IP
// arg3: remote port
fn syscall_net_connect(fd: i64, ip: i64, port: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    // Direct connect path - call tcp.gl's tcp_socket_connect which sends SYN
    // Socket table at 0xD3A000, desc size 32, type at offset 0, proto_id at offset 4
    let desc_addr = 0xD3A000 + (fd * 32);
    let sock_type = read_byte_addr(desc_addr);
    let proto_id = read_u32_at(desc_addr, 4) as i64;

    if sock_type == 0 {
        return -1;  // Invalid socket
    }

    if sock_type == 1 {
        // TCP (SOCK_STREAM) - call tcp.gl directly
        net::net_tcp_connect(proto_id, ip, port)
    } else if sock_type == 2 {
        // UDP (SOCK_DGRAM)
        net::net_udp_connect(proto_id, ip, port)
    } else {
        -1
    }
}

// SYS_NET_SEND - Send data
// arg1: socket fd
// arg2: buffer address
// arg3: length
fn syscall_net_send(fd: i64, buffer: i64, length: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    // Direct send path - bypass socket.gl's incomplete send()
    // Socket table at 0xD3A000, desc size 32, type at offset 0, proto_id at offset 4
    let desc_addr = 0xD3A000 + (fd * 32);
    let sock_type = read_byte_addr(desc_addr);
    let proto_id = read_u32_at(desc_addr, 4) as i64;

    if sock_type == 0 {
        return -1;  // Invalid socket
    }

    if sock_type == 1 {
        // TCP (SOCK_STREAM)
        net::net_tcp_send(proto_id, buffer, length)
    } else if sock_type == 2 {
        // UDP (SOCK_DGRAM)
        net::net_udp_send(proto_id, buffer, length)
    } else {
        -1  // Unsupported type
    }
}

// SYS_NET_RECV - Receive data
// arg1: socket fd
// arg2: buffer address
// arg3: max length
fn syscall_net_recv(fd: i64, buffer: i64, max_len: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    net::net_socket_recv(fd, buffer, max_len)
}

// SYS_NET_CLOSE - Close socket
// arg1: socket fd
fn syscall_net_close(fd: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    net::net_socket_close_fd(fd)
}

// SYS_NET_CONFIG - Configure network (static IP)
// arg1: IP address
// arg2: subnet mask
// arg3: gateway
fn syscall_net_config(ip: i64, mask: i64, gateway: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    // Configure the network stack with static IP
    // Use gateway as DNS server by default (common setup)
    net::net_stack_configure(ip, mask, gateway, gateway)
}

// SYS_NET_STATUS - Get network status
// arg1: what to query (0=initialized, 1=link, 2=ip, 3=mask, 4=gateway, 5=dns)
fn syscall_net_status(query: i64) -> i64 {
    match query {
        0 => net_is_ready(),
        1 => {
            // Link status - read from E1000 state
            let e1000_state = 0xD20400;
            read_byte_addr(e1000_state + 1)  // E1000_STATE_LINK_UP
        }
        2 => {
            // IP address
            let net_config = 0xD21000;
            read_u32_at(net_config, 0) as i64
        }
        3 => {
            // Subnet mask
            let net_config = 0xD21000;
            read_u32_at(net_config, 4) as i64
        }
        4 => {
            // Gateway
            let net_config = 0xD21000;
            read_u32_at(net_config, 8) as i64
        }
        5 => {
            // DNS
            let net_config = 0xD21000;
            read_u32_at(net_config, 12) as i64
        }
        _ => -1,
    }
}

// SYS_NET_GETIP - Get current IP address
fn syscall_net_getip() -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    let net_config: i64 = 0xD21000;
    read_u32_at(net_config, 0) as i64
}

// SYS_NET_GETMAC - Get MAC address
// arg1: 0 = low 4 bytes, 1 = high 2 bytes
fn syscall_net_getmac(idx: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    if idx == 0 {
        net::net_get_mac_lo()
    } else {
        net::net_get_mac_hi()
    }
}

// SYS_NET_RESOLVE - DNS resolve (placeholder)
// arg1: hostname buffer address
fn syscall_net_resolve(hostname: i64) -> i64 {
    // DNS resolution not implemented yet
    -1
}

// SYS_NET_PING - Send ICMP ping
// arg1: target IP
// arg2: timeout in ticks
fn syscall_net_ping(target_ip: i64, timeout: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    // Would call ping(target_ip, timeout)
    // Returns RTT in ticks, or -1 on timeout
    return -1;
}

// SYS_NET_ARP - ARP lookup
// arg1: IP address to lookup
// arg2: buffer for MAC address (6 bytes)
fn syscall_net_arp(ip: i64, mac_out: i64) -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    // Would call arp_lookup(ip, mac_out)
    return 0;
}

// SYS_NET_DHCP - Start DHCP discovery
fn syscall_net_dhcp() -> i64 {
    if net_is_ready() == 0 {
        return -1;
    }
    // Would call dhcp_start()
    return 0;
}

// SYS_NET_POLL - Poll network for packets
fn syscall_net_poll() -> i64 {
    if net_is_ready() == 0 {
        return 0;
    }
    // Would call net_stack_poll()
    // Returns number of packets processed
    return 0;
}

// ============================================================
// TLS 1.2 Implementation
// ============================================================

// TLS Memory Layout (using heap area 0x4000000 - 0x4100000 = 1MB for TLS)
const TLS_STATE_BASE: i64 = 0x4000000;        // TLS state base
const TLS_MAX_CONNECTIONS: i64 = 8;           // Max concurrent TLS connections
const TLS_CONN_SIZE: i64 = 8192;              // 8KB per connection state

// TLS Connection State Offsets
const TLS_OFF_SOCKET: i64 = 0;                // Socket FD (8 bytes)
const TLS_OFF_STATE: i64 = 8;                 // Handshake state (1 byte)
const TLS_OFF_CIPHER: i64 = 9;                // Cipher suite (2 bytes)
const TLS_OFF_CLIENT_RANDOM: i64 = 16;        // Client random (32 bytes)
const TLS_OFF_SERVER_RANDOM: i64 = 48;        // Server random (32 bytes)
const TLS_OFF_MASTER_SECRET: i64 = 80;        // Master secret (48 bytes)
const TLS_OFF_CLIENT_KEY: i64 = 128;          // Client write key (16 bytes)
const TLS_OFF_SERVER_KEY: i64 = 144;          // Server write key (16 bytes)
const TLS_OFF_CLIENT_IV: i64 = 160;           // Client write IV (4 bytes)
const TLS_OFF_SERVER_IV: i64 = 164;           // Server write IV (4 bytes)
const TLS_OFF_CLIENT_SEQ: i64 = 168;          // Client sequence number (8 bytes)
const TLS_OFF_SERVER_SEQ: i64 = 176;          // Server sequence number (8 bytes)
const TLS_OFF_HOSTNAME: i64 = 192;            // Server hostname (128 bytes)
const TLS_OFF_HOSTNAME_LEN: i64 = 320;        // Hostname length (2 bytes)
const TLS_OFF_HANDSHAKE_HASH: i64 = 384;      // Handshake hash state (128 bytes)
const TLS_OFF_TX_BUF: i64 = 512;              // TX buffer (2048 bytes)
const TLS_OFF_RX_BUF: i64 = 2560;             // RX buffer (4096 bytes)
const TLS_OFF_RX_LEN: i64 = 6656;             // RX buffer length (4 bytes)
const TLS_OFF_AES_KEYS: i64 = 6660;           // AES expanded keys (480 bytes)
const TLS_OFF_PREMASTER: i64 = 7140;          // Premaster secret (48 bytes)
const TLS_OFF_CERT_ADDR: i64 = 7200;          // Certificate data address (8 bytes)
const TLS_OFF_CERT_LEN: i64 = 7208;           // Certificate data length (8 bytes)

// TLS States
const TLS_STATE_NONE: i64 = 0;
const TLS_STATE_HANDSHAKE: i64 = 1;
const TLS_STATE_CONNECTED: i64 = 2;
const TLS_STATE_ERROR: i64 = 3;

// TLS Versions
const TLS_VERSION_12: i64 = 0x0303;

// TLS Content Types
const TLS_CONTENT_CHANGE_CIPHER: i64 = 20;
const TLS_CONTENT_ALERT: i64 = 21;
const TLS_CONTENT_HANDSHAKE: i64 = 22;
const TLS_CONTENT_APPLICATION: i64 = 23;

// TLS Handshake Types
const TLS_HS_CLIENT_HELLO: i64 = 1;
const TLS_HS_SERVER_HELLO: i64 = 2;
const TLS_HS_CERTIFICATE: i64 = 11;
const TLS_HS_SERVER_KEY_EXCHANGE: i64 = 12;
const TLS_HS_SERVER_HELLO_DONE: i64 = 14;
const TLS_HS_CLIENT_KEY_EXCHANGE: i64 = 16;
const TLS_HS_FINISHED: i64 = 20;

// Cipher Suites
const TLS_RSA_WITH_AES_128_GCM_SHA256: i64 = 0x009C;

// ============================================================
// SHA-256 Implementation
// ============================================================

// SHA-256 initial hash values
const SHA256_H0: u64 = 0x6a09e667;
const SHA256_H1: u64 = 0xbb67ae85;
const SHA256_H2: u64 = 0x3c6ef372;
const SHA256_H3: u64 = 0xa54ff53a;
const SHA256_H4: u64 = 0x510e527f;
const SHA256_H5: u64 = 0x9b05688c;
const SHA256_H6: u64 = 0x1f83d9ab;
const SHA256_H7: u64 = 0x5be0cd19;

// SHA-256 round constants (first 32)
fn sha256_k(i: i64) -> u64 {
    // First 32 round constants (there are 64 total)
    if i == 0 { return 0x428a2f98; }
    if i == 1 { return 0x71374491; }
    if i == 2 { return 0xb5c0fbcf; }
    if i == 3 { return 0xe9b5dba5; }
    if i == 4 { return 0x3956c25b; }
    if i == 5 { return 0x59f111f1; }
    if i == 6 { return 0x923f82a4; }
    if i == 7 { return 0xab1c5ed5; }
    if i == 8 { return 0xd807aa98; }
    if i == 9 { return 0x12835b01; }
    if i == 10 { return 0x243185be; }
    if i == 11 { return 0x550c7dc3; }
    if i == 12 { return 0x72be5d74; }
    if i == 13 { return 0x80deb1fe; }
    if i == 14 { return 0x9bdc06a7; }
    if i == 15 { return 0xc19bf174; }
    if i == 16 { return 0xe49b69c1; }
    if i == 17 { return 0xefbe4786; }
    if i == 18 { return 0x0fc19dc6; }
    if i == 19 { return 0x240ca1cc; }
    if i == 20 { return 0x2de92c6f; }
    if i == 21 { return 0x4a7484aa; }
    if i == 22 { return 0x5cb0a9dc; }
    if i == 23 { return 0x76f988da; }
    if i == 24 { return 0x983e5152; }
    if i == 25 { return 0xa831c66d; }
    if i == 26 { return 0xb00327c8; }
    if i == 27 { return 0xbf597fc7; }
    if i == 28 { return 0xc6e00bf3; }
    if i == 29 { return 0xd5a79147; }
    if i == 30 { return 0x06ca6351; }
    if i == 31 { return 0x14292967; }
    if i == 32 { return 0x27b70a85; }
    if i == 33 { return 0x2e1b2138; }
    if i == 34 { return 0x4d2c6dfc; }
    if i == 35 { return 0x53380d13; }
    if i == 36 { return 0x650a7354; }
    if i == 37 { return 0x766a0abb; }
    if i == 38 { return 0x81c2c92e; }
    if i == 39 { return 0x92722c85; }
    if i == 40 { return 0xa2bfe8a1; }
    if i == 41 { return 0xa81a664b; }
    if i == 42 { return 0xc24b8b70; }
    if i == 43 { return 0xc76c51a3; }
    if i == 44 { return 0xd192e819; }
    if i == 45 { return 0xd6990624; }
    if i == 46 { return 0xf40e3585; }
    if i == 47 { return 0x106aa070; }
    if i == 48 { return 0x19a4c116; }
    if i == 49 { return 0x1e376c08; }
    if i == 50 { return 0x2748774c; }
    if i == 51 { return 0x34b0bcb5; }
    if i == 52 { return 0x391c0cb3; }
    if i == 53 { return 0x4ed8aa4a; }
    if i == 54 { return 0x5b9cca4f; }
    if i == 55 { return 0x682e6ff3; }
    if i == 56 { return 0x748f82ee; }
    if i == 57 { return 0x78a5636f; }
    if i == 58 { return 0x84c87814; }
    if i == 59 { return 0x8cc70208; }
    if i == 60 { return 0x90befffa; }
    if i == 61 { return 0xa4506ceb; }
    if i == 62 { return 0xbef9a3f7; }
    if i == 63 { return 0xc67178f2; }
    0
}

// Right rotate 32-bit value
fn sha256_rotr(x: u64, n: i64) -> u64 {
    let x32 = bit_and(x, 0xFFFFFFFF);
    let shifted_right = x32 / shl_u64(1, n as u64);
    let shifted_left = shl_u64(x32, (32 - n) as u64);
    bit_and(bit_or(shifted_right, shifted_left), 0xFFFFFFFF)
}

// SHA-256 compression function Sigma0
fn sha256_sigma0(x: u64) -> u64 {
    let r2 = sha256_rotr(x, 2);
    let r13 = sha256_rotr(x, 13);
    let r22 = sha256_rotr(x, 22);
    bit_and(bit_xor(bit_xor(r2, r13), r22), 0xFFFFFFFF)
}

// SHA-256 compression function Sigma1
fn sha256_sigma1(x: u64) -> u64 {
    let r6 = sha256_rotr(x, 6);
    let r11 = sha256_rotr(x, 11);
    let r25 = sha256_rotr(x, 25);
    bit_and(bit_xor(bit_xor(r6, r11), r25), 0xFFFFFFFF)
}

// SHA-256 message schedule sigma0
fn sha256_sig0(x: u64) -> u64 {
    let r7 = sha256_rotr(x, 7);
    let r18 = sha256_rotr(x, 18);
    let s3 = bit_and(x, 0xFFFFFFFF) / 8;  // x >> 3
    bit_and(bit_xor(bit_xor(r7, r18), s3), 0xFFFFFFFF)
}

// SHA-256 message schedule sigma1
fn sha256_sig1(x: u64) -> u64 {
    let r17 = sha256_rotr(x, 17);
    let r19 = sha256_rotr(x, 19);
    let s10 = bit_and(x, 0xFFFFFFFF) / 1024;  // x >> 10
    bit_and(bit_xor(bit_xor(r17, r19), s10), 0xFFFFFFFF)
}

// SHA-256 Ch function
fn sha256_ch(x: u64, y: u64, z: u64) -> u64 {
    bit_and(bit_xor(bit_and(x, y), bit_and(bit_not(x), z)), 0xFFFFFFFF)
}

// SHA-256 Maj function
fn sha256_maj(x: u64, y: u64, z: u64) -> u64 {
    bit_and(bit_xor(bit_xor(bit_and(x, y), bit_and(x, z)), bit_and(y, z)), 0xFFFFFFFF)
}

// SHA-256 hash a single 64-byte block
// state_addr: address of 32-byte hash state (8 x u32)
// block_addr: address of 64-byte message block
fn sha256_process_block(state_addr: i64, block_addr: i64) {
    // Message schedule W[0..63]
    let w_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE;  // Temp buffer

    // Initialize W[0..15] from block (big-endian)
    let mut i: i64 = 0;
    while i < 16 {
        let b0 = read_byte_addr(block_addr + i * 4) as u64;
        let b1 = read_byte_addr(block_addr + i * 4 + 1) as u64;
        let b2 = read_byte_addr(block_addr + i * 4 + 2) as u64;
        let b3 = read_byte_addr(block_addr + i * 4 + 3) as u64;
        let w = bit_or(bit_or(bit_or(shl_u64(b0, 24), shl_u64(b1, 16)), shl_u64(b2, 8)), b3);
        write_u64_addr(w_addr + i * 8, w);
        i = i + 1;
    }

    // Extend W[16..63]
    while i < 64 {
        let w2 = read_u64_addr(w_addr + (i - 2) * 8);
        let w7 = read_u64_addr(w_addr + (i - 7) * 8);
        let w15 = read_u64_addr(w_addr + (i - 15) * 8);
        let w16 = read_u64_addr(w_addr + (i - 16) * 8);
        let s1 = sha256_sig1(w2);
        let s0 = sha256_sig0(w15);
        let w = bit_and(s1 + w7 + s0 + w16, 0xFFFFFFFF);
        write_u64_addr(w_addr + i * 8, w);
        i = i + 1;
    }

    // Initialize working variables
    let mut a = read_u64_addr(state_addr) as u64;
    let mut b = read_u64_addr(state_addr + 8) as u64;
    let mut c = read_u64_addr(state_addr + 16) as u64;
    let mut d = read_u64_addr(state_addr + 24) as u64;
    let mut e = read_u64_addr(state_addr + 32) as u64;
    let mut f = read_u64_addr(state_addr + 40) as u64;
    let mut g = read_u64_addr(state_addr + 48) as u64;
    let mut h = read_u64_addr(state_addr + 56) as u64;

    // 64 rounds
    i = 0;
    while i < 64 {
        let wi = read_u64_addr(w_addr + i * 8);
        let ki = sha256_k(i);
        let s1 = sha256_sigma1(e);
        let ch = sha256_ch(e, f, g);
        let t1 = bit_and(h + s1 + ch + ki + wi, 0xFFFFFFFF);
        let s0 = sha256_sigma0(a);
        let maj = sha256_maj(a, b, c);
        let t2 = bit_and(s0 + maj, 0xFFFFFFFF);

        h = g;
        g = f;
        f = e;
        e = bit_and(d + t1, 0xFFFFFFFF);
        d = c;
        c = b;
        b = a;
        a = bit_and(t1 + t2, 0xFFFFFFFF);

        i = i + 1;
    }

    // Add to hash state
    write_u64_addr(state_addr, bit_and(read_u64_addr(state_addr) as u64 + a, 0xFFFFFFFF));
    write_u64_addr(state_addr + 8, bit_and(read_u64_addr(state_addr + 8) as u64 + b, 0xFFFFFFFF));
    write_u64_addr(state_addr + 16, bit_and(read_u64_addr(state_addr + 16) as u64 + c, 0xFFFFFFFF));
    write_u64_addr(state_addr + 24, bit_and(read_u64_addr(state_addr + 24) as u64 + d, 0xFFFFFFFF));
    write_u64_addr(state_addr + 32, bit_and(read_u64_addr(state_addr + 32) as u64 + e, 0xFFFFFFFF));
    write_u64_addr(state_addr + 40, bit_and(read_u64_addr(state_addr + 40) as u64 + f, 0xFFFFFFFF));
    write_u64_addr(state_addr + 48, bit_and(read_u64_addr(state_addr + 48) as u64 + g, 0xFFFFFFFF));
    write_u64_addr(state_addr + 56, bit_and(read_u64_addr(state_addr + 56) as u64 + h, 0xFFFFFFFF));
}

// SHA-256 hash complete message
// data_addr: address of input data
// data_len: length of input data
// hash_addr: address to store 32-byte hash output
fn sha256_hash(data_addr: i64, data_len: i64, hash_addr: i64) {
    // Initialize state
    let state_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE + 512;
    write_u64_addr(state_addr, SHA256_H0);
    write_u64_addr(state_addr + 8, SHA256_H1);
    write_u64_addr(state_addr + 16, SHA256_H2);
    write_u64_addr(state_addr + 24, SHA256_H3);
    write_u64_addr(state_addr + 32, SHA256_H4);
    write_u64_addr(state_addr + 40, SHA256_H5);
    write_u64_addr(state_addr + 48, SHA256_H6);
    write_u64_addr(state_addr + 56, SHA256_H7);

    // Process complete 64-byte blocks
    let block_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE + 1024;
    let mut offset: i64 = 0;
    while offset + 64 <= data_len {
        // Copy block
        let mut i: i64 = 0;
        while i < 64 {
            write_byte_addr(block_addr + i, read_byte_addr(data_addr + offset + i));
            i = i + 1;
        }
        sha256_process_block(state_addr, block_addr);
        offset = offset + 64;
    }

    // Final block with padding
    let remaining = data_len - offset;
    let mut i: i64 = 0;
    while i < remaining {
        write_byte_addr(block_addr + i, read_byte_addr(data_addr + offset + i));
        i = i + 1;
    }

    // Add 0x80 padding byte
    write_byte_addr(block_addr + remaining, 0x80);

    // If not enough room for length, process this block and start new one
    let mut start_pad: i64 = remaining + 1;
    i = remaining + 1;
    if remaining >= 56 {
        while i < 64 {
            write_byte_addr(block_addr + i, 0);
            i = i + 1;
        }
        sha256_process_block(state_addr, block_addr);
        start_pad = 0;
    }

    // Pad with zeros until 56 bytes
    i = start_pad;
    while i < 56 {
        write_byte_addr(block_addr + i, 0);
        i = i + 1;
    }

    // Append message length in bits (big-endian 64-bit)
    let bit_len = (data_len * 8) as u64;
    write_byte_addr(block_addr + 56, (bit_len / shl_u64(1, 56)) as i64);
    write_byte_addr(block_addr + 57, (bit_and(bit_len, shl_u64(0xFF, 48)) / shl_u64(1, 48)) as i64);
    write_byte_addr(block_addr + 58, (bit_and(bit_len, shl_u64(0xFF, 40)) / shl_u64(1, 40)) as i64);
    write_byte_addr(block_addr + 59, (bit_and(bit_len, shl_u64(0xFF, 32)) / shl_u64(1, 32)) as i64);
    write_byte_addr(block_addr + 60, (bit_and(bit_len, shl_u64(0xFF, 24)) / shl_u64(1, 24)) as i64);
    write_byte_addr(block_addr + 61, (bit_and(bit_len, shl_u64(0xFF, 16)) / shl_u64(1, 16)) as i64);
    write_byte_addr(block_addr + 62, (bit_and(bit_len, shl_u64(0xFF, 8)) / shl_u64(1, 8)) as i64);
    write_byte_addr(block_addr + 63, bit_and(bit_len, 0xFF) as i64);

    sha256_process_block(state_addr, block_addr);

    // Output hash (big-endian)
    i = 0;
    while i < 8 {
        let h = read_u64_addr(state_addr + i * 8) as u64;
        write_byte_addr(hash_addr + i * 4, (bit_and(h, shl_u64(0xFF, 24)) / shl_u64(1, 24)) as i64);
        write_byte_addr(hash_addr + i * 4 + 1, (bit_and(h, shl_u64(0xFF, 16)) / shl_u64(1, 16)) as i64);
        write_byte_addr(hash_addr + i * 4 + 2, (bit_and(h, shl_u64(0xFF, 8)) / shl_u64(1, 8)) as i64);
        write_byte_addr(hash_addr + i * 4 + 3, bit_and(h, 0xFF) as i64);
        i = i + 1;
    }
}

// ============================================================
// HMAC-SHA256 Implementation
// ============================================================

// HMAC-SHA256: keyed hash
// key_addr: address of key
// key_len: length of key (max 64 bytes recommended)
// data_addr: address of data
// data_len: length of data
// out_addr: address for 32-byte output
fn hmac_sha256(key_addr: i64, key_len: i64, data_addr: i64, data_len: i64, out_addr: i64) {
    let ipad_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE + 2048;
    let opad_addr = ipad_addr + 64;
    let temp_addr = opad_addr + 64;

    // If key > 64 bytes, hash it first
    let mut actual_key_addr = key_addr;
    let mut actual_key_len = key_len;
    if key_len > 64 {
        actual_key_len = 32;
        actual_key_addr = temp_addr;
        sha256_hash(key_addr, key_len, temp_addr);
    }

    // Initialize ipad and opad
    let mut i: i64 = 0;
    while i < 64 {
        if i < actual_key_len {
            let k = read_byte_addr(actual_key_addr + i);
            write_byte_addr(ipad_addr + i, bit_xor(k as u64, 0x36) as i64);
            write_byte_addr(opad_addr + i, bit_xor(k as u64, 0x5C) as i64);
        } else {
            write_byte_addr(ipad_addr + i, 0x36);
            write_byte_addr(opad_addr + i, 0x5C);
        }
        i = i + 1;
    }

    // Inner hash: H(ipad || message)
    // Build ipad || message in temp buffer
    let inner_addr = temp_addr + 64;
    i = 0;
    while i < 64 {
        write_byte_addr(inner_addr + i, read_byte_addr(ipad_addr + i));
        i = i + 1;
    }
    i = 0;
    while i < data_len {
        write_byte_addr(inner_addr + 64 + i, read_byte_addr(data_addr + i));
        i = i + 1;
    }
    let inner_hash_addr = temp_addr + 2048;
    sha256_hash(inner_addr, 64 + data_len, inner_hash_addr);

    // Outer hash: H(opad || inner_hash)
    let outer_addr = inner_addr;
    i = 0;
    while i < 64 {
        write_byte_addr(outer_addr + i, read_byte_addr(opad_addr + i));
        i = i + 1;
    }
    i = 0;
    while i < 32 {
        write_byte_addr(outer_addr + 64 + i, read_byte_addr(inner_hash_addr + i));
        i = i + 1;
    }
    sha256_hash(outer_addr, 96, out_addr);
}

// ============================================================
// TLS PRF (Pseudo-Random Function)
// ============================================================

// PRF for TLS 1.2: P_SHA256
// secret_addr: address of secret
// secret_len: length of secret
// label_addr: address of label string
// label_len: length of label
// seed_addr: address of seed
// seed_len: length of seed
// out_addr: address for output
// out_len: desired output length
fn tls_prf(secret_addr: i64, secret_len: i64, label_addr: i64, label_len: i64,
           seed_addr: i64, seed_len: i64, out_addr: i64, out_len: i64) {
    // Build label + seed
    let ls_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE + 4096;
    let mut i: i64 = 0;
    while i < label_len {
        write_byte_addr(ls_addr + i, read_byte_addr(label_addr + i));
        i = i + 1;
    }
    i = 0;
    while i < seed_len {
        write_byte_addr(ls_addr + label_len + i, read_byte_addr(seed_addr + i));
        i = i + 1;
    }
    let ls_len = label_len + seed_len;

    // A(0) = seed (label + seed)
    // A(i) = HMAC(secret, A(i-1))
    let a_addr = ls_addr + 512;
    i = 0;
    while i < ls_len {
        write_byte_addr(a_addr + i, read_byte_addr(ls_addr + i));
        i = i + 1;
    }
    let mut a_len = ls_len;

    // P(secret, seed) = HMAC(secret, A(1) + seed) + HMAC(secret, A(2) + seed) + ...
    let p_addr = a_addr + 256;
    let mut out_pos: i64 = 0;

    while out_pos < out_len {
        // A(i) = HMAC(secret, A(i-1))
        let new_a_addr = p_addr + 256;
        hmac_sha256(secret_addr, secret_len, a_addr, a_len, new_a_addr);

        // Copy new A back
        i = 0;
        while i < 32 {
            write_byte_addr(a_addr + i, read_byte_addr(new_a_addr + i));
            i = i + 1;
        }
        a_len = 32;

        // Build A(i) + seed for HMAC
        let as_addr = new_a_addr + 64;
        i = 0;
        while i < 32 {
            write_byte_addr(as_addr + i, read_byte_addr(a_addr + i));
            i = i + 1;
        }
        i = 0;
        while i < ls_len {
            write_byte_addr(as_addr + 32 + i, read_byte_addr(ls_addr + i));
            i = i + 1;
        }

        // P_i = HMAC(secret, A(i) + seed)
        let pi_addr = as_addr + 512;
        hmac_sha256(secret_addr, secret_len, as_addr, 32 + ls_len, pi_addr);

        // Copy to output
        i = 0;
        while i < 32 && out_pos < out_len {
            write_byte_addr(out_addr + out_pos, read_byte_addr(pi_addr + i));
            out_pos = out_pos + 1;
            i = i + 1;
        }
    }
}

// ============================================================
// TLS Connection Management
// ============================================================

// Find or allocate TLS connection for socket
fn tls_get_conn(socket: i64) -> i64 {
    let mut i: i64 = 0;
    while i < TLS_MAX_CONNECTIONS {
        let conn_addr = TLS_STATE_BASE + i * TLS_CONN_SIZE;
        let conn_socket = read_u64_addr(conn_addr + TLS_OFF_SOCKET) as i64;
        if conn_socket == socket {
            return conn_addr;
        }
        i = i + 1;
    }
    return -1;  // Not found
}

// Allocate new TLS connection
fn tls_alloc_conn(socket: i64) -> i64 {
    let mut i: i64 = 0;
    while i < TLS_MAX_CONNECTIONS {
        let conn_addr = TLS_STATE_BASE + i * TLS_CONN_SIZE;
        let conn_socket = read_u64_addr(conn_addr + TLS_OFF_SOCKET) as i64;
        if conn_socket == 0 {
            // Clear connection state
            let mut j: i64 = 0;
            while j < TLS_CONN_SIZE {
                write_byte_addr(conn_addr + j, 0);
                j = j + 1;
            }
            write_u64_addr(conn_addr + TLS_OFF_SOCKET, socket as u64);
            return conn_addr;
        }
        i = i + 1;
    }
    return -1;  // No free slots
}

// Free TLS connection
fn tls_free_conn(conn_addr: i64) {
    write_u64_addr(conn_addr + TLS_OFF_SOCKET, 0);
}

// ============================================================
// AES-128 Implementation
// ============================================================

// AES S-box lookup table (stored as function due to no static arrays)
fn aes_sbox(i: i64) -> i64 {
    // S-box values in groups of 16
    if i < 16 {
        if i == 0 { return 0x63; } if i == 1 { return 0x7c; } if i == 2 { return 0x77; } if i == 3 { return 0x7b; }
        if i == 4 { return 0xf2; } if i == 5 { return 0x6b; } if i == 6 { return 0x6f; } if i == 7 { return 0xc5; }
        if i == 8 { return 0x30; } if i == 9 { return 0x01; } if i == 10 { return 0x67; } if i == 11 { return 0x2b; }
        if i == 12 { return 0xfe; } if i == 13 { return 0xd7; } if i == 14 { return 0xab; } return 0x76;
    }
    if i < 32 {
        let j = i - 16;
        if j == 0 { return 0xca; } if j == 1 { return 0x82; } if j == 2 { return 0xc9; } if j == 3 { return 0x7d; }
        if j == 4 { return 0xfa; } if j == 5 { return 0x59; } if j == 6 { return 0x47; } if j == 7 { return 0xf0; }
        if j == 8 { return 0xad; } if j == 9 { return 0xd4; } if j == 10 { return 0xa2; } if j == 11 { return 0xaf; }
        if j == 12 { return 0x9c; } if j == 13 { return 0xa4; } if j == 14 { return 0x72; } return 0xc0;
    }
    if i < 48 {
        let j = i - 32;
        if j == 0 { return 0xb7; } if j == 1 { return 0xfd; } if j == 2 { return 0x93; } if j == 3 { return 0x26; }
        if j == 4 { return 0x36; } if j == 5 { return 0x3f; } if j == 6 { return 0xf7; } if j == 7 { return 0xcc; }
        if j == 8 { return 0x34; } if j == 9 { return 0xa5; } if j == 10 { return 0xe5; } if j == 11 { return 0xf1; }
        if j == 12 { return 0x71; } if j == 13 { return 0xd8; } if j == 14 { return 0x31; } return 0x15;
    }
    if i < 64 {
        let j = i - 48;
        if j == 0 { return 0x04; } if j == 1 { return 0xc7; } if j == 2 { return 0x23; } if j == 3 { return 0xc3; }
        if j == 4 { return 0x18; } if j == 5 { return 0x96; } if j == 6 { return 0x05; } if j == 7 { return 0x9a; }
        if j == 8 { return 0x07; } if j == 9 { return 0x12; } if j == 10 { return 0x80; } if j == 11 { return 0xe2; }
        if j == 12 { return 0xeb; } if j == 13 { return 0x27; } if j == 14 { return 0xb2; } return 0x75;
    }
    if i < 80 {
        let j = i - 64;
        if j == 0 { return 0x09; } if j == 1 { return 0x83; } if j == 2 { return 0x2c; } if j == 3 { return 0x1a; }
        if j == 4 { return 0x1b; } if j == 5 { return 0x6e; } if j == 6 { return 0x5a; } if j == 7 { return 0xa0; }
        if j == 8 { return 0x52; } if j == 9 { return 0x3b; } if j == 10 { return 0xd6; } if j == 11 { return 0xb3; }
        if j == 12 { return 0x29; } if j == 13 { return 0xe3; } if j == 14 { return 0x2f; } return 0x84;
    }
    if i < 96 {
        let j = i - 80;
        if j == 0 { return 0x53; } if j == 1 { return 0xd1; } if j == 2 { return 0x00; } if j == 3 { return 0xed; }
        if j == 4 { return 0x20; } if j == 5 { return 0xfc; } if j == 6 { return 0xb1; } if j == 7 { return 0x5b; }
        if j == 8 { return 0x6a; } if j == 9 { return 0xcb; } if j == 10 { return 0xbe; } if j == 11 { return 0x39; }
        if j == 12 { return 0x4a; } if j == 13 { return 0x4c; } if j == 14 { return 0x58; } return 0xcf;
    }
    if i < 112 {
        let j = i - 96;
        if j == 0 { return 0xd0; } if j == 1 { return 0xef; } if j == 2 { return 0xaa; } if j == 3 { return 0xfb; }
        if j == 4 { return 0x43; } if j == 5 { return 0x4d; } if j == 6 { return 0x33; } if j == 7 { return 0x85; }
        if j == 8 { return 0x45; } if j == 9 { return 0xf9; } if j == 10 { return 0x02; } if j == 11 { return 0x7f; }
        if j == 12 { return 0x50; } if j == 13 { return 0x3c; } if j == 14 { return 0x9f; } return 0xa8;
    }
    if i < 128 {
        let j = i - 112;
        if j == 0 { return 0x51; } if j == 1 { return 0xa3; } if j == 2 { return 0x40; } if j == 3 { return 0x8f; }
        if j == 4 { return 0x92; } if j == 5 { return 0x9d; } if j == 6 { return 0x38; } if j == 7 { return 0xf5; }
        if j == 8 { return 0xbc; } if j == 9 { return 0xb6; } if j == 10 { return 0xda; } if j == 11 { return 0x21; }
        if j == 12 { return 0x10; } if j == 13 { return 0xff; } if j == 14 { return 0xf3; } return 0xd2;
    }
    if i < 144 {
        let j = i - 128;
        if j == 0 { return 0xcd; } if j == 1 { return 0x0c; } if j == 2 { return 0x13; } if j == 3 { return 0xec; }
        if j == 4 { return 0x5f; } if j == 5 { return 0x97; } if j == 6 { return 0x44; } if j == 7 { return 0x17; }
        if j == 8 { return 0xc4; } if j == 9 { return 0xa7; } if j == 10 { return 0x7e; } if j == 11 { return 0x3d; }
        if j == 12 { return 0x64; } if j == 13 { return 0x5d; } if j == 14 { return 0x19; } return 0x73;
    }
    if i < 160 {
        let j = i - 144;
        if j == 0 { return 0x60; } if j == 1 { return 0x81; } if j == 2 { return 0x4f; } if j == 3 { return 0xdc; }
        if j == 4 { return 0x22; } if j == 5 { return 0x2a; } if j == 6 { return 0x90; } if j == 7 { return 0x88; }
        if j == 8 { return 0x46; } if j == 9 { return 0xee; } if j == 10 { return 0xb8; } if j == 11 { return 0x14; }
        if j == 12 { return 0xde; } if j == 13 { return 0x5e; } if j == 14 { return 0x0b; } return 0xdb;
    }
    if i < 176 {
        let j = i - 160;
        if j == 0 { return 0xe0; } if j == 1 { return 0x32; } if j == 2 { return 0x3a; } if j == 3 { return 0x0a; }
        if j == 4 { return 0x49; } if j == 5 { return 0x06; } if j == 6 { return 0x24; } if j == 7 { return 0x5c; }
        if j == 8 { return 0xc2; } if j == 9 { return 0xd3; } if j == 10 { return 0xac; } if j == 11 { return 0x62; }
        if j == 12 { return 0x91; } if j == 13 { return 0x95; } if j == 14 { return 0xe4; } return 0x79;
    }
    if i < 192 {
        let j = i - 176;
        if j == 0 { return 0xe7; } if j == 1 { return 0xc8; } if j == 2 { return 0x37; } if j == 3 { return 0x6d; }
        if j == 4 { return 0x8d; } if j == 5 { return 0xd5; } if j == 6 { return 0x4e; } if j == 7 { return 0xa9; }
        if j == 8 { return 0x6c; } if j == 9 { return 0x56; } if j == 10 { return 0xf4; } if j == 11 { return 0xea; }
        if j == 12 { return 0x65; } if j == 13 { return 0x7a; } if j == 14 { return 0xae; } return 0x08;
    }
    if i < 208 {
        let j = i - 192;
        if j == 0 { return 0xba; } if j == 1 { return 0x78; } if j == 2 { return 0x25; } if j == 3 { return 0x2e; }
        if j == 4 { return 0x1c; } if j == 5 { return 0xa6; } if j == 6 { return 0xb4; } if j == 7 { return 0xc6; }
        if j == 8 { return 0xe8; } if j == 9 { return 0xdd; } if j == 10 { return 0x74; } if j == 11 { return 0x1f; }
        if j == 12 { return 0x4b; } if j == 13 { return 0xbd; } if j == 14 { return 0x8b; } return 0x8a;
    }
    if i < 224 {
        let j = i - 208;
        if j == 0 { return 0x70; } if j == 1 { return 0x3e; } if j == 2 { return 0xb5; } if j == 3 { return 0x66; }
        if j == 4 { return 0x48; } if j == 5 { return 0x03; } if j == 6 { return 0xf6; } if j == 7 { return 0x0e; }
        if j == 8 { return 0x61; } if j == 9 { return 0x35; } if j == 10 { return 0x57; } if j == 11 { return 0xb9; }
        if j == 12 { return 0x86; } if j == 13 { return 0xc1; } if j == 14 { return 0x1d; } return 0x9e;
    }
    if i < 240 {
        let j = i - 224;
        if j == 0 { return 0xe1; } if j == 1 { return 0xf8; } if j == 2 { return 0x98; } if j == 3 { return 0x11; }
        if j == 4 { return 0x69; } if j == 5 { return 0xd9; } if j == 6 { return 0x8e; } if j == 7 { return 0x94; }
        if j == 8 { return 0x9b; } if j == 9 { return 0x1e; } if j == 10 { return 0x87; } if j == 11 { return 0xe9; }
        if j == 12 { return 0xce; } if j == 13 { return 0x55; } if j == 14 { return 0x28; } return 0xdf;
    }
    // i >= 240
    let j = i - 240;
    if j == 0 { return 0x8c; } if j == 1 { return 0xa1; } if j == 2 { return 0x89; } if j == 3 { return 0x0d; }
    if j == 4 { return 0xbf; } if j == 5 { return 0xe6; } if j == 6 { return 0x42; } if j == 7 { return 0x68; }
    if j == 8 { return 0x41; } if j == 9 { return 0x99; } if j == 10 { return 0x2d; } if j == 11 { return 0x0f; }
    if j == 12 { return 0xb0; } if j == 13 { return 0x54; } if j == 14 { return 0xbb; } return 0x16;
}

// AES round constant
fn aes_rcon(i: i64) -> i64 {
    if i == 0 { return 0x01; }
    if i == 1 { return 0x02; }
    if i == 2 { return 0x04; }
    if i == 3 { return 0x08; }
    if i == 4 { return 0x10; }
    if i == 5 { return 0x20; }
    if i == 6 { return 0x40; }
    if i == 7 { return 0x80; }
    if i == 8 { return 0x1b; }
    return 0x36;
}

// AES-128 Key Expansion (16 bytes key -> 176 bytes expanded)
fn aes_key_expand(key_addr: i64, expanded_addr: i64) {
    // Copy original key (first 16 bytes)
    let mut i: i64 = 0;
    while i < 16 {
        write_byte_addr(expanded_addr + i, read_byte_addr(key_addr + i));
        i = i + 1;
    }

    // Generate remaining round keys (10 rounds, 16 bytes each = 160 more bytes)
    let mut bytes_generated: i64 = 16;
    let mut rcon_idx: i64 = 0;

    while bytes_generated < 176 {
        // Get last 4 bytes
        let t0 = read_byte_addr(expanded_addr + bytes_generated - 4);
        let t1 = read_byte_addr(expanded_addr + bytes_generated - 3);
        let t2 = read_byte_addr(expanded_addr + bytes_generated - 2);
        let t3 = read_byte_addr(expanded_addr + bytes_generated - 1);

        // Every 16 bytes: RotWord + SubWord + Rcon
        if bytes_generated % 16 == 0 {
            // RotWord: [t0,t1,t2,t3] -> [t1,t2,t3,t0]
            // SubWord: apply S-box
            let s0 = aes_sbox(t1);
            let s1 = aes_sbox(t2);
            let s2 = aes_sbox(t3);
            let s3 = aes_sbox(t0);

            // XOR with Rcon
            let r = aes_rcon(rcon_idx);
            rcon_idx = rcon_idx + 1;

            // XOR with word 4 positions back
            let x0 = bit_xor(bit_xor(s0 as u64, r as u64), read_byte_addr(expanded_addr + bytes_generated - 16) as u64) as i64;
            let x1 = bit_xor(s1 as u64, read_byte_addr(expanded_addr + bytes_generated - 15) as u64) as i64;
            let x2 = bit_xor(s2 as u64, read_byte_addr(expanded_addr + bytes_generated - 14) as u64) as i64;
            let x3 = bit_xor(s3 as u64, read_byte_addr(expanded_addr + bytes_generated - 13) as u64) as i64;

            write_byte_addr(expanded_addr + bytes_generated, x0);
            write_byte_addr(expanded_addr + bytes_generated + 1, x1);
            write_byte_addr(expanded_addr + bytes_generated + 2, x2);
            write_byte_addr(expanded_addr + bytes_generated + 3, x3);
        } else {
            // Simple XOR with word 4 positions back
            let x0 = bit_xor(t0 as u64, read_byte_addr(expanded_addr + bytes_generated - 16) as u64) as i64;
            let x1 = bit_xor(t1 as u64, read_byte_addr(expanded_addr + bytes_generated - 15) as u64) as i64;
            let x2 = bit_xor(t2 as u64, read_byte_addr(expanded_addr + bytes_generated - 14) as u64) as i64;
            let x3 = bit_xor(t3 as u64, read_byte_addr(expanded_addr + bytes_generated - 13) as u64) as i64;

            write_byte_addr(expanded_addr + bytes_generated, x0);
            write_byte_addr(expanded_addr + bytes_generated + 1, x1);
            write_byte_addr(expanded_addr + bytes_generated + 2, x2);
            write_byte_addr(expanded_addr + bytes_generated + 3, x3);
        }
        bytes_generated = bytes_generated + 4;
    }
}

// GF(2^8) multiplication for MixColumns
fn gf_mul(a: i64, b: i64) -> i64 {
    let mut result: i64 = 0;
    let mut aa = a;
    let mut bb = b;

    let mut i: i64 = 0;
    while i < 8 {
        if bit_and(bb as u64, 1) != 0 {
            result = bit_xor(result as u64, aa as u64) as i64;
        }
        let hi_bit = bit_and(aa as u64, 0x80);
        aa = bit_and(shl_u64(aa as u64, 1), 0xFF) as i64;
        if hi_bit != 0 {
            aa = bit_xor(aa as u64, 0x1b) as i64;  // AES irreducible polynomial
        }
        bb = shr_u64(bb as u64, 1) as i64;
        i = i + 1;
    }
    result
}

// AES SubBytes transformation (in place, 16 bytes at state_addr)
fn aes_sub_bytes(state_addr: i64) {
    let mut i: i64 = 0;
    while i < 16 {
        let b = read_byte_addr(state_addr + i);
        write_byte_addr(state_addr + i, aes_sbox(b));
        i = i + 1;
    }
}

// AES ShiftRows transformation (in place)
fn aes_shift_rows(state_addr: i64) {
    // Row 0: no shift
    // Row 1: shift left by 1
    let t = read_byte_addr(state_addr + 1);
    write_byte_addr(state_addr + 1, read_byte_addr(state_addr + 5));
    write_byte_addr(state_addr + 5, read_byte_addr(state_addr + 9));
    write_byte_addr(state_addr + 9, read_byte_addr(state_addr + 13));
    write_byte_addr(state_addr + 13, t);

    // Row 2: shift left by 2
    let t0 = read_byte_addr(state_addr + 2);
    let t1 = read_byte_addr(state_addr + 6);
    write_byte_addr(state_addr + 2, read_byte_addr(state_addr + 10));
    write_byte_addr(state_addr + 6, read_byte_addr(state_addr + 14));
    write_byte_addr(state_addr + 10, t0);
    write_byte_addr(state_addr + 14, t1);

    // Row 3: shift left by 3 (= shift right by 1)
    let t = read_byte_addr(state_addr + 15);
    write_byte_addr(state_addr + 15, read_byte_addr(state_addr + 11));
    write_byte_addr(state_addr + 11, read_byte_addr(state_addr + 7));
    write_byte_addr(state_addr + 7, read_byte_addr(state_addr + 3));
    write_byte_addr(state_addr + 3, t);
}

// AES MixColumns transformation (in place)
fn aes_mix_columns(state_addr: i64) {
    let mut col: i64 = 0;
    while col < 4 {
        let c = col * 4;
        let s0 = read_byte_addr(state_addr + c);
        let s1 = read_byte_addr(state_addr + c + 1);
        let s2 = read_byte_addr(state_addr + c + 2);
        let s3 = read_byte_addr(state_addr + c + 3);

        // MixColumns matrix multiplication in GF(2^8)
        let r0 = bit_xor(bit_xor(bit_xor(gf_mul(2, s0) as u64, gf_mul(3, s1) as u64), s2 as u64), s3 as u64) as i64;
        let r1 = bit_xor(bit_xor(bit_xor(s0 as u64, gf_mul(2, s1) as u64), gf_mul(3, s2) as u64), s3 as u64) as i64;
        let r2 = bit_xor(bit_xor(bit_xor(s0 as u64, s1 as u64), gf_mul(2, s2) as u64), gf_mul(3, s3) as u64) as i64;
        let r3 = bit_xor(bit_xor(bit_xor(gf_mul(3, s0) as u64, s1 as u64), s2 as u64), gf_mul(2, s3) as u64) as i64;

        write_byte_addr(state_addr + c, r0);
        write_byte_addr(state_addr + c + 1, r1);
        write_byte_addr(state_addr + c + 2, r2);
        write_byte_addr(state_addr + c + 3, r3);

        col = col + 1;
    }
}

// AES AddRoundKey transformation
fn aes_add_round_key(state_addr: i64, round_key_addr: i64) {
    let mut i: i64 = 0;
    while i < 16 {
        let s = read_byte_addr(state_addr + i);
        let k = read_byte_addr(round_key_addr + i);
        write_byte_addr(state_addr + i, bit_xor(s as u64, k as u64) as i64);
        i = i + 1;
    }
}

// AES-128 Block Encryption (16 bytes plaintext -> 16 bytes ciphertext)
fn aes_encrypt_block(plaintext_addr: i64, ciphertext_addr: i64, expanded_key_addr: i64) {
    // Copy plaintext to state
    let state_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE + 8192;
    let mut i: i64 = 0;
    while i < 16 {
        write_byte_addr(state_addr + i, read_byte_addr(plaintext_addr + i));
        i = i + 1;
    }

    // Initial round key addition
    aes_add_round_key(state_addr, expanded_key_addr);

    // Main rounds (1-9)
    let mut round: i64 = 1;
    while round < 10 {
        aes_sub_bytes(state_addr);
        aes_shift_rows(state_addr);
        aes_mix_columns(state_addr);
        aes_add_round_key(state_addr, expanded_key_addr + round * 16);
        round = round + 1;
    }

    // Final round (no MixColumns)
    aes_sub_bytes(state_addr);
    aes_shift_rows(state_addr);
    aes_add_round_key(state_addr, expanded_key_addr + 160);

    // Copy state to ciphertext
    i = 0;
    while i < 16 {
        write_byte_addr(ciphertext_addr + i, read_byte_addr(state_addr + i));
        i = i + 1;
    }
}

// ============================================================
// GCM Mode Implementation
// ============================================================

// GF(2^128) multiplication for GHASH (bit-by-bit, MSB first)
fn gcm_gf_mul(x_addr: i64, y_addr: i64, result_addr: i64) {
    // Zero result
    let mut i: i64 = 0;
    while i < 16 {
        write_byte_addr(result_addr + i, 0);
        i = i + 1;
    }

    // Temp for V (copy of Y)
    let v_addr = result_addr + 16;
    i = 0;
    while i < 16 {
        write_byte_addr(v_addr + i, read_byte_addr(y_addr + i));
        i = i + 1;
    }

    // Process each bit of X
    let mut byte_idx: i64 = 0;
    while byte_idx < 16 {
        let x_byte = read_byte_addr(x_addr + byte_idx);
        let mut bit_idx: i64 = 7;
        while bit_idx >= 0 {
            // If bit is set, XOR V into result
            if bit_and(x_byte as u64, shl_u64(1, bit_idx as u64)) != 0 {
                i = 0;
                while i < 16 {
                    let r = read_byte_addr(result_addr + i);
                    let v = read_byte_addr(v_addr + i);
                    write_byte_addr(result_addr + i, bit_xor(r as u64, v as u64) as i64);
                    i = i + 1;
                }
            }

            // Multiply V by x (shift right, conditionally XOR R)
            let lsb = bit_and(read_byte_addr(v_addr + 15) as u64, 1);

            // Shift V right by 1 bit
            i = 15;
            while i > 0 {
                let curr = read_byte_addr(v_addr + i);
                let prev = read_byte_addr(v_addr + i - 1);
                let new_val = bit_or(shr_u64(curr as u64, 1), shl_u64(bit_and(prev as u64, 1), 7)) as i64;
                write_byte_addr(v_addr + i, new_val);
                i = i - 1;
            }
            write_byte_addr(v_addr, shr_u64(read_byte_addr(v_addr) as u64, 1) as i64);

            // If LSB was 1, XOR with R (0xE1 in MSB position)
            if lsb != 0 {
                let v0 = read_byte_addr(v_addr);
                write_byte_addr(v_addr, bit_xor(v0 as u64, 0xE1) as i64);
            }

            bit_idx = bit_idx - 1;
        }
        byte_idx = byte_idx + 1;
    }
}

// GHASH function for GCM authentication
fn gcm_ghash(h_addr: i64, data_addr: i64, data_len: i64, result_addr: i64) {
    // Zero result (Y_0 = 0)
    let mut i: i64 = 0;
    while i < 16 {
        write_byte_addr(result_addr + i, 0);
        i = i + 1;
    }

    // Process 16-byte blocks
    let temp_addr = result_addr + 32;
    let mut offset: i64 = 0;
    while offset < data_len {
        // XOR block into result
        i = 0;
        while i < 16 && (offset + i) < data_len {
            let r = read_byte_addr(result_addr + i);
            let d = read_byte_addr(data_addr + offset + i);
            write_byte_addr(result_addr + i, bit_xor(r as u64, d as u64) as i64);
            i = i + 1;
        }

        // GF multiply by H
        gcm_gf_mul(result_addr, h_addr, temp_addr);

        // Copy temp back to result
        i = 0;
        while i < 16 {
            write_byte_addr(result_addr + i, read_byte_addr(temp_addr + i));
            i = i + 1;
        }

        offset = offset + 16;
    }
}

// Increment counter (big-endian, last 4 bytes)
fn gcm_inc_counter(counter_addr: i64) {
    let mut i: i64 = 15;
    while i >= 12 {
        let b = read_byte_addr(counter_addr + i);
        if b < 255 {
            write_byte_addr(counter_addr + i, b + 1);
            return;
        }
        write_byte_addr(counter_addr + i, 0);
        i = i - 1;
    }
}

// AES-GCM Encrypt
// iv_addr: 12-byte IV
// plaintext_addr: plaintext data
// plaintext_len: length of plaintext
// aad_addr: additional authenticated data (can be 0)
// aad_len: length of AAD
// ciphertext_addr: output ciphertext (same size as plaintext)
// tag_addr: output 16-byte authentication tag
// expanded_key_addr: AES expanded key (176 bytes)
fn aes_gcm_encrypt(iv_addr: i64, plaintext_addr: i64, plaintext_len: i64,
                   aad_addr: i64, aad_len: i64,
                   ciphertext_addr: i64, tag_addr: i64, expanded_key_addr: i64) {
    let work_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE + 8448;

    // Compute H = AES(K, 0^128)
    let h_addr = work_addr;
    let zero_block_addr = work_addr + 64;
    let mut i: i64 = 0;
    while i < 16 {
        write_byte_addr(zero_block_addr + i, 0);
        i = i + 1;
    }
    aes_encrypt_block(zero_block_addr, h_addr, expanded_key_addr);

    // Initialize counter J0 = IV || 0^31 || 1
    let j0_addr = work_addr + 80;
    i = 0;
    while i < 12 {
        write_byte_addr(j0_addr + i, read_byte_addr(iv_addr + i));
        i = i + 1;
    }
    write_byte_addr(j0_addr + 12, 0);
    write_byte_addr(j0_addr + 13, 0);
    write_byte_addr(j0_addr + 14, 0);
    write_byte_addr(j0_addr + 15, 1);

    // Counter for encryption (J0 + 1)
    let counter_addr = work_addr + 96;
    i = 0;
    while i < 16 {
        write_byte_addr(counter_addr + i, read_byte_addr(j0_addr + i));
        i = i + 1;
    }
    gcm_inc_counter(counter_addr);

    // Encrypt plaintext (CTR mode)
    let keystream_addr = work_addr + 112;
    let mut offset: i64 = 0;
    while offset < plaintext_len {
        // Generate keystream block
        aes_encrypt_block(counter_addr, keystream_addr, expanded_key_addr);
        gcm_inc_counter(counter_addr);

        // XOR with plaintext
        i = 0;
        while i < 16 && (offset + i) < plaintext_len {
            let p = read_byte_addr(plaintext_addr + offset + i);
            let k = read_byte_addr(keystream_addr + i);
            write_byte_addr(ciphertext_addr + offset + i, bit_xor(p as u64, k as u64) as i64);
            i = i + 1;
        }
        offset = offset + 16;
    }

    // Build GHASH input: AAD || pad || C || pad || len(AAD) || len(C)
    let ghash_input_addr = work_addr + 256;
    let mut ghash_len: i64 = 0;

    // Copy AAD (padded to 16 bytes)
    if aad_len > 0 {
        i = 0;
        while i < aad_len {
            write_byte_addr(ghash_input_addr + i, read_byte_addr(aad_addr + i));
            i = i + 1;
        }
        // Pad to 16-byte boundary
        let aad_padded = ((aad_len + 15) / 16) * 16;
        while i < aad_padded {
            write_byte_addr(ghash_input_addr + i, 0);
            i = i + 1;
        }
        ghash_len = aad_padded;
    }

    // Copy ciphertext (padded to 16 bytes)
    i = 0;
    while i < plaintext_len {
        write_byte_addr(ghash_input_addr + ghash_len + i, read_byte_addr(ciphertext_addr + i));
        i = i + 1;
    }
    let ct_padded = ((plaintext_len + 15) / 16) * 16;
    while i < ct_padded {
        write_byte_addr(ghash_input_addr + ghash_len + i, 0);
        i = i + 1;
    }
    ghash_len = ghash_len + ct_padded;

    // Append lengths (big-endian, 64 bits each)
    let aad_bits = aad_len * 8;
    let ct_bits = plaintext_len * 8;
    write_byte_addr(ghash_input_addr + ghash_len, shr_u64(aad_bits as u64, 56) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 1, shr_u64(aad_bits as u64, 48) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 2, shr_u64(aad_bits as u64, 40) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 3, shr_u64(aad_bits as u64, 32) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 4, shr_u64(aad_bits as u64, 24) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 5, shr_u64(aad_bits as u64, 16) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 6, shr_u64(aad_bits as u64, 8) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 7, aad_bits as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 8, shr_u64(ct_bits as u64, 56) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 9, shr_u64(ct_bits as u64, 48) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 10, shr_u64(ct_bits as u64, 40) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 11, shr_u64(ct_bits as u64, 32) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 12, shr_u64(ct_bits as u64, 24) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 13, shr_u64(ct_bits as u64, 16) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 14, shr_u64(ct_bits as u64, 8) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 15, ct_bits as i64);
    ghash_len = ghash_len + 16;

    // Compute GHASH
    let ghash_result_addr = work_addr + 128;
    gcm_ghash(h_addr, ghash_input_addr, ghash_len, ghash_result_addr);

    // Compute tag = GHASH XOR AES(K, J0)
    let enc_j0_addr = work_addr + 144;
    aes_encrypt_block(j0_addr, enc_j0_addr, expanded_key_addr);

    i = 0;
    while i < 16 {
        let g = read_byte_addr(ghash_result_addr + i);
        let e = read_byte_addr(enc_j0_addr + i);
        write_byte_addr(tag_addr + i, bit_xor(g as u64, e as u64) as i64);
        i = i + 1;
    }
}

// AES-GCM Decrypt (returns 0 on success, -1 on tag mismatch)
fn aes_gcm_decrypt(iv_addr: i64, ciphertext_addr: i64, ciphertext_len: i64,
                   aad_addr: i64, aad_len: i64,
                   plaintext_addr: i64, tag_addr: i64, expanded_key_addr: i64) -> i64 {
    let work_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE + 8448;

    // Compute H = AES(K, 0^128)
    let h_addr = work_addr;
    let zero_block_addr = work_addr + 64;
    let mut i: i64 = 0;
    while i < 16 {
        write_byte_addr(zero_block_addr + i, 0);
        i = i + 1;
    }
    aes_encrypt_block(zero_block_addr, h_addr, expanded_key_addr);

    // Initialize counter J0 = IV || 0^31 || 1
    let j0_addr = work_addr + 80;
    i = 0;
    while i < 12 {
        write_byte_addr(j0_addr + i, read_byte_addr(iv_addr + i));
        i = i + 1;
    }
    write_byte_addr(j0_addr + 12, 0);
    write_byte_addr(j0_addr + 13, 0);
    write_byte_addr(j0_addr + 14, 0);
    write_byte_addr(j0_addr + 15, 1);

    // Build GHASH input and compute expected tag
    let ghash_input_addr = work_addr + 256;
    let mut ghash_len: i64 = 0;

    // Copy AAD (padded to 16 bytes)
    if aad_len > 0 {
        i = 0;
        while i < aad_len {
            write_byte_addr(ghash_input_addr + i, read_byte_addr(aad_addr + i));
            i = i + 1;
        }
        let aad_padded = ((aad_len + 15) / 16) * 16;
        while i < aad_padded {
            write_byte_addr(ghash_input_addr + i, 0);
            i = i + 1;
        }
        ghash_len = aad_padded;
    }

    // Copy ciphertext (padded)
    i = 0;
    while i < ciphertext_len {
        write_byte_addr(ghash_input_addr + ghash_len + i, read_byte_addr(ciphertext_addr + i));
        i = i + 1;
    }
    let ct_padded = ((ciphertext_len + 15) / 16) * 16;
    while i < ct_padded {
        write_byte_addr(ghash_input_addr + ghash_len + i, 0);
        i = i + 1;
    }
    ghash_len = ghash_len + ct_padded;

    // Append lengths
    let aad_bits = aad_len * 8;
    let ct_bits = ciphertext_len * 8;
    write_byte_addr(ghash_input_addr + ghash_len, shr_u64(aad_bits as u64, 56) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 1, shr_u64(aad_bits as u64, 48) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 2, shr_u64(aad_bits as u64, 40) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 3, shr_u64(aad_bits as u64, 32) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 4, shr_u64(aad_bits as u64, 24) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 5, shr_u64(aad_bits as u64, 16) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 6, shr_u64(aad_bits as u64, 8) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 7, aad_bits as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 8, shr_u64(ct_bits as u64, 56) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 9, shr_u64(ct_bits as u64, 48) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 10, shr_u64(ct_bits as u64, 40) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 11, shr_u64(ct_bits as u64, 32) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 12, shr_u64(ct_bits as u64, 24) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 13, shr_u64(ct_bits as u64, 16) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 14, shr_u64(ct_bits as u64, 8) as i64);
    write_byte_addr(ghash_input_addr + ghash_len + 15, ct_bits as i64);
    ghash_len = ghash_len + 16;

    // Compute GHASH
    let ghash_result_addr = work_addr + 128;
    gcm_ghash(h_addr, ghash_input_addr, ghash_len, ghash_result_addr);

    // Compute expected tag
    let enc_j0_addr = work_addr + 144;
    aes_encrypt_block(j0_addr, enc_j0_addr, expanded_key_addr);

    let expected_tag_addr = work_addr + 160;
    i = 0;
    while i < 16 {
        let g = read_byte_addr(ghash_result_addr + i);
        let e = read_byte_addr(enc_j0_addr + i);
        write_byte_addr(expected_tag_addr + i, bit_xor(g as u64, e as u64) as i64);
        i = i + 1;
    }

    // Verify tag (constant-time comparison)
    let mut diff: i64 = 0;
    i = 0;
    while i < 16 {
        let expected = read_byte_addr(expected_tag_addr + i);
        let actual = read_byte_addr(tag_addr + i);
        diff = bit_or(diff as u64, bit_xor(expected as u64, actual as u64)) as i64;
        i = i + 1;
    }

    if diff != 0 {
        return -1;  // Tag mismatch
    }

    // Decrypt ciphertext (CTR mode, same as encrypt)
    let counter_addr = work_addr + 96;
    i = 0;
    while i < 16 {
        write_byte_addr(counter_addr + i, read_byte_addr(j0_addr + i));
        i = i + 1;
    }
    gcm_inc_counter(counter_addr);

    let keystream_addr = work_addr + 112;
    let mut offset: i64 = 0;
    while offset < ciphertext_len {
        aes_encrypt_block(counter_addr, keystream_addr, expanded_key_addr);
        gcm_inc_counter(counter_addr);

        i = 0;
        while i < 16 && (offset + i) < ciphertext_len {
            let c = read_byte_addr(ciphertext_addr + offset + i);
            let k = read_byte_addr(keystream_addr + i);
            write_byte_addr(plaintext_addr + offset + i, bit_xor(c as u64, k as u64) as i64);
            i = i + 1;
        }
        offset = offset + 16;
    }

    0  // Success
}

// ============================================================
// RSA Implementation (2048-bit)
// ============================================================

// Big integer representation: array of 32 64-bit words (2048 bits)
// Stored in little-endian order (word 0 is least significant)
const RSA_WORDS: i64 = 32;          // 32 * 64 = 2048 bits
const RSA_BYTES: i64 = 256;         // 2048 / 8 = 256 bytes
const RSA_WORK_ADDR: i64 = 0x3000000;  // RSA working memory (16KB) - must be < 64MB (mapped)

// Zero a big integer (32 words at addr)
fn bigint_zero(addr: i64) {
    let mut i: i64 = 0;
    while i < RSA_WORDS {
        write_u64_addr(addr + i * 8, 0);
        i = i + 1;
    }
}

// Copy big integer: dst = src
fn bigint_copy(dst: i64, src: i64) {
    let mut i: i64 = 0;
    while i < RSA_WORDS {
        write_u64_addr(dst + i * 8, read_u64_addr(src + i * 8));
        i = i + 1;
    }
}

// Load big integer from big-endian bytes
fn bigint_from_bytes(dst: i64, src: i64, len: i64) {
    bigint_zero(dst);
    let mut i: i64 = 0;
    while i < len && i < RSA_BYTES {
        // Big-endian: first byte is most significant
        let byte_val = read_byte_addr(src + i);
        let word_idx = (RSA_BYTES - 1 - i) / 8;
        let byte_idx = (RSA_BYTES - 1 - i) % 8;
        let shift = (byte_idx * 8) as u64;
        let current = read_u64_addr(dst + word_idx * 8);
        write_u64_addr(dst + word_idx * 8, bit_or(current, shl_u64(byte_val as u64, shift)));
        i = i + 1;
    }
}

// Store big integer to big-endian bytes
fn bigint_to_bytes(dst: i64, src: i64) {
    let mut i: i64 = 0;
    while i < RSA_BYTES {
        let word_idx = (RSA_BYTES - 1 - i) / 8;
        let byte_idx = (RSA_BYTES - 1 - i) % 8;
        let shift = (byte_idx * 8) as u64;
        let word = read_u64_addr(src + word_idx * 8);
        let byte_val = bit_and(shr_u64(word, shift), 0xFF) as i64;
        write_byte_addr(dst + i, byte_val);
        i = i + 1;
    }
}

// Compare big integers: returns -1 if a < b, 0 if a == b, 1 if a > b
fn bigint_cmp(a: i64, b: i64) -> i64 {
    let mut i: i64 = RSA_WORDS - 1;
    while i >= 0 {
        let av = read_u64_addr(a + i * 8);
        let bv = read_u64_addr(b + i * 8);
        if av > bv {
            return 1;
        }
        if av < bv {
            return -1;
        }
        i = i - 1;
    }
    0
}

// Add big integers: result = a + b, returns carry (0 or 1)
fn bigint_add(result: i64, a: i64, b: i64) -> i64 {
    let mut carry: u64 = 0;
    let mut i: i64 = 0;
    while i < RSA_WORDS {
        let av = read_u64_addr(a + i * 8);
        let bv = read_u64_addr(b + i * 8);

        // Add with carry using two separate additions to detect overflow
        let sum1 = av + bv;
        let carry1: u64 = if sum1 < av { 1 } else { 0 };
        let sum2 = sum1 + carry;
        let carry2: u64 = if sum2 < sum1 { 1 } else { 0 };

        write_u64_addr(result + i * 8, sum2);
        carry = carry1 + carry2;
        i = i + 1;
    }
    carry as i64
}

// Subtract big integers: result = a - b, returns borrow (0 or 1)
fn bigint_sub(result: i64, a: i64, b: i64) -> i64 {
    let mut borrow: u64 = 0;
    let mut i: i64 = 0;
    while i < RSA_WORDS {
        let av = read_u64_addr(a + i * 8);
        let bv = read_u64_addr(b + i * 8);

        // Subtract with borrow
        let diff1 = av - bv;
        let borrow1: u64 = if diff1 > av { 1 } else { 0 };
        let diff2 = diff1 - borrow;
        let borrow2: u64 = if diff2 > diff1 { 1 } else { 0 };

        write_u64_addr(result + i * 8, diff2);
        borrow = borrow1 + borrow2;
        i = i + 1;
    }
    borrow as i64
}

// Multiply 64-bit * 64-bit -> 128-bit (returns high 64 bits, stores low 64 bits)
fn mul64_128(a: u64, b: u64, lo_addr: i64) -> u64 {
    // Split into 32-bit halves to avoid overflow
    let a_lo = bit_and(a, 0xFFFFFFFF);
    let a_hi = shr_u64(a, 32);
    let b_lo = bit_and(b, 0xFFFFFFFF);
    let b_hi = shr_u64(b, 32);

    // Partial products
    let p0 = a_lo * b_lo;                    // Low * Low
    let p1 = a_lo * b_hi;                    // Low * High
    let p2 = a_hi * b_lo;                    // High * Low
    let p3 = a_hi * b_hi;                    // High * High

    // Combine: result = p3:p0 + (p1 + p2) << 32
    let mid = p1 + p2;
    let mid_carry: u64 = if mid < p1 { 1 } else { 0 };

    let mid_lo = shl_u64(bit_and(mid, 0xFFFFFFFF), 32);
    let mid_hi = shr_u64(mid, 32);

    let lo = p0 + mid_lo;
    let lo_carry: u64 = if lo < p0 { 1 } else { 0 };

    let hi = p3 + mid_hi + lo_carry + shl_u64(mid_carry, 32);

    write_u64_addr(lo_addr, lo);
    hi
}

// Multiply big integer by single word: result = a * w
fn bigint_mul_word(result: i64, a: i64, w: u64) {
    let mut carry: u64 = 0;
    let mut i: i64 = 0;
    let lo_temp = RSA_WORK_ADDR + 8192;

    while i < RSA_WORDS {
        let av = read_u64_addr(a + i * 8);
        let hi = mul64_128(av, w, lo_temp);
        let lo = read_u64_addr(lo_temp);

        let sum = lo + carry;
        let sum_carry: u64 = if sum < lo { 1 } else { 0 };

        write_u64_addr(result + i * 8, sum);
        carry = hi + sum_carry;
        i = i + 1;
    }
}

// Left shift big integer by 1 bit
fn bigint_shl1(a: i64) {
    let mut carry: u64 = 0;
    let mut i: i64 = 0;
    while i < RSA_WORDS {
        let v = read_u64_addr(a + i * 8);
        let new_carry = shr_u64(v, 63);
        write_u64_addr(a + i * 8, bit_or(shl_u64(v, 1), carry));
        carry = new_carry;
        i = i + 1;
    }
}

// Right shift big integer by 1 bit
fn bigint_shr1(a: i64) {
    let mut carry: u64 = 0;
    let mut i: i64 = RSA_WORDS - 1;
    while i >= 0 {
        let v = read_u64_addr(a + i * 8);
        let new_carry = shl_u64(bit_and(v, 1), 63);
        write_u64_addr(a + i * 8, bit_or(shr_u64(v, 1), carry));
        carry = new_carry;
        i = i - 1;
    }
}

// Check if big integer is zero
fn bigint_is_zero(a: i64) -> i64 {
    let mut i: i64 = 0;
    while i < RSA_WORDS {
        if read_u64_addr(a + i * 8) != 0 {
            return 0;
        }
        i = i + 1;
    }
    1
}

// Get bit at position (0 = LSB)
fn bigint_get_bit(a: i64, pos: i64) -> i64 {
    let word_idx = pos / 64;
    let bit_idx = pos % 64;
    if word_idx >= RSA_WORDS {
        return 0;
    }
    let word = read_u64_addr(a + word_idx * 8);
    bit_and(shr_u64(word, bit_idx as u64), 1) as i64
}

// Get highest set bit position (-1 if zero)
fn bigint_bit_length(a: i64) -> i64 {
    let mut i: i64 = RSA_WORDS - 1;
    let mut result: i64 = -1;
    let mut found: i64 = 0;

    while i >= 0 && found == 0 {
        let word = read_u64_addr(a + i * 8);
        if word != 0 {
            // Find highest bit in this word
            let mut bit: i64 = 63;
            while bit >= 0 && found == 0 {
                if bit_and(shr_u64(word, bit as u64), 1) != 0 {
                    result = i * 64 + bit;
                    found = 1;
                }
                if found == 0 {
                    bit = bit - 1;
                }
            }
        }
        if found == 0 {
            i = i - 1;
        }
    }
    result
}

// Modular reduction: result = a mod n (using subtraction method for simplicity)
// This is slow but correct - can be optimized with Montgomery later
fn bigint_mod(result: i64, a: i64, n: i64) {
    let temp = RSA_WORK_ADDR + 512;
    let shifted_n = RSA_WORK_ADDR + 768;

    bigint_copy(result, a);

    // Find how much to shift n to align with a
    let a_bits = bigint_bit_length(result);
    let n_bits = bigint_bit_length(n);

    if a_bits < n_bits {
        return;  // Already reduced
    }

    let shift_amount = a_bits - n_bits;

    // Shift n left
    bigint_copy(shifted_n, n);
    let mut s: i64 = 0;
    while s < shift_amount {
        bigint_shl1(shifted_n);
        s = s + 1;
    }

    // Subtract shifted_n from result while result >= shifted_n
    let mut current_shift = shift_amount;
    while current_shift >= 0 {
        while bigint_cmp(result, shifted_n) >= 0 {
            bigint_sub(result, result, shifted_n);
        }
        if current_shift > 0 {
            bigint_shr1(shifted_n);
        }
        current_shift = current_shift - 1;
    }
}

// Modular multiplication: result = (a * b) mod n
fn bigint_mulmod(result: i64, a: i64, b: i64, n: i64) {
    let product = RSA_WORK_ADDR + 1024;  // 64 words for product
    let product_hi = product + RSA_WORDS * 8;

    // Zero product (need 64 words for full product)
    let mut i: i64 = 0;
    while i < RSA_WORDS * 2 {
        write_u64_addr(product + i * 8, 0);
        i = i + 1;
    }

    // Schoolbook multiplication
    i = 0;
    while i < RSA_WORDS {
        let bv = read_u64_addr(b + i * 8);
        if bv != 0 {
            let mut carry: u64 = 0;
            let mut j: i64 = 0;
            let lo_temp = RSA_WORK_ADDR + 8200;

            while j < RSA_WORDS {
                let av = read_u64_addr(a + j * 8);
                let pv = read_u64_addr(product + (i + j) * 8);

                let hi = mul64_128(av, bv, lo_temp);
                let lo = read_u64_addr(lo_temp);

                let sum1 = lo + pv;
                let carry1: u64 = if sum1 < lo { 1 } else { 0 };
                let sum2 = sum1 + carry;
                let carry2: u64 = if sum2 < sum1 { 1 } else { 0 };

                write_u64_addr(product + (i + j) * 8, sum2);
                carry = hi + carry1 + carry2;
                j = j + 1;
            }

            // Propagate final carry
            let mut k = i + RSA_WORDS;
            while carry != 0 && k < RSA_WORDS * 2 {
                let pv = read_u64_addr(product + k * 8);
                let sum = pv + carry;
                let new_carry: u64 = if sum < pv { 1 } else { 0 };
                write_u64_addr(product + k * 8, sum);
                carry = new_carry;
                k = k + 1;
            }
        }
        i = i + 1;
    }

    // Now reduce product mod n
    // For simplicity, use repeated subtraction (slow but works)
    bigint_mod(result, product, n);
}

// Modular exponentiation: result = base^exp mod n
// Using square-and-multiply (right-to-left binary method)
fn bigint_modexp(result: i64, base: i64, exp: i64, n: i64) {
    let temp_base = RSA_WORK_ADDR + 2048;
    let temp_result = RSA_WORK_ADDR + 2304;

    // result = 1
    bigint_zero(result);
    write_u64_addr(result, 1);

    // temp_base = base mod n
    bigint_mod(temp_base, base, n);

    // Find exponent bit length
    let exp_bits = bigint_bit_length(exp);
    if exp_bits < 0 {
        return;  // exp = 0, result = 1
    }

    // Square-and-multiply
    let mut i: i64 = 0;
    while i <= exp_bits {
        if bigint_get_bit(exp, i) == 1 {
            // result = result * base mod n
            bigint_mulmod(temp_result, result, temp_base, n);
            bigint_copy(result, temp_result);
        }

        // base = base^2 mod n
        bigint_mulmod(temp_result, temp_base, temp_base, n);
        bigint_copy(temp_base, temp_result);

        i = i + 1;
    }
}

// RSA encrypt: ciphertext = plaintext^e mod n
fn rsa_encrypt(ciphertext_addr: i64, plaintext_addr: i64, plaintext_len: i64,
               n_addr: i64, n_len: i64, e: u64) {
    let n_bigint = RSA_WORK_ADDR + 3072;
    let m_bigint = RSA_WORK_ADDR + 3328;
    let c_bigint = RSA_WORK_ADDR + 3584;
    let e_bigint = RSA_WORK_ADDR + 3840;

    // Load modulus n
    bigint_from_bytes(n_bigint, n_addr, n_len);

    // Load plaintext (already PKCS#1 padded)
    bigint_from_bytes(m_bigint, plaintext_addr, plaintext_len);

    // Set up exponent (usually 65537)
    bigint_zero(e_bigint);
    write_u64_addr(e_bigint, e);

    // Compute c = m^e mod n
    bigint_modexp(c_bigint, m_bigint, e_bigint, n_bigint);

    // Store result
    bigint_to_bytes(ciphertext_addr, c_bigint);
}

// PKCS#1 v1.5 padding for encryption
// Input: message (48 bytes premaster secret)
// Output: padded message (256 bytes for 2048-bit RSA)
fn pkcs1_pad(output_addr: i64, message_addr: i64, message_len: i64, output_len: i64) {
    // Format: 0x00 || 0x02 || PS || 0x00 || M
    // PS = random non-zero padding bytes
    // PS length = output_len - message_len - 3

    let ps_len = output_len - message_len - 3;
    if ps_len < 8 {
        return;  // Message too long
    }

    let mut pos: i64 = 0;

    // Leading zero
    write_byte_addr(output_addr + pos, 0x00);
    pos = pos + 1;

    // Block type (0x02 for encryption)
    write_byte_addr(output_addr + pos, 0x02);
    pos = pos + 1;

    // Random padding (non-zero bytes)
    // Use timer-based pseudo-random for now
    let time = read_u64_addr(TICK_COUNT_ADDR);
    let mut i: i64 = 0;
    while i < ps_len {
        // Generate pseudo-random non-zero byte
        let r = bit_xor(time, ((i + 1) * 0x5DEECE66D) as u64);
        let shifted = shr_u64(r, (i % 7) as u64);
        let mut byte_val = bit_and(shifted, 0xFF) as i64;
        if byte_val == 0 {
            byte_val = 0x42;  // Replace zero with non-zero
        }
        write_byte_addr(output_addr + pos, byte_val);
        pos = pos + 1;
        i = i + 1;
    }

    // Separator
    write_byte_addr(output_addr + pos, 0x00);
    pos = pos + 1;

    // Message
    i = 0;
    while i < message_len {
        write_byte_addr(output_addr + pos, read_byte_addr(message_addr + i));
        pos = pos + 1;
        i = i + 1;
    }
}

// ============================================================
// X.509 Certificate Parsing
// ============================================================

// ASN.1 tag constants
const ASN1_SEQUENCE: i64 = 0x30;
const ASN1_SET: i64 = 0x31;
const ASN1_INTEGER: i64 = 0x02;
const ASN1_BIT_STRING: i64 = 0x03;
const ASN1_OCTET_STRING: i64 = 0x04;
const ASN1_NULL: i64 = 0x05;
const ASN1_OID: i64 = 0x06;

// Parse ASN.1 length field, returns length and advances offset
fn asn1_parse_length(data_addr: i64, offset_addr: i64) -> i64 {
    let offset = read_u64_addr(offset_addr) as i64;
    let first_byte = read_byte_addr(data_addr + offset);

    if bit_and(first_byte as u64, 0x80) == 0 {
        // Short form: length is in this byte
        write_u64_addr(offset_addr, (offset + 1) as u64);
        return first_byte;
    }

    // Long form: first byte tells us how many length bytes follow
    let num_bytes = bit_and(first_byte as u64, 0x7F) as i64;
    let mut length: i64 = 0;
    let mut i: i64 = 0;
    while i < num_bytes {
        length = shl_u64(length as u64, 8) as i64;
        length = length + read_byte_addr(data_addr + offset + 1 + i);
        i = i + 1;
    }

    write_u64_addr(offset_addr, (offset + 1 + num_bytes) as u64);
    length
}

// Skip ASN.1 element and return its length
fn asn1_skip_element(data_addr: i64, offset_addr: i64) -> i64 {
    let offset = read_u64_addr(offset_addr) as i64;
    let tag = read_byte_addr(data_addr + offset);
    write_u64_addr(offset_addr, (offset + 1) as u64);
    let length = asn1_parse_length(data_addr, offset_addr);
    let new_offset = read_u64_addr(offset_addr) as i64;
    write_u64_addr(offset_addr, (new_offset + length) as u64);
    length
}

// Extract RSA public key (n, e) from X.509 certificate
// Returns 0 on success, -1 on failure
// Stores n at n_addr (up to 256 bytes), e at e_addr (4 bytes)
fn x509_extract_rsa_pubkey(cert_addr: i64, cert_len: i64, n_addr: i64, n_len_addr: i64, e_addr: i64) -> i64 {
    let offset_storage = RSA_WORK_ADDR + 4096;
    write_u64_addr(offset_storage, 0);

    // Certificate ::= SEQUENCE { tbsCertificate, signatureAlgorithm, signature }
    let tag = read_byte_addr(cert_addr);
    if tag != ASN1_SEQUENCE {
        return -1;
    }
    write_u64_addr(offset_storage, 1);
    let cert_seq_len = asn1_parse_length(cert_addr, offset_storage);

    // TBSCertificate ::= SEQUENCE { ... }
    let tbs_offset = read_u64_addr(offset_storage) as i64;
    let tbs_tag = read_byte_addr(cert_addr + tbs_offset);
    if tbs_tag != ASN1_SEQUENCE {
        return -2;
    }
    write_u64_addr(offset_storage, (tbs_offset + 1) as u64);
    let tbs_len = asn1_parse_length(cert_addr, offset_storage);
    let tbs_content_start = read_u64_addr(offset_storage) as i64;

    // TBSCertificate contains: version?, serialNumber, signature, issuer, validity, subject, subjectPublicKeyInfo, ...
    let mut current_offset = tbs_content_start;

    // Check for optional version [0] EXPLICIT
    let first_tag = read_byte_addr(cert_addr + current_offset);
    if first_tag == 0xA0 {  // Context-specific constructed [0]
        write_u64_addr(offset_storage, current_offset as u64);
        asn1_skip_element(cert_addr, offset_storage);
        current_offset = read_u64_addr(offset_storage) as i64;
    }

    // serialNumber INTEGER
    write_u64_addr(offset_storage, current_offset as u64);
    asn1_skip_element(cert_addr, offset_storage);
    current_offset = read_u64_addr(offset_storage) as i64;

    // signature AlgorithmIdentifier
    write_u64_addr(offset_storage, current_offset as u64);
    asn1_skip_element(cert_addr, offset_storage);
    current_offset = read_u64_addr(offset_storage) as i64;

    // issuer Name
    write_u64_addr(offset_storage, current_offset as u64);
    asn1_skip_element(cert_addr, offset_storage);
    current_offset = read_u64_addr(offset_storage) as i64;

    // validity Validity
    write_u64_addr(offset_storage, current_offset as u64);
    asn1_skip_element(cert_addr, offset_storage);
    current_offset = read_u64_addr(offset_storage) as i64;

    // subject Name
    write_u64_addr(offset_storage, current_offset as u64);
    asn1_skip_element(cert_addr, offset_storage);
    current_offset = read_u64_addr(offset_storage) as i64;

    // subjectPublicKeyInfo SubjectPublicKeyInfo
    // SubjectPublicKeyInfo ::= SEQUENCE { algorithm, subjectPublicKey BIT STRING }
    let spki_tag = read_byte_addr(cert_addr + current_offset);
    if spki_tag != ASN1_SEQUENCE {
        return -3;
    }
    write_u64_addr(offset_storage, (current_offset + 1) as u64);
    let spki_len = asn1_parse_length(cert_addr, offset_storage);
    let spki_content_start = read_u64_addr(offset_storage) as i64;

    // algorithm AlgorithmIdentifier - skip it
    write_u64_addr(offset_storage, spki_content_start as u64);
    asn1_skip_element(cert_addr, offset_storage);
    let pubkey_offset = read_u64_addr(offset_storage) as i64;

    // subjectPublicKey BIT STRING
    let pk_tag = read_byte_addr(cert_addr + pubkey_offset);
    if pk_tag != ASN1_BIT_STRING {
        return -4;
    }
    write_u64_addr(offset_storage, (pubkey_offset + 1) as u64);
    let pk_len = asn1_parse_length(cert_addr, offset_storage);
    let pk_content_start = read_u64_addr(offset_storage) as i64;

    // BIT STRING has unused bits count as first byte
    let unused_bits = read_byte_addr(cert_addr + pk_content_start);
    let rsa_pubkey_start = pk_content_start + 1;

    // RSAPublicKey ::= SEQUENCE { modulus INTEGER, publicExponent INTEGER }
    let rsa_tag = read_byte_addr(cert_addr + rsa_pubkey_start);
    if rsa_tag != ASN1_SEQUENCE {
        return -5;
    }
    write_u64_addr(offset_storage, (rsa_pubkey_start + 1) as u64);
    let rsa_len = asn1_parse_length(cert_addr, offset_storage);
    let rsa_content_start = read_u64_addr(offset_storage) as i64;

    // modulus INTEGER
    let n_tag = read_byte_addr(cert_addr + rsa_content_start);
    if n_tag != ASN1_INTEGER {
        return -6;
    }
    write_u64_addr(offset_storage, (rsa_content_start + 1) as u64);
    let n_len = asn1_parse_length(cert_addr, offset_storage);
    let n_content_start = read_u64_addr(offset_storage) as i64;

    // Copy modulus (skip leading zero if present)
    let mut n_start = n_content_start;
    let mut actual_n_len = n_len;
    if read_byte_addr(cert_addr + n_start) == 0 && actual_n_len > 1 {
        n_start = n_start + 1;
        actual_n_len = actual_n_len - 1;
    }

    let mut i: i64 = 0;
    while i < actual_n_len && i < 256 {
        write_byte_addr(n_addr + i, read_byte_addr(cert_addr + n_start + i));
        i = i + 1;
    }
    write_u64_addr(n_len_addr, actual_n_len as u64);

    // publicExponent INTEGER
    let e_offset = n_content_start + n_len;
    let e_tag = read_byte_addr(cert_addr + e_offset);
    if e_tag != ASN1_INTEGER {
        return -7;
    }
    write_u64_addr(offset_storage, (e_offset + 1) as u64);
    let e_len = asn1_parse_length(cert_addr, offset_storage);
    let e_content_start = read_u64_addr(offset_storage) as i64;

    // Read exponent (usually 3 bytes for 65537)
    let mut exp: i64 = 0;
    i = 0;
    while i < e_len && i < 4 {
        exp = shl_u64(exp as u64, 8) as i64;
        exp = exp + read_byte_addr(cert_addr + e_content_start + i);
        i = i + 1;
    }
    write_u64_addr(e_addr, exp as u64);

    0  // Success
}

// ============================================================
// TLS Handshake Implementation
// ============================================================

// Build and send ClientHello message
fn tls_send_client_hello(conn: i64, socket: i64) -> i64 {
    let tx_buf = conn + TLS_OFF_TX_BUF;
    let mut pos: i64 = 0;

    // TLS Record header
    write_byte_addr(tx_buf + pos, 0x16);  // Handshake
    pos = pos + 1;
    write_byte_addr(tx_buf + pos, 0x03);  // TLS 1.0 for ClientHello
    write_byte_addr(tx_buf + pos + 1, 0x01);
    pos = pos + 2;
    // Length placeholder (will fill later)
    let record_len_pos = pos;
    pos = pos + 2;

    // Handshake header
    let hs_start = pos;
    write_byte_addr(tx_buf + pos, 0x01);  // ClientHello
    pos = pos + 1;
    // Length placeholder (3 bytes)
    let hs_len_pos = pos;
    pos = pos + 3;

    // Client Version (TLS 1.2)
    write_byte_addr(tx_buf + pos, 0x03);
    write_byte_addr(tx_buf + pos + 1, 0x03);
    pos = pos + 2;

    // Client Random (32 bytes)
    let mut i: i64 = 0;
    while i < 32 {
        write_byte_addr(tx_buf + pos + i, read_byte_addr(conn + TLS_OFF_CLIENT_RANDOM + i));
        i = i + 1;
    }
    pos = pos + 32;

    // Session ID (empty)
    write_byte_addr(tx_buf + pos, 0);
    pos = pos + 1;

    // Cipher Suites (2 bytes length + suites)
    write_byte_addr(tx_buf + pos, 0);
    write_byte_addr(tx_buf + pos + 1, 2);  // 1 cipher suite = 2 bytes
    pos = pos + 2;
    // TLS_RSA_WITH_AES_128_GCM_SHA256 (0x009C)
    write_byte_addr(tx_buf + pos, 0x00);
    write_byte_addr(tx_buf + pos + 1, 0x9C);
    pos = pos + 2;

    // Compression Methods (1 byte length + null)
    write_byte_addr(tx_buf + pos, 1);  // Length
    write_byte_addr(tx_buf + pos + 1, 0);  // No compression
    pos = pos + 2;

    // Extensions (SNI - Server Name Indication)
    let ext_start = pos;
    pos = pos + 2;  // Extension length placeholder

    // SNI Extension
    let hostname_len = read_u64_addr(conn + TLS_OFF_HOSTNAME_LEN) as i64;
    if hostname_len > 0 {
        // Extension type: server_name (0x0000)
        write_byte_addr(tx_buf + pos, 0);
        write_byte_addr(tx_buf + pos + 1, 0);
        pos = pos + 2;

        // Extension data length
        let sni_data_len = hostname_len + 5;
        write_byte_addr(tx_buf + pos, shr_u64(sni_data_len as u64, 8) as i64);
        write_byte_addr(tx_buf + pos + 1, sni_data_len as i64);
        pos = pos + 2;

        // Server Name List length
        let sni_list_len = hostname_len + 3;
        write_byte_addr(tx_buf + pos, shr_u64(sni_list_len as u64, 8) as i64);
        write_byte_addr(tx_buf + pos + 1, sni_list_len as i64);
        pos = pos + 2;

        // Name type: host_name (0)
        write_byte_addr(tx_buf + pos, 0);
        pos = pos + 1;

        // Hostname length
        write_byte_addr(tx_buf + pos, shr_u64(hostname_len as u64, 8) as i64);
        write_byte_addr(tx_buf + pos + 1, hostname_len as i64);
        pos = pos + 2;

        // Hostname
        i = 0;
        while i < hostname_len {
            write_byte_addr(tx_buf + pos + i, read_byte_addr(conn + TLS_OFF_HOSTNAME + i));
            i = i + 1;
        }
        pos = pos + hostname_len;
    }

    // Fill extension length
    let ext_len = pos - ext_start - 2;
    write_byte_addr(tx_buf + ext_start, shr_u64(ext_len as u64, 8) as i64);
    write_byte_addr(tx_buf + ext_start + 1, ext_len as i64);

    // Fill handshake length
    let hs_len = pos - hs_start - 4;
    write_byte_addr(tx_buf + hs_len_pos, shr_u64(hs_len as u64, 16) as i64);
    write_byte_addr(tx_buf + hs_len_pos + 1, shr_u64(hs_len as u64, 8) as i64);
    write_byte_addr(tx_buf + hs_len_pos + 2, hs_len as i64);

    // Fill record length
    let record_len = pos - 5;
    write_byte_addr(tx_buf + record_len_pos, shr_u64(record_len as u64, 8) as i64);
    write_byte_addr(tx_buf + record_len_pos + 1, record_len as i64);

    // Update handshake hash with ClientHello (excluding record header)
    sha256_hash(tx_buf + 5, record_len, conn + TLS_OFF_HANDSHAKE_HASH);

    // Debug output
    serial_out(67);  // C
    serial_out(72);  // H
    serial_out(58);  // :
    serial_hex64(pos as u64);
    serial_newline();

    // Send
    syscall_net_send(socket, tx_buf, pos)
}

// Receive and parse ServerHello, Certificate, ServerHelloDone
fn tls_recv_server_hello(conn: i64, socket: i64) -> i64 {
    let rx_buf = conn + TLS_OFF_RX_BUF;

    // Receive data
    let recv_len = syscall_net_recv(socket, rx_buf, 4096);
    if recv_len <= 0 {
        serial_out(82);  // R
        serial_out(88);  // X
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        return -1;
    }

    serial_out(82);  // R
    serial_out(88);  // X
    serial_out(58);  // :
    serial_hex64(recv_len as u64);
    serial_newline();

    // Parse TLS records
    let mut offset: i64 = 0;
    while offset < recv_len {
        let content_type = read_byte_addr(rx_buf + offset);
        let version_major = read_byte_addr(rx_buf + offset + 1);
        let version_minor = read_byte_addr(rx_buf + offset + 2);
        let record_len = bit_or(shl_u64(read_byte_addr(rx_buf + offset + 3) as u64, 8), read_byte_addr(rx_buf + offset + 4) as u64) as i64;

        if content_type == 0x16 {  // Handshake
            let hs_type = read_byte_addr(rx_buf + offset + 5);
            let hs_len = bit_or(bit_or(shl_u64(read_byte_addr(rx_buf + offset + 6) as u64, 16),
                         shl_u64(read_byte_addr(rx_buf + offset + 7) as u64, 8)),
                          read_byte_addr(rx_buf + offset + 8) as u64) as i64;

            serial_out(72);  // H
            serial_out(83);  // S
            serial_out(58);  // :
            serial_hex64(hs_type as u64);
            serial_newline();

            if hs_type == 2 {  // ServerHello
                // Extract server random (starts at offset+11)
                let mut i: i64 = 0;
                while i < 32 {
                    write_byte_addr(conn + TLS_OFF_SERVER_RANDOM + i, read_byte_addr(rx_buf + offset + 11 + i));
                    i = i + 1;
                }

                serial_out(83);  // S
                serial_out(72);  // H
                serial_out(79);  // O
                serial_out(75);  // K
                serial_newline();
            }

            if hs_type == 11 {  // Certificate
                // Certificate message format:
                // - 3 bytes: handshake header (type + 3-byte length) - already parsed
                // - 3 bytes: total certificates length
                // - For each certificate:
                //   - 3 bytes: certificate length
                //   - N bytes: certificate DER data

                // Offset to certificate message content (after handshake type and length)
                let cert_msg_start = offset + 9;  // Skip record header (5) + hs type (1) + hs length (3)

                // Parse total certificates length (3 bytes big-endian)
                let total_certs_len = bit_or(bit_or(
                    shl_u64(read_byte_addr(rx_buf + cert_msg_start) as u64, 16),
                    shl_u64(read_byte_addr(rx_buf + cert_msg_start + 1) as u64, 8)),
                    read_byte_addr(rx_buf + cert_msg_start + 2) as u64) as i64;

                // First certificate starts at cert_msg_start + 3
                let first_cert_len_pos = cert_msg_start + 3;

                // Parse first certificate length (3 bytes big-endian)
                let first_cert_len = bit_or(bit_or(
                    shl_u64(read_byte_addr(rx_buf + first_cert_len_pos) as u64, 16),
                    shl_u64(read_byte_addr(rx_buf + first_cert_len_pos + 1) as u64, 8)),
                    read_byte_addr(rx_buf + first_cert_len_pos + 2) as u64) as i64;

                // First certificate DER data starts at first_cert_len_pos + 3
                let first_cert_addr = rx_buf + first_cert_len_pos + 3;

                serial_out(67);  // C
                serial_out(69);  // E
                serial_out(82);  // R
                serial_out(84);  // T
                serial_out(58);  // :
                serial_hex64(first_cert_len as u64);
                serial_newline();

                // Store certificate location for RSA key extraction
                write_u64_addr(conn + TLS_OFF_CERT_ADDR, first_cert_addr as u64);
                write_u64_addr(conn + TLS_OFF_CERT_LEN, first_cert_len as u64);
            }

            if hs_type == 14 {  // ServerHelloDone
                serial_out(68);  // D
                serial_out(79);  // O
                serial_out(78);  // N
                serial_out(69);  // E
                serial_newline();
                return 0;  // Handshake messages received
            }
        } else if content_type == 0x15 {  // Alert
            let alert_level = read_byte_addr(rx_buf + offset + 5);
            let alert_desc = read_byte_addr(rx_buf + offset + 6);
            serial_out(65);  // A
            serial_out(76);  // L
            serial_out(69);  // E
            serial_out(82);  // R
            serial_out(84);  // T
            serial_out(58);  // :
            serial_hex64(alert_desc as u64);
            serial_newline();
            return -2;
        }

        offset = offset + 5 + record_len;
    }

    0
}

// Generate premaster secret and send ClientKeyExchange
fn tls_send_client_key_exchange(conn: i64, socket: i64) -> i64 {
    let tx_buf = conn + TLS_OFF_TX_BUF;
    let mut pos: i64 = 0;

    // Generate 48-byte premaster secret
    // Format: 2 bytes version (0x0303) + 46 random bytes
    write_byte_addr(conn + TLS_OFF_PREMASTER, 0x03);
    write_byte_addr(conn + TLS_OFF_PREMASTER + 1, 0x03);

    // Generate "random" bytes (using timer ticks as entropy source)
    let time = read_u64_addr(TICK_COUNT_ADDR);
    let mut i: i64 = 2;
    while i < 48 {
        let r = bit_xor(time, ((i * 0xDEADBEEF) + (i * i * 0x1337)) as u64);
        write_byte_addr(conn + TLS_OFF_PREMASTER + i, bit_and(shr_u64(r, ((i % 8) * 8) as u64), 0xFF) as i64);
        i = i + 1;
    }

    // RSA key exchange: encrypt premaster with server's public key

    // 1. Get certificate from stored location
    let cert_addr = read_u64_addr(conn + TLS_OFF_CERT_ADDR) as i64;
    let cert_len = read_u64_addr(conn + TLS_OFF_CERT_LEN) as i64;

    if cert_addr == 0 || cert_len == 0 {
        serial_out(78);  // N
        serial_out(79);  // O
        serial_out(67);  // C
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(84);  // T
        serial_newline();
        return -1;
    }

    // 2. Extract RSA public key from certificate
    let n_addr = RSA_WORK_ADDR + 4608;      // Modulus (256 bytes)
    let n_len_addr = RSA_WORK_ADDR + 4864;  // Modulus length storage
    let e_addr = RSA_WORK_ADDR + 4872;      // Exponent storage

    let extract_result = x509_extract_rsa_pubkey(cert_addr, cert_len, n_addr, n_len_addr, e_addr);
    if extract_result < 0 {
        serial_out(88);  // X
        serial_out(53);  // 5
        serial_out(48);  // 0
        serial_out(57);  // 9
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_out(58);  // :
        serial_hex64((0 - extract_result) as u64);
        serial_newline();
        return -2;
    }

    let n_len = read_u64_addr(n_len_addr) as i64;
    let e = read_u64_addr(e_addr);

    serial_out(82);  // R
    serial_out(83);  // S
    serial_out(65);  // A
    serial_out(58);  // :
    serial_out(78);  // N
    serial_out(61);  // =
    serial_hex64(n_len as u64);
    serial_out(32);  // space
    serial_out(69);  // E
    serial_out(61);  // =
    serial_hex64(e);
    serial_newline();

    // 3. PKCS#1 v1.5 pad the premaster secret (48 bytes -> 256 bytes)
    let padded_addr = RSA_WORK_ADDR + 4880;
    pkcs1_pad(padded_addr, conn + TLS_OFF_PREMASTER, 48, 256);

    // 4. RSA encrypt: ciphertext = padded^e mod n
    let encrypted_addr = RSA_WORK_ADDR + 5136;
    rsa_encrypt(encrypted_addr, padded_addr, 256, n_addr, n_len, e);

    serial_out(69);  // E
    serial_out(78);  // N
    serial_out(67);  // C
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Build ClientKeyExchange message with encrypted premaster

    // TLS Record header
    write_byte_addr(tx_buf + pos, 0x16);  // Handshake
    pos = pos + 1;
    write_byte_addr(tx_buf + pos, 0x03);
    write_byte_addr(tx_buf + pos + 1, 0x03);  // TLS 1.2
    pos = pos + 2;
    let record_len_pos = pos;
    pos = pos + 2;

    // ClientKeyExchange
    write_byte_addr(tx_buf + pos, 16);  // ClientKeyExchange type
    pos = pos + 1;

    // Handshake length (3 bytes) = encrypted premaster length (256) + 2 byte length prefix
    let hs_len: i64 = 256 + 2;
    write_byte_addr(tx_buf + pos, 0);
    write_byte_addr(tx_buf + pos + 1, shr_u64(hs_len as u64, 8) as i64);
    write_byte_addr(tx_buf + pos + 2, hs_len as i64);
    pos = pos + 3;

    // Encrypted premaster length (2 bytes) = 256 for 2048-bit RSA
    write_byte_addr(tx_buf + pos, 1);   // 256 >> 8 = 1
    write_byte_addr(tx_buf + pos + 1, 0);  // 256 & 0xFF = 0
    pos = pos + 2;

    // Encrypted premaster (256 bytes)
    i = 0;
    while i < 256 {
        write_byte_addr(tx_buf + pos + i, read_byte_addr(encrypted_addr + i));
        i = i + 1;
    }
    pos = pos + 256;

    // Fill record length
    let record_len = pos - 5;
    write_byte_addr(tx_buf + record_len_pos, shr_u64(record_len as u64, 8) as i64);
    write_byte_addr(tx_buf + record_len_pos + 1, record_len as i64);

    serial_out(67);  // C
    serial_out(75);  // K
    serial_out(69);  // E
    serial_out(58);  // :
    serial_hex64(pos as u64);
    serial_newline();

    syscall_net_send(socket, tx_buf, pos)
}

// Derive keys from master secret
fn tls_derive_keys(conn: i64) {
    // master_secret = PRF(premaster_secret, "master secret", client_random + server_random)
    let label_addr = conn + TLS_OFF_TX_BUF + 1024;
    // "master secret" = 13 bytes
    write_byte_addr(label_addr, 109);      // m
    write_byte_addr(label_addr + 1, 97);   // a
    write_byte_addr(label_addr + 2, 115);  // s
    write_byte_addr(label_addr + 3, 116);  // t
    write_byte_addr(label_addr + 4, 101);  // e
    write_byte_addr(label_addr + 5, 114);  // r
    write_byte_addr(label_addr + 6, 32);   // (space)
    write_byte_addr(label_addr + 7, 115);  // s
    write_byte_addr(label_addr + 8, 101);  // e
    write_byte_addr(label_addr + 9, 99);   // c
    write_byte_addr(label_addr + 10, 114); // r
    write_byte_addr(label_addr + 11, 101); // e
    write_byte_addr(label_addr + 12, 116); // t

    // seed = client_random + server_random (64 bytes)
    let seed_addr = label_addr + 64;
    let mut i: i64 = 0;
    while i < 32 {
        write_byte_addr(seed_addr + i, read_byte_addr(conn + TLS_OFF_CLIENT_RANDOM + i));
        write_byte_addr(seed_addr + 32 + i, read_byte_addr(conn + TLS_OFF_SERVER_RANDOM + i));
        i = i + 1;
    }

    // Generate master secret (48 bytes)
    tls_prf(conn + TLS_OFF_PREMASTER, 48, label_addr, 13, seed_addr, 64, conn + TLS_OFF_MASTER_SECRET, 48);

    serial_out(77);  // M
    serial_out(83);  // S
    serial_out(58);  // :
    serial_hex64(read_byte_addr(conn + TLS_OFF_MASTER_SECRET) as u64);
    serial_newline();

    // key_block = PRF(master_secret, "key expansion", server_random + client_random)
    // "key expansion" = 13 bytes
    write_byte_addr(label_addr, 107);      // k
    write_byte_addr(label_addr + 1, 101);  // e
    write_byte_addr(label_addr + 2, 121);  // y
    write_byte_addr(label_addr + 3, 32);   // (space)
    write_byte_addr(label_addr + 4, 101);  // e
    write_byte_addr(label_addr + 5, 120);  // x
    write_byte_addr(label_addr + 6, 112);  // p
    write_byte_addr(label_addr + 7, 97);   // a
    write_byte_addr(label_addr + 8, 110);  // n
    write_byte_addr(label_addr + 9, 115);  // s
    write_byte_addr(label_addr + 10, 105); // i
    write_byte_addr(label_addr + 11, 111); // o
    write_byte_addr(label_addr + 12, 110); // n

    // seed = server_random + client_random
    i = 0;
    while i < 32 {
        write_byte_addr(seed_addr + i, read_byte_addr(conn + TLS_OFF_SERVER_RANDOM + i));
        write_byte_addr(seed_addr + 32 + i, read_byte_addr(conn + TLS_OFF_CLIENT_RANDOM + i));
        i = i + 1;
    }

    // For AES-128-GCM-SHA256:
    // client_write_key (16) + server_write_key (16) + client_write_IV (4) + server_write_IV (4) = 40 bytes
    let key_block_addr = conn + TLS_OFF_TX_BUF + 1280;
    tls_prf(conn + TLS_OFF_MASTER_SECRET, 48, label_addr, 13, seed_addr, 64, key_block_addr, 40);

    // Expand client write key for AES
    aes_key_expand(key_block_addr, conn + TLS_OFF_AES_KEYS);
    // Expand server write key for AES
    aes_key_expand(key_block_addr + 16, conn + TLS_OFF_AES_KEYS + 176);

    // Store IVs
    i = 0;
    while i < 4 {
        write_byte_addr(conn + TLS_OFF_AES_KEYS + 352 + i, read_byte_addr(key_block_addr + 32 + i));  // Client IV
        write_byte_addr(conn + TLS_OFF_AES_KEYS + 356 + i, read_byte_addr(key_block_addr + 36 + i));  // Server IV
        i = i + 1;
    }

    serial_out(75);  // K
    serial_out(69);  // E
    serial_out(89);  // Y
    serial_out(83);  // S
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

// Send ChangeCipherSpec and Finished
fn tls_send_finished(conn: i64, socket: i64) -> i64 {
    let tx_buf = conn + TLS_OFF_TX_BUF;
    let mut pos: i64 = 0;

    // ChangeCipherSpec record
    write_byte_addr(tx_buf + pos, 0x14);  // ChangeCipherSpec
    pos = pos + 1;
    write_byte_addr(tx_buf + pos, 0x03);
    write_byte_addr(tx_buf + pos + 1, 0x03);
    pos = pos + 2;
    write_byte_addr(tx_buf + pos, 0);
    write_byte_addr(tx_buf + pos + 1, 1);  // Length = 1
    pos = pos + 2;
    write_byte_addr(tx_buf + pos, 1);  // CCS message
    pos = pos + 1;

    // Now encrypted Finished message
    // verify_data = PRF(master_secret, "client finished", hash(handshake_messages))

    let label_addr = conn + TLS_OFF_TX_BUF + 1024;
    // "client finished" = 15 bytes
    write_byte_addr(label_addr, 99);       // c
    write_byte_addr(label_addr + 1, 108);  // l
    write_byte_addr(label_addr + 2, 105);  // i
    write_byte_addr(label_addr + 3, 101);  // e
    write_byte_addr(label_addr + 4, 110);  // n
    write_byte_addr(label_addr + 5, 116);  // t
    write_byte_addr(label_addr + 6, 32);   // (space)
    write_byte_addr(label_addr + 7, 102);  // f
    write_byte_addr(label_addr + 8, 105);  // i
    write_byte_addr(label_addr + 9, 110);  // n
    write_byte_addr(label_addr + 10, 105); // i
    write_byte_addr(label_addr + 11, 115); // s
    write_byte_addr(label_addr + 12, 104); // h
    write_byte_addr(label_addr + 13, 101); // e
    write_byte_addr(label_addr + 14, 100); // d

    // Generate verify_data (12 bytes)
    let verify_data_addr = label_addr + 128;
    tls_prf(conn + TLS_OFF_MASTER_SECRET, 48, label_addr, 15, conn + TLS_OFF_HANDSHAKE_HASH, 32, verify_data_addr, 12);

    // Build Finished message (unencrypted form)
    let finished_msg_addr = verify_data_addr + 64;
    write_byte_addr(finished_msg_addr, 20);  // Finished type
    write_byte_addr(finished_msg_addr + 1, 0);
    write_byte_addr(finished_msg_addr + 2, 0);
    write_byte_addr(finished_msg_addr + 3, 12);  // Length
    let mut i: i64 = 0;
    while i < 12 {
        write_byte_addr(finished_msg_addr + 4 + i, read_byte_addr(verify_data_addr + i));
        i = i + 1;
    }

    // Build IV for encryption (implicit IV + explicit nonce)
    let iv_addr = finished_msg_addr + 32;
    // First 4 bytes from client_write_IV
    i = 0;
    while i < 4 {
        write_byte_addr(iv_addr + i, read_byte_addr(conn + TLS_OFF_AES_KEYS + 352 + i));
        i = i + 1;
    }
    // Next 8 bytes: sequence number (starts at 0)
    i = 4;
    while i < 12 {
        write_byte_addr(iv_addr + i, 0);
        i = i + 1;
    }

    // Build AAD for GCM (8-byte seq + record header)
    let aad_addr = iv_addr + 16;
    // Sequence number (8 bytes, all zeros for first record)
    i = 0;
    while i < 8 {
        write_byte_addr(aad_addr + i, 0);
        i = i + 1;
    }
    // Record type
    write_byte_addr(aad_addr + 8, 0x16);  // Handshake
    // Version
    write_byte_addr(aad_addr + 9, 0x03);
    write_byte_addr(aad_addr + 10, 0x03);
    // Length of plaintext
    write_byte_addr(aad_addr + 11, 0);
    write_byte_addr(aad_addr + 12, 16);

    // Encrypt with AES-GCM
    let ciphertext_addr = aad_addr + 32;
    let tag_addr = ciphertext_addr + 16;
    aes_gcm_encrypt(iv_addr, finished_msg_addr, 16, aad_addr, 13, ciphertext_addr, tag_addr, conn + TLS_OFF_AES_KEYS);

    // Build encrypted Finished record
    // Record header
    write_byte_addr(tx_buf + pos, 0x16);  // Handshake
    pos = pos + 1;
    write_byte_addr(tx_buf + pos, 0x03);
    write_byte_addr(tx_buf + pos + 1, 0x03);
    pos = pos + 2;
    // Length = 8 (explicit nonce) + 16 (ciphertext) + 16 (tag) = 40
    write_byte_addr(tx_buf + pos, 0);
    write_byte_addr(tx_buf + pos + 1, 40);
    pos = pos + 2;

    // Explicit nonce (8 bytes from IV[4..12])
    i = 0;
    while i < 8 {
        write_byte_addr(tx_buf + pos + i, read_byte_addr(iv_addr + 4 + i));
        i = i + 1;
    }
    pos = pos + 8;

    // Ciphertext
    i = 0;
    while i < 16 {
        write_byte_addr(tx_buf + pos + i, read_byte_addr(ciphertext_addr + i));
        i = i + 1;
    }
    pos = pos + 16;

    // Tag
    i = 0;
    while i < 16 {
        write_byte_addr(tx_buf + pos + i, read_byte_addr(tag_addr + i));
        i = i + 1;
    }
    pos = pos + 16;

    serial_out(70);  // F
    serial_out(73);  // I
    serial_out(78);  // N
    serial_out(58);  // :
    serial_hex64(pos as u64);
    serial_newline();

    syscall_net_send(socket, tx_buf, pos)
}

// Receive server's ChangeCipherSpec and Finished
fn tls_recv_server_finished(conn: i64, socket: i64) -> i64 {
    let rx_buf = conn + TLS_OFF_RX_BUF;

    let recv_len = syscall_net_recv(socket, rx_buf, 4096);
    if recv_len <= 0 {
        return -1;
    }

    serial_out(83);  // S
    serial_out(70);  // F
    serial_out(73);  // I
    serial_out(78);  // N
    serial_out(58);  // :
    serial_hex64(recv_len as u64);
    serial_newline();

    // Parse and verify server's Finished
    // For now, just accept it (TODO: proper verification)

    0
}

// ============================================================
// TLS Syscall Handlers (Stubs - Full implementation needed)
// ============================================================

// SYS_TLS_CONNECT - Perform TLS handshake on socket
fn syscall_tls_connect(socket: i64, hostname_addr: i64, hostname_len: i64) -> i64 {
    // Allocate connection
    let conn = tls_alloc_conn(socket);
    if conn < 0 {
        return -1;  // No free connections
    }

    serial_out(84);  // T
    serial_out(76);  // L
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(83);  // S
    serial_out(84);  // T
    serial_out(65);  // A
    serial_out(82);  // R
    serial_out(84);  // T
    serial_newline();

    // Copy hostname
    let mut i: i64 = 0;
    while i < hostname_len && i < 127 {
        write_byte_addr(conn + TLS_OFF_HOSTNAME + i, read_byte_addr(hostname_addr + i));
        i = i + 1;
    }
    write_byte_addr(conn + TLS_OFF_HOSTNAME + i, 0);
    write_u64_addr(conn + TLS_OFF_HOSTNAME_LEN, hostname_len as u64);

    // Generate client random (32 bytes) using RDRAND if available, fallback to timer
    let time = read_u64_addr(TICK_COUNT_ADDR);
    i = 0;
    while i < 32 {
        // Mix multiple entropy sources
        let shift1 = (i % 8) as u64;
        let shift2 = ((i % 8) * 4) as u64;
        let entropy1 = bit_xor(time, ((i + 1) * 0x5DEECE66D) as u64);
        let shifted_time = shr_u64(time, shift1);
        let entropy2 = bit_xor(entropy1, shifted_time * 0xB);
        let r = bit_xor(entropy2, ((i * i * 0x1337CAFE) as u64 + entropy1));
        write_byte_addr(conn + TLS_OFF_CLIENT_RANDOM + i, bit_and(shr_u64(r, shift2), 0xFF) as i64);
        i = i + 1;
    }

    // Set handshake state
    write_byte_addr(conn + TLS_OFF_STATE, TLS_STATE_HANDSHAKE);

    // Step 1: Send ClientHello
    let result = tls_send_client_hello(conn, socket);
    if result < 0 {
        serial_out(67);  // C
        serial_out(72);  // H
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        tls_free_conn(conn);
        return -2;
    }

    // Step 2: Receive ServerHello, Certificate, ServerHelloDone
    let result = tls_recv_server_hello(conn, socket);
    if result < 0 {
        serial_out(83);  // S
        serial_out(72);  // H
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        tls_free_conn(conn);
        return -3;
    }

    // Step 3: Send ClientKeyExchange
    let result = tls_send_client_key_exchange(conn, socket);
    if result < 0 {
        serial_out(67);  // C
        serial_out(75);  // K
        serial_out(69);  // E
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        tls_free_conn(conn);
        return -4;
    }

    // Step 4: Derive encryption keys
    tls_derive_keys(conn);

    // Step 5: Send ChangeCipherSpec and Finished
    let result = tls_send_finished(conn, socket);
    if result < 0 {
        serial_out(70);  // F
        serial_out(73);  // I
        serial_out(78);  // N
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        tls_free_conn(conn);
        return -5;
    }

    // Step 6: Receive server's ChangeCipherSpec and Finished
    let result = tls_recv_server_finished(conn, socket);
    if result < 0 {
        serial_out(83);  // S
        serial_out(70);  // F
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        tls_free_conn(conn);
        return -6;
    }

    // Handshake complete
    write_byte_addr(conn + TLS_OFF_STATE, TLS_STATE_CONNECTED);

    serial_out(84);  // T
    serial_out(76);  // L
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    0
}

// Increment 64-bit sequence number
fn tls_inc_seq(seq_addr: i64) {
    let mut i: i64 = 7;
    while i >= 0 {
        let b = read_byte_addr(seq_addr + i);
        if b < 255 {
            write_byte_addr(seq_addr + i, b + 1);
            return;
        }
        write_byte_addr(seq_addr + i, 0);
        i = i - 1;
    }
}

// SYS_TLS_SEND - Send encrypted data
fn syscall_tls_send(socket: i64, data_addr: i64, data_len: i64) -> i64 {
    let conn = tls_get_conn(socket);
    if conn < 0 {
        return -1;  // No TLS connection
    }

    let state = read_byte_addr(conn + TLS_OFF_STATE);
    if state != TLS_STATE_CONNECTED {
        return -2;  // Not connected
    }

    let tx_buf = conn + TLS_OFF_TX_BUF;
    let work_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE + 10000;

    // Build IV: implicit IV (4 bytes) + explicit nonce (8 bytes from seq number)
    let iv_addr = work_addr;
    let mut i: i64 = 0;
    while i < 4 {
        write_byte_addr(iv_addr + i, read_byte_addr(conn + TLS_OFF_AES_KEYS + 352 + i));
        i = i + 1;
    }
    // Use sequence number as explicit nonce
    i = 0;
    while i < 8 {
        write_byte_addr(iv_addr + 4 + i, read_byte_addr(conn + TLS_OFF_CLIENT_SEQ + i));
        i = i + 1;
    }

    // Build AAD: seq_num (8) + content_type (1) + version (2) + length (2)
    let aad_addr = work_addr + 16;
    i = 0;
    while i < 8 {
        write_byte_addr(aad_addr + i, read_byte_addr(conn + TLS_OFF_CLIENT_SEQ + i));
        i = i + 1;
    }
    write_byte_addr(aad_addr + 8, 0x17);   // Application data
    write_byte_addr(aad_addr + 9, 0x03);   // TLS 1.2
    write_byte_addr(aad_addr + 10, 0x03);
    write_byte_addr(aad_addr + 11, shr_u64(data_len as u64, 8) as i64);
    write_byte_addr(aad_addr + 12, data_len as i64);

    // Encrypt
    let ciphertext_addr = work_addr + 32;
    let tag_addr = ciphertext_addr + data_len + 16;
    aes_gcm_encrypt(iv_addr, data_addr, data_len, aad_addr, 13, ciphertext_addr, tag_addr, conn + TLS_OFF_AES_KEYS);

    // Build TLS record
    let mut pos: i64 = 0;
    write_byte_addr(tx_buf + pos, 0x17);  // Application data
    pos = pos + 1;
    write_byte_addr(tx_buf + pos, 0x03);
    write_byte_addr(tx_buf + pos + 1, 0x03);
    pos = pos + 2;

    // Length = 8 (explicit nonce) + ciphertext_len + 16 (tag)
    let record_len = 8 + data_len + 16;
    write_byte_addr(tx_buf + pos, shr_u64(record_len as u64, 8) as i64);
    write_byte_addr(tx_buf + pos + 1, record_len as i64);
    pos = pos + 2;

    // Explicit nonce (8 bytes from sequence number)
    i = 0;
    while i < 8 {
        write_byte_addr(tx_buf + pos + i, read_byte_addr(conn + TLS_OFF_CLIENT_SEQ + i));
        i = i + 1;
    }
    pos = pos + 8;

    // Ciphertext
    i = 0;
    while i < data_len {
        write_byte_addr(tx_buf + pos + i, read_byte_addr(ciphertext_addr + i));
        i = i + 1;
    }
    pos = pos + data_len;

    // Tag
    i = 0;
    while i < 16 {
        write_byte_addr(tx_buf + pos + i, read_byte_addr(tag_addr + i));
        i = i + 1;
    }
    pos = pos + 16;

    // Increment sequence number
    tls_inc_seq(conn + TLS_OFF_CLIENT_SEQ);

    // Send
    let sent = syscall_net_send(socket, tx_buf, pos);
    if sent > 0 {
        return data_len;  // Return plaintext length
    }
    sent
}

// SYS_TLS_RECV - Receive and decrypt data
fn syscall_tls_recv(socket: i64, data_addr: i64, max_len: i64) -> i64 {
    let conn = tls_get_conn(socket);
    if conn < 0 {
        return -1;  // No TLS connection
    }

    let state = read_byte_addr(conn + TLS_OFF_STATE);
    if state != TLS_STATE_CONNECTED {
        return -2;  // Not connected
    }

    let rx_buf = conn + TLS_OFF_RX_BUF;
    let work_addr = TLS_STATE_BASE + TLS_MAX_CONNECTIONS * TLS_CONN_SIZE + 10000;

    // Receive TLS record
    let recv_len = syscall_net_recv(socket, rx_buf, 4096);
    if recv_len <= 0 {
        return recv_len;
    }

    // Parse TLS record header
    let content_type = read_byte_addr(rx_buf);
    let version_major = read_byte_addr(rx_buf + 1);
    let version_minor = read_byte_addr(rx_buf + 2);
    let record_len = bit_or(shl_u64(read_byte_addr(rx_buf + 3) as u64, 8), read_byte_addr(rx_buf + 4) as u64) as i64;

    if content_type == 0x15 {  // Alert
        let alert_level = read_byte_addr(rx_buf + 5);
        let alert_desc = read_byte_addr(rx_buf + 6);
        serial_out(65);  // A
        serial_out(76);  // L
        serial_out(82);  // R
        serial_out(84);  // T
        serial_out(58);  // :
        serial_hex64(alert_desc as u64);
        serial_newline();
        return -3;
    }

    if content_type != 0x17 {  // Not application data
        return -4;
    }

    // Extract explicit nonce (8 bytes) and build IV
    let iv_addr = work_addr;
    let mut i: i64 = 0;
    while i < 4 {
        write_byte_addr(iv_addr + i, read_byte_addr(conn + TLS_OFF_AES_KEYS + 356 + i));  // Server IV
        i = i + 1;
    }
    i = 0;
    while i < 8 {
        write_byte_addr(iv_addr + 4 + i, read_byte_addr(rx_buf + 5 + i));  // Explicit nonce
        i = i + 1;
    }

    // Ciphertext starts after header (5) + explicit nonce (8)
    let ciphertext_addr = rx_buf + 13;
    let ciphertext_len = record_len - 8 - 16;  // Subtract nonce and tag

    // Tag is at the end
    let tag_addr = rx_buf + 5 + record_len - 16;

    // Build AAD
    let aad_addr = work_addr + 16;
    i = 0;
    while i < 8 {
        write_byte_addr(aad_addr + i, read_byte_addr(conn + TLS_OFF_SERVER_SEQ + i));
        i = i + 1;
    }
    write_byte_addr(aad_addr + 8, 0x17);
    write_byte_addr(aad_addr + 9, 0x03);
    write_byte_addr(aad_addr + 10, 0x03);
    write_byte_addr(aad_addr + 11, shr_u64(ciphertext_len as u64, 8) as i64);
    write_byte_addr(aad_addr + 12, ciphertext_len as i64);

    // Decrypt
    let plaintext_addr = work_addr + 32;
    let result = aes_gcm_decrypt(iv_addr, ciphertext_addr, ciphertext_len, aad_addr, 13, plaintext_addr, tag_addr, conn + TLS_OFF_AES_KEYS + 176);

    if result < 0 {
        serial_out(68);  // D
        serial_out(69);  // E
        serial_out(67);  // C
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        return -5;  // Decryption failed
    }

    // Increment server sequence number
    tls_inc_seq(conn + TLS_OFF_SERVER_SEQ);

    // Copy to output buffer
    let copy_len = if ciphertext_len < max_len { ciphertext_len } else { max_len };
    i = 0;
    while i < copy_len {
        write_byte_addr(data_addr + i, read_byte_addr(plaintext_addr + i));
        i = i + 1;
    }

    copy_len
}

// SYS_TLS_CLOSE - Close TLS connection
fn syscall_tls_close(socket: i64) -> i64 {
    let conn = tls_get_conn(socket);
    if conn < 0 {
        return 0;  // Already closed
    }

    // TODO: Send close_notify alert

    tls_free_conn(conn);
    0
}

// ============================================================
// Graphics Syscalls (Hello Graphics)
// ============================================================

const FB_STATE_BASE_SYS: i64 = 0x4C1000;
const FB_GFX_STATE_ADDR_SYS: i64 = 0x4C2000;

fn syscall_fb_info(which: i64) -> i64 {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        return 0;
    }

    if which == 0 {
        let ptr = (FB_GFX_STATE_ADDR_SYS + 16) as *u32;
        unsafe {
            volatile_read_u32(ptr) as i64
        }
    } else if which == 1 {
        let ptr = (FB_GFX_STATE_ADDR_SYS + 20) as *u32;
        unsafe {
            volatile_read_u32(ptr) as i64
        }
    } else {
        0
    }
}

const BACK_BUFFER_ADDR_SYS: i64 = 0x02000000;

fn syscall_fb_pixel(x: i64, y: i64, color: i64) -> i64 {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        return -1;
    }

    let width_ptr = (FB_GFX_STATE_ADDR_SYS + 16) as *u32;
    let height_ptr = (FB_GFX_STATE_ADDR_SYS + 20) as *u32;
    let pitch_ptr = (FB_GFX_STATE_ADDR_SYS + 24) as *u32;
    let width: i64;
    let height: i64;
    let pitch: i64;
    unsafe {
        width = volatile_read_u32(width_ptr) as i64;
        height = volatile_read_u32(height_ptr) as i64;
        pitch = volatile_read_u32(pitch_ptr) as i64;
    }

    if x < 0 || x >= width || y < 0 || y >= height {
        return -1;
    }

    // Convert color from RGB to BGR
    // Use division instead of shift to avoid parser issues
    let b = color & 0xFF;
    let g = (color / 256) & 0xFF;
    let r = (color / 65536) & 0xFF;
    let g_shifted = g * 256;
    let r_shifted = r * 65536;
    let pixel = b | g_shifted | r_shifted;

    let offset = y * pitch + x * 4;
    let addr = (BACK_BUFFER_ADDR_SYS + offset) as *mut u32;
    unsafe {
        volatile_write_u32(addr, pixel as u32);
    }
    0
}

fn syscall_fb_rect(x: i64, y: i64, w: i64, h: i64, color: i64) -> i64 {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        return -1;
    }

    let width_ptr = (FB_GFX_STATE_ADDR_SYS + 16) as *u32;
    let height_ptr = (FB_GFX_STATE_ADDR_SYS + 20) as *u32;
    let pitch_ptr = (FB_GFX_STATE_ADDR_SYS + 24) as *u32;
    let screen_width: i64;
    let screen_height: i64;
    let pitch: i64;
    unsafe {
        screen_width = volatile_read_u32(width_ptr) as i64;
        screen_height = volatile_read_u32(height_ptr) as i64;
        pitch = volatile_read_u32(pitch_ptr) as i64;
    }

    // Clamp coordinates
    let x0 = if x < 0 { 0 } else { x };
    let y0 = if y < 0 { 0 } else { y };
    let x1 = if x + w > screen_width { screen_width } else { x + w };
    let y1 = if y + h > screen_height { screen_height } else { y + h };

    if x0 >= x1 || y0 >= y1 {
        return -1;
    }

    // Convert color
    let b = color & 0xFF;
    let g = (color / 256) & 0xFF;
    let r = (color / 65536) & 0xFF;
    let g_shifted = g * 256;
    let r_shifted = r * 65536;
    let pixel_tmp = b | g_shifted | r_shifted;
    let pixel = pixel_tmp as u32;

    // Fill rectangle
    let mut py = y0;
    while py < y1 {
        let row_addr = BACK_BUFFER_ADDR_SYS + py * pitch;
        let mut px = x0;
        while px < x1 {
            let addr = (row_addr + px * 4) as *mut u32;
            unsafe {
                volatile_write_u32(addr, pixel);
            }
            px = px + 1;
        }
        py = py + 1;
    }
    0
}

fn syscall_fb_clear(color: i64) -> i64 {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        return -1;
    }

    let width_ptr = (FB_GFX_STATE_ADDR_SYS + 16) as *u32;
    let height_ptr = (FB_GFX_STATE_ADDR_SYS + 20) as *u32;
    let pitch_ptr = (FB_GFX_STATE_ADDR_SYS + 24) as *u32;
    let width: i64;
    let height: i64;
    let pitch: i64;
    unsafe {
        width = volatile_read_u32(width_ptr) as i64;
        height = volatile_read_u32(height_ptr) as i64;
        pitch = volatile_read_u32(pitch_ptr) as i64;
    }

    // Convert color from RGB to BGR
    let b = color & 0xFF;
    let g_div = color / 256;
    let g = g_div & 0xFF;
    let r_div = color / 65536;
    let r = r_div & 0xFF;
    let g_shifted = g * 256;
    let r_shifted = r * 65536;
    let pixel_tmp = b + g_shifted + r_shifted;
    let pixel = pixel_tmp as u32;

    // Create 64-bit value with two pixels for rep stosq
    let pixel64 = (pixel as u64) + ((pixel as u64) * 0x100000000);
    let total_qwords = (width * height) / 2;
    let dst = BACK_BUFFER_ADDR_SYS;

    // Use rep stosq for fast fill (2 pixels at a time)
    unsafe {
        asm!(
            "rep stosq",
            in("rdi") dst,
            in("rax") pixel64,
            in("rcx") total_qwords,
            options(nostack, att_syntax)
        );
    }
    0
}

fn syscall_fb_swap() -> i64 {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        return -1;
    }

    let fb_addr_ptr = (FB_GFX_STATE_ADDR_SYS + 8) as *u64;
    let height_ptr = (FB_GFX_STATE_ADDR_SYS + 20) as *u32;
    let pitch_ptr = (FB_GFX_STATE_ADDR_SYS + 24) as *u32;
    let fb_addr: i64;
    let height: i64;
    let pitch: i64;
    unsafe {
        fb_addr = volatile_read_u64(fb_addr_ptr) as i64;
        height = volatile_read_u32(height_ptr) as i64;
        pitch = volatile_read_u32(pitch_ptr) as i64;
    }

    let total_size = pitch * height;
    let total_qwords = total_size / 8;
    let src = BACK_BUFFER_ADDR_SYS;
    let dst = fb_addr;

    // Use rep movsq for fast copy
    unsafe {
        asm!(
            "rep movsq",
            in("rsi") src,
            in("rdi") dst,
            in("rcx") total_qwords,
            options(nostack, att_syntax)
        );
    }
    0
}

// SYS_FB_BLIT - Copy pixel data to back buffer
// src: source address of pixel data (BGRA format)
// x, y: destination position
// w, h: dimensions
fn syscall_fb_blit(src: i64, x: i64, y: i64, w: i64, h: i64) -> i64 {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        return -1;
    }

    let width_ptr = (FB_GFX_STATE_ADDR_SYS + 16) as *u32;
    let height_ptr = (FB_GFX_STATE_ADDR_SYS + 20) as *u32;
    let pitch_ptr = (FB_GFX_STATE_ADDR_SYS + 24) as *u32;
    let screen_width: i64;
    let screen_height: i64;
    let pitch: i64;
    unsafe {
        screen_width = volatile_read_u32(width_ptr) as i64;
        screen_height = volatile_read_u32(height_ptr) as i64;
        pitch = volatile_read_u32(pitch_ptr) as i64;
    }

    // Bounds check
    if x < 0 || y < 0 || w <= 0 || h <= 0 {
        return -1;
    }
    if x + w > screen_width || y + h > screen_height {
        return -1;
    }

    // Copy row by row
    let src_stride = w * 4;
    let mut row: i64 = 0;
    while row < h {
        let src_row = src + row * src_stride;
        let dst_row = BACK_BUFFER_ADDR_SYS + (y + row) * pitch + x * 4;
        let qwords = w / 2;

        // Use rep movsq for fast copy
        if qwords > 0 {
            unsafe {
                asm!(
                    "rep movsq",
                    in("rsi") src_row,
                    in("rdi") dst_row,
                    in("rcx") qwords,
                    options(nostack, att_syntax)
                );
            }
        }
        row = row + 1;
    }
    0
}

// SYS_FB_MAP - Get framebuffer info for direct access
// Returns: back buffer physical address
fn syscall_fb_map() -> i64 {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        return 0;
    }
    BACK_BUFFER_ADDR_SYS
}

// ============================================================
// Bitmap Font 8x16 for Text Rendering
// ============================================================

// Font data stored at this address (initialized by font_init)
const FONT_DATA_ADDR: i64 = 0x4C3000;
const FONT_WIDTH: i64 = 8;
const FONT_HEIGHT: i64 = 16;
const FONT_FIRST_CHAR: i64 = 32;   // Space
const FONT_LAST_CHAR: i64 = 126;   // Tilde

// Initialize bitmap font data (8x16 VGA-style font)
fn font_init() {
    let base = FONT_DATA_ADDR;

    // Each character is 16 bytes (16 rows of 8 pixels)
    // Characters 32-126 (95 characters total)

    // Space (32) - all zeros
    font_set_char(base, 0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // ! (33)
    font_set_char(base, 1, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00);

    // " (34)
    font_set_char(base, 2, 0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // # (35)
    font_set_char(base, 3, 0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00);

    // $ (36)
    font_set_char(base, 4, 0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00);

    // % (37)
    font_set_char(base, 5, 0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00);

    // & (38)
    font_set_char(base, 6, 0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00);

    // ' (39)
    font_set_char(base, 7, 0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // ( (40)
    font_set_char(base, 8, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00);

    // ) (41)
    font_set_char(base, 9, 0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00);

    // * (42)
    font_set_char(base, 10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // + (43)
    font_set_char(base, 11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // , (44)
    font_set_char(base, 12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00);

    // - (45)
    font_set_char(base, 13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // . (46)
    font_set_char(base, 14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00);

    // / (47)
    font_set_char(base, 15, 0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00);

    // 0 (48)
    font_set_char(base, 16, 0x00, 0x00, 0x3C, 0x66, 0xC3, 0xC3, 0xDB, 0xDB, 0xC3, 0xC3, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00);

    // 1 (49)
    font_set_char(base, 17, 0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00);

    // 2 (50)
    font_set_char(base, 18, 0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00);

    // 3 (51)
    font_set_char(base, 19, 0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // 4 (52)
    font_set_char(base, 20, 0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00);

    // 5 (53)
    font_set_char(base, 21, 0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // 6 (54)
    font_set_char(base, 22, 0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // 7 (55)
    font_set_char(base, 23, 0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00);

    // 8 (56)
    font_set_char(base, 24, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // 9 (57)
    font_set_char(base, 25, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00);

    // : (58)
    font_set_char(base, 26, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00);

    // ; (59)
    font_set_char(base, 27, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00);

    // < (60)
    font_set_char(base, 28, 0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00);

    // = (61)
    font_set_char(base, 29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // > (62)
    font_set_char(base, 30, 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00);

    // ? (63)
    font_set_char(base, 31, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00);

    // @ (64)
    font_set_char(base, 32, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // A (65)
    font_set_char(base, 33, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00);

    // B (66)
    font_set_char(base, 34, 0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00);

    // C (67)
    font_set_char(base, 35, 0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00);

    // D (68)
    font_set_char(base, 36, 0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00);

    // E (69)
    font_set_char(base, 37, 0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00);

    // F (70)
    font_set_char(base, 38, 0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00);

    // G (71)
    font_set_char(base, 39, 0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00);

    // H (72)
    font_set_char(base, 40, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00);

    // I (73)
    font_set_char(base, 41, 0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00);

    // J (74)
    font_set_char(base, 42, 0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00);

    // K (75)
    font_set_char(base, 43, 0x00, 0x00, 0xE6, 0x66, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00);

    // L (76)
    font_set_char(base, 44, 0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00);

    // M (77)
    font_set_char(base, 45, 0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00);

    // N (78)
    font_set_char(base, 46, 0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00);

    // O (79)
    font_set_char(base, 47, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // P (80)
    font_set_char(base, 48, 0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00);

    // Q (81)
    font_set_char(base, 49, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00);

    // R (82)
    font_set_char(base, 50, 0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00);

    // S (83)
    font_set_char(base, 51, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // T (84)
    font_set_char(base, 52, 0x00, 0x00, 0xFF, 0xDB, 0x99, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00);

    // U (85)
    font_set_char(base, 53, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // V (86)
    font_set_char(base, 54, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00);

    // W (87)
    font_set_char(base, 55, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0xEE, 0x6C, 0x00, 0x00, 0x00, 0x00);

    // X (88)
    font_set_char(base, 56, 0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x7C, 0x38, 0x38, 0x7C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00);

    // Y (89)
    font_set_char(base, 57, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00);

    // Z (90)
    font_set_char(base, 58, 0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00);

    // [ (91)
    font_set_char(base, 59, 0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00);

    // \ (92)
    font_set_char(base, 60, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00);

    // ] (93)
    font_set_char(base, 61, 0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00);

    // ^ (94)
    font_set_char(base, 62, 0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // _ (95)
    font_set_char(base, 63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00);

    // ` (96)
    font_set_char(base, 64, 0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);

    // a (97)
    font_set_char(base, 65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00);

    // b (98)
    font_set_char(base, 66, 0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // c (99)
    font_set_char(base, 67, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // d (100)
    font_set_char(base, 68, 0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00);

    // e (101)
    font_set_char(base, 69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // f (102)
    font_set_char(base, 70, 0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00);

    // g (103)
    font_set_char(base, 71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00);

    // h (104)
    font_set_char(base, 72, 0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00);

    // i (105)
    font_set_char(base, 73, 0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00);

    // j (106)
    font_set_char(base, 74, 0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00);

    // k (107)
    font_set_char(base, 75, 0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00);

    // l (108)
    font_set_char(base, 76, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00);

    // m (109)
    font_set_char(base, 77, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0xFF, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0x00, 0x00, 0x00, 0x00);

    // n (110)
    font_set_char(base, 78, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00);

    // o (111)
    font_set_char(base, 79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // p (112)
    font_set_char(base, 80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00);

    // q (113)
    font_set_char(base, 81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00);

    // r (114)
    font_set_char(base, 82, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00);

    // s (115)
    font_set_char(base, 83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00);

    // t (116)
    font_set_char(base, 84, 0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00);

    // u (117)
    font_set_char(base, 85, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00);

    // v (118)
    font_set_char(base, 86, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xC3, 0xC3, 0xC3, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00);

    // w (119)
    font_set_char(base, 87, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00);

    // x (120)
    font_set_char(base, 88, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00);

    // y (121)
    font_set_char(base, 89, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00);

    // z (122)
    font_set_char(base, 90, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00);

    // { (123)
    font_set_char(base, 91, 0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00);

    // | (124)
    font_set_char(base, 92, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00);

    // } (125)
    font_set_char(base, 93, 0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00);

    // ~ (126)
    font_set_char(base, 94, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
}

// Helper to set character data (16 bytes per character)
fn font_set_char(base: i64, idx: i64, b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8, b14: u8, b15: u8) {
    let addr = base + idx * 16;
    unsafe {
        volatile_write_u8((addr) as *mut u8, b0);
        volatile_write_u8((addr + 1) as *mut u8, b1);
        volatile_write_u8((addr + 2) as *mut u8, b2);
        volatile_write_u8((addr + 3) as *mut u8, b3);
        volatile_write_u8((addr + 4) as *mut u8, b4);
        volatile_write_u8((addr + 5) as *mut u8, b5);
        volatile_write_u8((addr + 6) as *mut u8, b6);
        volatile_write_u8((addr + 7) as *mut u8, b7);
        volatile_write_u8((addr + 8) as *mut u8, b8);
        volatile_write_u8((addr + 9) as *mut u8, b9);
        volatile_write_u8((addr + 10) as *mut u8, b10);
        volatile_write_u8((addr + 11) as *mut u8, b11);
        volatile_write_u8((addr + 12) as *mut u8, b12);
        volatile_write_u8((addr + 13) as *mut u8, b13);
        volatile_write_u8((addr + 14) as *mut u8, b14);
        volatile_write_u8((addr + 15) as *mut u8, b15);
    }
}

// Helper to draw a single pixel if bit is set
fn draw_font_pixel(fb: i64, divisor: i64, px: i64, py: i64, pitch: i64, pixel: u32, sw: i64, sh: i64) {
    if px < 0 || px >= sw || py < 0 || py >= sh {
        return;
    }
    let bit_val = (fb / divisor) & 1;
    if bit_val == 1 {
        let off = py * pitch + px * 4;
        let addr = (BACK_BUFFER_ADDR_SYS + off) as *mut u32;
        unsafe { volatile_write_u32(addr, pixel); }
    }
}

// Draw a single character to the back buffer
fn fb_draw_char(x: i64, y: i64, ch: i64, color: i64) -> i64 {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        return -1;
    }

    // Check character range
    if ch < FONT_FIRST_CHAR || ch > FONT_LAST_CHAR {
        return -1;
    }

    let width_ptr = (FB_GFX_STATE_ADDR_SYS + 16) as *u32;
    let height_ptr = (FB_GFX_STATE_ADDR_SYS + 20) as *u32;
    let pitch_ptr = (FB_GFX_STATE_ADDR_SYS + 24) as *u32;
    let screen_width: i64;
    let screen_height: i64;
    let pitch: i64;
    unsafe {
        screen_width = volatile_read_u32(width_ptr) as i64;
        screen_height = volatile_read_u32(height_ptr) as i64;
        pitch = volatile_read_u32(pitch_ptr) as i64;
    }

    // Convert color from RGB to BGR
    let b = color & 0xFF;
    let g = (color / 256) & 0xFF;
    let r = (color / 65536) & 0xFF;
    let g_shifted = g * 256;
    let r_shifted = r * 65536;
    let pixel_tmp = b | g_shifted | r_shifted;
    let pixel = pixel_tmp as u32;

    // Get font data offset for this character
    let char_idx = ch - FONT_FIRST_CHAR;
    let font_offset = FONT_DATA_ADDR + char_idx * 16;

    // Draw 16 rows of 8 pixels each
    let mut row: i64 = 0;
    while row < 16 {
        let py = y + row;

        // Read font byte for this row
        let font_ptr = (font_offset + row) as *u8;
        let font_byte: u8;
        unsafe {
            font_byte = volatile_read_u8(font_ptr);
        }
        let fb = font_byte as i64;

        // Draw 8 pixels (bits 7-0, left to right)
        draw_font_pixel(fb, 128, x, py, pitch, pixel, screen_width, screen_height);
        draw_font_pixel(fb, 64, x + 1, py, pitch, pixel, screen_width, screen_height);
        draw_font_pixel(fb, 32, x + 2, py, pitch, pixel, screen_width, screen_height);
        draw_font_pixel(fb, 16, x + 3, py, pitch, pixel, screen_width, screen_height);
        draw_font_pixel(fb, 8, x + 4, py, pitch, pixel, screen_width, screen_height);
        draw_font_pixel(fb, 4, x + 5, py, pitch, pixel, screen_width, screen_height);
        draw_font_pixel(fb, 2, x + 6, py, pitch, pixel, screen_width, screen_height);
        draw_font_pixel(fb, 1, x + 7, py, pitch, pixel, screen_width, screen_height);

        row = row + 1;
    }
    0
}

// Draw a string to the back buffer
// text_addr: address of null-terminated string in memory
fn fb_draw_string(x: i64, y: i64, text_addr: i64, color: i64) -> i64 {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        return -1;
    }

    let mut cur_x = x;
    let mut offset: i64 = 0;

    // Read characters until null terminator
    loop {
        let char_ptr = (text_addr + offset) as *u8;
        let ch: u8;
        unsafe {
            ch = volatile_read_u8(char_ptr);
        }

        if ch == 0 {
            break;
        }

        // Handle newline
        if ch == 10 {
            // Newline character - not supported in single-line mode
            break;
        }

        // Draw character
        let _ = fb_draw_char(cur_x, y, ch as i64, color);
        cur_x = cur_x + FONT_WIDTH;
        offset = offset + 1;

        // Safety limit
        if offset > 1000 {
            break;
        }
    }

    offset
}

// Syscall wrapper for drawing a character
fn syscall_fb_char(x: i64, y: i64, ch: i64, color: i64) -> i64 {
    fb_draw_char(x, y, ch, color)
}

// Syscall wrapper for drawing a string
fn syscall_fb_text(x: i64, y: i64, text_addr: i64, color: i64) -> i64 {
    fb_draw_string(x, y, text_addr, color)
}

// VBE initialization - read framebuffer info from multiboot
fn vbe_init(mb_info_addr: i64) -> bool {
    // Check if framebuffer flag is set (bit 12)
    let flags_ptr = mb_info_addr as *u32;
    let flags: u32;
    unsafe {
        flags = volatile_read_u32(flags_ptr);
    }

    let has_fb = (flags / 4096) & 1;  // Check bit 12
    if has_fb == 0 {
        serial_out(86);  // V
        serial_out(66);  // B
        serial_out(69);  // E
        serial_out(58);  // :
        serial_out(78);  // N
        serial_out(79);  // O
        serial_newline();
        return false;
    }

    // Read framebuffer info from multiboot (offset 88-108)
    let fb_addr_ptr = (mb_info_addr + 88) as *u64;
    let fb_pitch_ptr = (mb_info_addr + 96) as *u32;
    let fb_width_ptr = (mb_info_addr + 100) as *u32;
    let fb_height_ptr = (mb_info_addr + 104) as *u32;
    let fb_bpp_ptr = (mb_info_addr + 108) as *u8;

    let fb_addr: u64;
    let fb_pitch: u32;
    let fb_width: u32;
    let fb_height: u32;
    let fb_bpp: u8;

    unsafe {
        fb_addr = volatile_read_u64(fb_addr_ptr);
        fb_pitch = volatile_read_u32(fb_pitch_ptr);
        fb_width = volatile_read_u32(fb_width_ptr);
        fb_height = volatile_read_u32(fb_height_ptr);
        fb_bpp = volatile_read_u8(fb_bpp_ptr);
    }

    if fb_addr == 0 || fb_width == 0 || fb_height == 0 {
        serial_out(86);  // V
        serial_out(66);  // B
        serial_out(69);  // E
        serial_out(58);  // :
        serial_out(66);  // B
        serial_out(65);  // A
        serial_out(68);  // D
        serial_newline();
        return false;
    }

    // Store framebuffer state at FB_GFX_STATE_ADDR_SYS
    // Offset 0: initialized flag
    // Offset 8: physical address
    // Offset 16: width
    // Offset 20: height
    // Offset 24: pitch
    // Offset 28: bpp
    unsafe {
        let init_ptr = FB_GFX_STATE_ADDR_SYS as *mut u8;
        let addr_ptr = (FB_GFX_STATE_ADDR_SYS + 8) as *mut u64;
        let width_ptr = (FB_GFX_STATE_ADDR_SYS + 16) as *mut u32;
        let height_ptr = (FB_GFX_STATE_ADDR_SYS + 20) as *mut u32;
        let pitch_ptr = (FB_GFX_STATE_ADDR_SYS + 24) as *mut u32;
        let bpp_ptr = (FB_GFX_STATE_ADDR_SYS + 28) as *mut u8;

        volatile_write_u64(addr_ptr, fb_addr);
        volatile_write_u32(width_ptr, fb_width);
        volatile_write_u32(height_ptr, fb_height);
        volatile_write_u32(pitch_ptr, fb_pitch);
        volatile_write_u8(bpp_ptr, fb_bpp);
        volatile_write_u8(init_ptr, 1);  // Mark as initialized
    }

    // Map the framebuffer into page tables using 2MB huge pages
    // Framebuffer is typically at 0xFD000000 or similar high address
    let map_ok = map_framebuffer_pages(fb_addr, fb_pitch as u64 * fb_height as u64);
    if !map_ok {
        serial_out(86);  // V
        serial_out(66);  // B
        serial_out(69);  // E
        serial_out(58);  // :
        serial_out(77);  // M
        serial_out(65);  // A
        serial_out(80);  // P
        serial_newline();
        return false;
    }

    serial_out(86);  // V
    serial_out(66);  // B
    serial_out(69);  // E
    serial_out(58);  // :
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    true
}

// Map framebuffer using 2MB huge pages
fn map_framebuffer_pages(fb_addr: u64, fb_size: u64) -> bool {
    // Debug: Print framebuffer address
    serial_out(70);  // F
    serial_out(66);  // B
    serial_out(58);  // :
    serial_hex(fb_addr);
    serial_newline();

    // Get PML4 address from CR3
    let mut cr3: u64 = 0;
    unsafe {
        asm!(
            "movq %cr3, %rax",
            lateout("rax") cr3,
            options(nomem, nostack, att_syntax)
        );
    }
    // Clear low 12 bits using division
    let cr3_div = cr3 / 4096;
    let pml4_addr = cr3_div * 4096;

    // Debug: Print CR3
    serial_out(67);  // C
    serial_out(82);  // R
    serial_out(51);  // 3
    serial_out(58);  // :
    serial_hex(pml4_addr);
    serial_newline();

    // Calculate how many 2MB pages we need - round up
    let fb_size_plus = fb_size + 0x1FFFFF;
    let pages_needed = fb_size_plus / 0x200000;
    // Align fb_addr to 2MB boundary using division
    let fb_addr_div = fb_addr / 0x200000;
    let fb_base = fb_addr_div * 0x200000;

    // For each 2MB page in the framebuffer
    let mut mapped: u64 = 0;
    while mapped < pages_needed {
        let phys = fb_base + mapped * 0x200000;

        // Calculate page table indices
        let pml4_div = phys / 0x8000000000;
        let pml4_idx = pml4_div % 512;
        let pdpt_div = phys / 0x40000000;
        let pdpt_idx = pdpt_div % 512;
        let pd_div = phys / 0x200000;
        let pd_idx = pd_div % 512;

        // Get or create PDPT entry
        let pml4e_addr = pml4_addr + pml4_idx * 8;
        let pml4e = read_u64_addr(pml4e_addr as i64);

        let pdpt_addr: u64;
        if pml4e % 2 == 0 {
            // Allocate PDPT from kernel page table pool
            let new_pdpt = kptpool_alloc();
            if new_pdpt == 0 {
                return false;
            }
            zero_page(new_pdpt as i64);
            let new_pdpt_entry = new_pdpt + 7;  // P + R/W + U
            write_u64_addr(pml4e_addr as i64, new_pdpt_entry);
            pdpt_addr = new_pdpt;
        } else {
            let div = pml4e / 4096;
            pdpt_addr = div * 4096;
        }

        // Get or create PD entry
        let pdpte_addr = pdpt_addr + pdpt_idx * 8;
        let pdpte = read_u64_addr(pdpte_addr as i64);

        let pd_addr: u64;
        if pdpte % 2 == 0 {
            // Allocate PD from kernel page table pool
            let new_pd = kptpool_alloc();
            if new_pd == 0 {
                return false;
            }
            zero_page(new_pd as i64);
            let new_pd_entry = new_pd + 7;  // P + R/W + U
            write_u64_addr(pdpte_addr as i64, new_pd_entry);
            pd_addr = new_pd;
        } else {
            let div = pdpte / 4096;
            pd_addr = div * 4096;
        }

        // Set PD entry as 2MB huge page (P + RW + U + WT + CD + HUGE = 0x9F)
        // 0x9F = Present + R/W + User + WriteThrough + CacheDisabled + PageSize(2MB)
        let pde_addr = pd_addr + pd_idx * 8;
        let pde_val = phys + 0x9F;
        write_u64_addr(pde_addr as i64, pde_val);

        // Debug: Print mapping info
        serial_out(77);  // M
        serial_out(65);  // A
        serial_out(80);  // P
        serial_out(58);  // :
        serial_hex(phys);
        serial_out(45);  // -
        serial_out(62);  // >
        serial_hex(pd_idx);
        serial_newline();

        // Invalidate TLB
        unsafe {
            asm!(
                "invlpg (%rdi)",
                in("rdi") phys,
                options(nostack, att_syntax)
            );
        }

        mapped = mapped + 1;
    }

    serial_out(70);  // F
    serial_out(66);  // B
    serial_out(77);  // M
    serial_out(65);  // A
    serial_out(80);  // P
    serial_out(58);  // :
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    true
}

// Zero a 4KB page
fn zero_page(addr: i64) {
    let mut offset: i64 = 0;
    while offset < 4096 {
        write_u64_addr(addr + offset, 0);
        offset = offset + 8;
    }
}

// Draw rectangle directly to framebuffer
fn draw_rect_direct(fb_addr: i64, pitch: i64, x: i64, y: i64, w: i64, h: i64, color: u32) {
    let mut py = y;
    while py < y + h {
        let row_addr = fb_addr + py * pitch;
        let mut px = x;
        while px < x + w {
            let addr = row_addr + px * 4;
            unsafe {
                volatile_write_u32(addr as *mut u32, color);
            }
            px = px + 1;
        }
        py = py + 1;
    }
}

// ============================================================
// Mouse PS/2 Initialization
// ============================================================

const MOUSE_STATE_ADDR: i64 = 0x4B0000;

fn mouse_init() {
    // Initialize mouse state to center of screen
    let x_ptr = (MOUSE_STATE_ADDR + 8) as *mut i64;
    let y_ptr = (MOUSE_STATE_ADDR + 16) as *mut i64;
    let btn_ptr = (MOUSE_STATE_ADDR + 24) as *mut u8;
    let idx_ptr = MOUSE_STATE_ADDR as *mut i64;
    unsafe {
        volatile_write_i64(x_ptr, 960);  // Center X
        volatile_write_i64(y_ptr, 540);  // Center Y
        volatile_write_u8(btn_ptr, 0);
        volatile_write_i64(idx_ptr, 0);
    }

    // Wait for controller ready
    mouse_wait_write();
    outb_main(0x64, 0xA8);  // Enable auxiliary device

    // Enable IRQ12
    mouse_wait_write();
    outb_main(0x64, 0x20);  // Read command byte
    mouse_wait_read();
    let config = inb_main(0x60);
    // Enable IRQ12 - bit 1 should be 0 initially, so + works like |
    let bit1_clear = config & 0xFD;  // Clear bit 1 first
    let new_config = bit1_clear + 0x02;  // Set bit 1

    mouse_wait_write();
    outb_main(0x64, 0x60);  // Write command byte
    mouse_wait_write();
    outb_main(0x60, new_config as i64);

    // Enable mouse data reporting
    mouse_write_cmd(0xF4);

    serial_out(77);  // M
    serial_out(79);  // O
    serial_out(85);  // U
    serial_out(83);  // S
    serial_out(69);  // E
    serial_out(58);  // :
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

fn mouse_wait_write() {
    let mut timeout: i64 = 100000;
    while timeout > 0 {
        let status = inb_main(0x64);
        let busy = status & 0x02;
        if busy == 0 {
            return;
        }
        timeout = timeout - 1;
    }
}

fn mouse_wait_read() {
    let mut timeout: i64 = 100000;
    while timeout > 0 {
        let status = inb_main(0x64);
        let ready = status & 0x01;
        if ready != 0 {
            return;
        }
        timeout = timeout - 1;
    }
}

fn mouse_write_cmd(cmd: i64) {
    mouse_wait_write();
    outb_main(0x64, 0xD4);  // Write to mouse
    mouse_wait_write();
    outb_main(0x60, cmd);
    // Read ACK
    mouse_wait_read();
    let _ = inb_main(0x60);
}

fn inb_main(port: i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "in %dx, %al",
            in("dx") port,
            lateout("al") result,
            options(nomem, nostack, att_syntax)
        );
    }
    result
}

fn outb_main(port: i64, value: i64) {
    unsafe {
        asm!(
            "out %al, %dx",
            in("dx") port,
            in("al") value,
            options(nomem, nostack, att_syntax)
        );
    }
}

fn volatile_write_i64(ptr: *mut i64, value: i64) {
    unsafe {
        asm!(
            "movq %rax, (%rcx)",
            in("rcx") ptr,
            in("rax") value,
            options(nostack, att_syntax)
        );
    }
}

// ============================================================
// Mouse Syscalls
// ============================================================

fn syscall_mouse_pos() -> i64 {
    let x_ptr = (MOUSE_STATE_ADDR + 8) as *i64;
    let y_ptr = (MOUSE_STATE_ADDR + 16) as *i64;
    let x: i64;
    let y: i64;
    unsafe {
        x = volatile_read_i64(x_ptr);
        y = volatile_read_i64(y_ptr);
    }
    // Return x in low 32 bits, y in high 32 bits
    let y_shifted = y * 0x100000000;
    x + y_shifted
}

fn syscall_mouse_btn() -> i64 {
    let btn_ptr = (MOUSE_STATE_ADDR + 24) as *u8;
    let btn: u8;
    unsafe { btn = volatile_read_u8(btn_ptr); }
    btn as i64
}

fn syscall_mouse_set(x: i64, y: i64) -> i64 {
    let x_ptr = (MOUSE_STATE_ADDR + 8) as *mut i64;
    let y_ptr = (MOUSE_STATE_ADDR + 16) as *mut i64;
    unsafe {
        volatile_write_i64(x_ptr, x);
        volatile_write_i64(y_ptr, y);
    }
    0
}

fn volatile_read_i64(ptr: *i64) -> i64 {
    let mut result: i64 = 0;
    unsafe {
        asm!(
            "movq (%rcx), %rax",
            in("rcx") ptr,
            lateout("rax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Hello Graphics Demo - draw colored rectangles and text using double-buffering
fn hello_graphics_demo() {
    let initialized_ptr = FB_GFX_STATE_ADDR_SYS as *u8;
    let initialized: u8;
    unsafe {
        initialized = volatile_read_u8(initialized_ptr);
    }
    if initialized == 0 {
        serial_out(71);  // G
        serial_out(70);  // F
        serial_out(88);  // X
        serial_out(58);  // :
        serial_out(78);  // N
        serial_out(79);  // O
        serial_newline();
        return;
    }

    serial_out(71);  // G
    serial_out(70);  // F
    serial_out(88);  // X
    serial_out(58);  // :
    serial_out(68);  // D
    serial_out(69);  // E
    serial_out(77);  // M
    serial_out(79);  // O
    serial_newline();

    // Get framebuffer pitch for back buffer drawing
    let pitch_ptr = (FB_GFX_STATE_ADDR_SYS + 24) as *u32;
    let pitch: i64;
    unsafe {
        pitch = volatile_read_u32(pitch_ptr) as i64;
    }

    // Clear back buffer with dark blue background (0x003366 RGB -> BGR)
    let _ = syscall_fb_clear(0x003366);

    // ===== TITLE TEXT =====
    // Draw "GENESIS OS" title at top center (white text)
    // G=71, E=69, N=78, E=69, S=83, I=73, S=83, space=32, O=79, S=83
    let title_y: i64 = 20;
    let title_x: i64 = 350;  // Centered approximately
    let title_color: i64 = 0xFFFFFF;  // White

    // Draw "GENESIS OS" character by character
    let _ = fb_draw_char(title_x, title_y, 71, title_color);       // G
    let _ = fb_draw_char(title_x + 8, title_y, 69, title_color);   // E
    let _ = fb_draw_char(title_x + 16, title_y, 78, title_color);  // N
    let _ = fb_draw_char(title_x + 24, title_y, 69, title_color);  // E
    let _ = fb_draw_char(title_x + 32, title_y, 83, title_color);  // S
    let _ = fb_draw_char(title_x + 40, title_y, 73, title_color);  // I
    let _ = fb_draw_char(title_x + 48, title_y, 83, title_color);  // S
    let _ = fb_draw_char(title_x + 56, title_y, 32, title_color);  // (space)
    let _ = fb_draw_char(title_x + 64, title_y, 79, title_color);  // O
    let _ = fb_draw_char(title_x + 72, title_y, 83, title_color);  // S

    // ===== SUBTITLE =====
    // Draw "Hello Graphics!" subtitle
    let sub_y: i64 = 40;
    let sub_x: i64 = 330;
    let sub_color: i64 = 0x00FFFF;  // Cyan

    // "Hello Graphics!"
    // H=72, e=101, l=108, l=108, o=111, space=32, G=71, r=114, a=97, p=112, h=104, i=105, c=99, s=115, !=33
    let _ = fb_draw_char(sub_x, sub_y, 72, sub_color);        // H
    let _ = fb_draw_char(sub_x + 8, sub_y, 101, sub_color);   // e
    let _ = fb_draw_char(sub_x + 16, sub_y, 108, sub_color);  // l
    let _ = fb_draw_char(sub_x + 24, sub_y, 108, sub_color);  // l
    let _ = fb_draw_char(sub_x + 32, sub_y, 111, sub_color);  // o
    let _ = fb_draw_char(sub_x + 40, sub_y, 32, sub_color);   // (space)
    let _ = fb_draw_char(sub_x + 48, sub_y, 71, sub_color);   // G
    let _ = fb_draw_char(sub_x + 56, sub_y, 114, sub_color);  // r
    let _ = fb_draw_char(sub_x + 64, sub_y, 97, sub_color);   // a
    let _ = fb_draw_char(sub_x + 72, sub_y, 112, sub_color);  // p
    let _ = fb_draw_char(sub_x + 80, sub_y, 104, sub_color);  // h
    let _ = fb_draw_char(sub_x + 88, sub_y, 105, sub_color);  // i
    let _ = fb_draw_char(sub_x + 96, sub_y, 99, sub_color);   // c
    let _ = fb_draw_char(sub_x + 104, sub_y, 115, sub_color); // s
    let _ = fb_draw_char(sub_x + 112, sub_y, 33, sub_color);  // !

    // ===== COLOR BOXES WITH LABELS =====

    // Red rectangle at top-left (RGB 0xFF0000 -> BGR 0x0000FF)
    draw_rect_backbuf(pitch, 50, 80, 150, 80, 0x0000FF);
    // Label "Red"
    let _ = fb_draw_char(100, 170, 82, 0xFFFFFF);   // R
    let _ = fb_draw_char(108, 170, 101, 0xFFFFFF);  // e
    let _ = fb_draw_char(116, 170, 100, 0xFFFFFF);  // d

    // Green rectangle (RGB 0x00FF00 -> BGR 0x00FF00)
    draw_rect_backbuf(pitch, 250, 80, 150, 80, 0x00FF00);
    // Label "Green"
    let _ = fb_draw_char(290, 170, 71, 0xFFFFFF);   // G
    let _ = fb_draw_char(298, 170, 114, 0xFFFFFF);  // r
    let _ = fb_draw_char(306, 170, 101, 0xFFFFFF);  // e
    let _ = fb_draw_char(314, 170, 101, 0xFFFFFF);  // e
    let _ = fb_draw_char(322, 170, 110, 0xFFFFFF);  // n

    // Blue rectangle (RGB 0x0000FF -> BGR 0xFF0000)
    draw_rect_backbuf(pitch, 450, 80, 150, 80, 0xFF0000);
    // Label "Blue"
    let _ = fb_draw_char(495, 170, 66, 0xFFFFFF);   // B
    let _ = fb_draw_char(503, 170, 108, 0xFFFFFF);  // l
    let _ = fb_draw_char(511, 170, 117, 0xFFFFFF);  // u
    let _ = fb_draw_char(519, 170, 101, 0xFFFFFF);  // e

    // Yellow rectangle (RGB 0xFFFF00 -> BGR 0x00FFFF)
    draw_rect_backbuf(pitch, 50, 200, 150, 80, 0x00FFFF);
    // Label "Yellow"
    let _ = fb_draw_char(85, 290, 89, 0xFFFFFF);    // Y
    let _ = fb_draw_char(93, 290, 101, 0xFFFFFF);   // e
    let _ = fb_draw_char(101, 290, 108, 0xFFFFFF);  // l
    let _ = fb_draw_char(109, 290, 108, 0xFFFFFF);  // l
    let _ = fb_draw_char(117, 290, 111, 0xFFFFFF);  // o
    let _ = fb_draw_char(125, 290, 119, 0xFFFFFF);  // w

    // Magenta rectangle (RGB 0xFF00FF -> BGR 0xFF00FF)
    draw_rect_backbuf(pitch, 250, 200, 150, 80, 0xFF00FF);
    // Label "Magenta"
    let _ = fb_draw_char(275, 290, 77, 0xFFFFFF);   // M
    let _ = fb_draw_char(283, 290, 97, 0xFFFFFF);   // a
    let _ = fb_draw_char(291, 290, 103, 0xFFFFFF);  // g
    let _ = fb_draw_char(299, 290, 101, 0xFFFFFF);  // e
    let _ = fb_draw_char(307, 290, 110, 0xFFFFFF);  // n
    let _ = fb_draw_char(315, 290, 116, 0xFFFFFF);  // t
    let _ = fb_draw_char(323, 290, 97, 0xFFFFFF);   // a

    // Cyan rectangle (RGB 0x00FFFF -> BGR 0xFFFF00)
    draw_rect_backbuf(pitch, 450, 200, 150, 80, 0xFFFF00);
    // Label "Cyan"
    let _ = fb_draw_char(495, 290, 67, 0xFFFFFF);   // C
    let _ = fb_draw_char(503, 290, 121, 0xFFFFFF);  // y
    let _ = fb_draw_char(511, 290, 97, 0xFFFFFF);   // a
    let _ = fb_draw_char(519, 290, 110, 0xFFFFFF);  // n

    // White rectangle
    draw_rect_backbuf(pitch, 250, 320, 150, 80, 0xFFFFFF);
    // Label "White"
    let _ = fb_draw_char(290, 410, 87, 0xFFFFFF);   // W
    let _ = fb_draw_char(298, 410, 104, 0xFFFFFF);  // h
    let _ = fb_draw_char(306, 410, 105, 0xFFFFFF);  // i
    let _ = fb_draw_char(314, 410, 116, 0xFFFFFF);  // t
    let _ = fb_draw_char(322, 410, 101, 0xFFFFFF);  // e

    // ===== FOOTER TEXT =====
    // Draw "Milestone 4: Hello Graphics - COMPLETE!" at bottom
    let footer_y: i64 = 450;
    let footer_x: i64 = 200;
    let footer_color: i64 = 0x00FF00;  // Green

    // "Milestone 4 Complete!"
    // M=77, i=105, l=108, e=101, s=115, t=116, o=111, n=110, e=101, space=32, 4=52, space=32, C=67, o=111, m=109, p=112, l=108, e=101, t=116, e=101, !=33
    let _ = fb_draw_char(footer_x, footer_y, 77, footer_color);        // M
    let _ = fb_draw_char(footer_x + 8, footer_y, 105, footer_color);   // i
    let _ = fb_draw_char(footer_x + 16, footer_y, 108, footer_color);  // l
    let _ = fb_draw_char(footer_x + 24, footer_y, 101, footer_color);  // e
    let _ = fb_draw_char(footer_x + 32, footer_y, 115, footer_color);  // s
    let _ = fb_draw_char(footer_x + 40, footer_y, 116, footer_color);  // t
    let _ = fb_draw_char(footer_x + 48, footer_y, 111, footer_color);  // o
    let _ = fb_draw_char(footer_x + 56, footer_y, 110, footer_color);  // n
    let _ = fb_draw_char(footer_x + 64, footer_y, 101, footer_color);  // e
    let _ = fb_draw_char(footer_x + 72, footer_y, 32, footer_color);   // (space)
    let _ = fb_draw_char(footer_x + 80, footer_y, 52, footer_color);   // 4
    let _ = fb_draw_char(footer_x + 88, footer_y, 32, footer_color);   // (space)
    let _ = fb_draw_char(footer_x + 96, footer_y, 67, footer_color);   // C
    let _ = fb_draw_char(footer_x + 104, footer_y, 111, footer_color); // o
    let _ = fb_draw_char(footer_x + 112, footer_y, 109, footer_color); // m
    let _ = fb_draw_char(footer_x + 120, footer_y, 112, footer_color); // p
    let _ = fb_draw_char(footer_x + 128, footer_y, 108, footer_color); // l
    let _ = fb_draw_char(footer_x + 136, footer_y, 101, footer_color); // e
    let _ = fb_draw_char(footer_x + 144, footer_y, 116, footer_color); // t
    let _ = fb_draw_char(footer_x + 152, footer_y, 101, footer_color); // e
    let _ = fb_draw_char(footer_x + 160, footer_y, 33, footer_color);  // !

    // ===== MOUSE CURSOR =====
    // Draw mouse cursor at current position
    let mx_ptr = (MOUSE_STATE_ADDR + 8) as *i64;
    let my_ptr = (MOUSE_STATE_ADDR + 16) as *i64;
    let mx: i64;
    let my: i64;
    unsafe {
        mx = volatile_read_i64(mx_ptr);
        my = volatile_read_i64(my_ptr);
    }
    // Draw white 10x10 cursor to back buffer
    draw_rect_backbuf(pitch, mx, my, 10, 10, 0xFFFFFF);

    // Swap back buffer to front buffer
    let _ = syscall_fb_swap();

    serial_out(71);  // G
    serial_out(70);  // F
    serial_out(88);  // X
    serial_out(58);  // :
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();
}

// Draw rectangle to back buffer
fn draw_rect_backbuf(pitch: i64, x: i64, y: i64, w: i64, h: i64, color: u32) {
    let mut py = y;
    while py < y + h {
        let row_addr = BACK_BUFFER_ADDR_SYS + py * pitch;
        let mut px = x;
        while px < x + w {
            let addr = row_addr + px * 4;
            unsafe {
                volatile_write_u32(addr as *mut u32, color);
            }
            px = px + 1;
        }
        py = py + 1;
    }
}

// Debug function: check page table entry for an address
fn debug_check_pte(vaddr: i64) {
    // Get CR3
    let mut pml4: i64 = 0;
    unsafe {
        asm!(
            "movq %cr3, %rax",
            lateout("rax") pml4,
            options(nomem, nostack, att_syntax)
        );
    }
    // Clear lower 12 bits to get physical address
    let pml4_addr: i64 = (pml4 / 4096) * 4096;

    serial_out(67);  // C
    serial_out(82);  // R
    serial_out(51);  // 3
    serial_out(58);  // :
    serial_hex(pml4_addr as u64);
    serial_newline();

    // Calculate indices (0xFEB80000)
    // PML4: vaddr / 512GB % 512
    // PDPT: vaddr / 1GB % 512 = 0xFEB80000 / 0x40000000 % 512 = 3
    // PD: vaddr / 2MB % 512 = 0xFEB80000 / 0x200000 % 512 = 501
    // PT: vaddr / 4KB % 512 = 0xFEB80000 / 0x1000 % 512 = 384
    let pml4_idx: i64 = 0;   // vaddr < 512GB so index is 0
    let pdpt_idx: i64 = 3;   // 0xFEB80000 / 0x40000000 = 3
    let pd_idx: i64 = 501;   // ((0xFEB80000 / 0x200000) % 512) = 501
    let pt_idx: i64 = 384;   // ((0xFEB80000 / 0x1000) % 512) = 384

    // Read PML4E
    let pml4e = read_u64_addr(pml4_addr + pml4_idx * 8) as i64;
    serial_out(80);  // P
    serial_out(52);  // 4
    serial_out(58);  // :
    serial_hex(pml4e as u64);
    serial_newline();

    if (pml4e % 2) == 0 {
        serial_out(78);  // N
        serial_out(80);  // P
        serial_newline();
        return;
    }

    // Read PDPTE
    let pdpt_addr: i64 = (pml4e / 4096) * 4096;  // Clear lower 12 bits
    let pdpte = read_u64_addr(pdpt_addr + pdpt_idx * 8) as i64;
    serial_out(80);  // P
    serial_out(51);  // 3
    serial_out(58);  // :
    serial_hex(pdpte as u64);
    serial_newline();

    if (pdpte % 2) == 0 {
        serial_out(78);  // N
        serial_out(80);  // P
        serial_newline();
        return;
    }

    // Check for 1GB page (bit 7)
    if (pdpte / 128) % 2 == 1 {
        serial_out(49);  // 1
        serial_out(71);  // G
        serial_newline();
        return;
    }

    // Read PDE
    let pd_addr: i64 = (pdpte / 4096) * 4096;  // Clear lower 12 bits
    let pde = read_u64_addr(pd_addr + pd_idx * 8) as i64;
    serial_out(80);  // P
    serial_out(50);  // 2
    serial_out(58);  // :
    serial_hex(pde as u64);
    serial_newline();

    if (pde % 2) == 0 {
        serial_out(78);  // N
        serial_out(80);  // P
        serial_newline();
        return;
    }

    // Check for 2MB page (bit 7)
    if (pde / 128) % 2 == 1 {
        serial_out(50);  // 2
        serial_out(77);  // M
        serial_newline();
        return;
    }

    // Read PTE
    let pt_addr: i64 = (pde / 4096) * 4096;  // Clear lower 12 bits
    let pte = read_u64_addr(pt_addr + pt_idx * 8) as i64;
    serial_out(80);  // P
    serial_out(84);  // T
    serial_out(58);  // :
    serial_hex(pte as u64);
    serial_newline();
}

// Map MMIO region for E1000 network card
// E1000 typically at 0xFEB80000 in QEMU
fn map_e1000_mmio() {
    serial_out(77);  // M
    serial_out(77);  // M
    serial_out(73);  // I
    serial_out(79);  // O
    serial_newline();

    // Map 256KB of MMIO space (0xFEB80000 - 0xFEBC0000)
    // Using identity mapping with appropriate flags
    let base: u64 = 0xFEB80000;
    let size: u64 = 0x40000;  // 256KB

    // Page flags: Present (1) + Writable (2) + Cache Disable (16)
    let flags: u64 = 1 + 2 + 16;

    let mut offset: u64 = 0;
    let mut count: i64 = 0;
    while offset < size {
        let addr = base + offset;
        let ok = mmap_map_page(addr, addr, flags);  // Identity map
        if ok {
            count = count + 1;
        }
        offset = offset + 0x1000;  // 4KB pages
    }

    serial_out(77);  // M
    serial_out(65);  // A
    serial_out(80);  // P
    serial_out(58);  // :
    serial_out(48 + ((count / 10) % 10) as i64);
    serial_out(48 + (count % 10) as i64);
    serial_newline();

    // Verify the mapping
    debug_check_pte(0xFEB80000);

    // Test MMIO read directly - use register-based addressing
    serial_out(84);  // T
    serial_out(82);  // R
    serial_out(58);  // :
    let mmio_addr: i64 = 0xFEB80008;  // STATUS register
    let mmio_status: i64;
    unsafe {
        asm!(
            "mfence
             movl (%rdi), %eax
             mfence",
            in("rdi") mmio_addr,
            lateout("eax") mmio_status,
            options(nostack, att_syntax)
        );
    }
    serial_hex(mmio_status as u64);
    serial_newline();
}

// Public MMIO read helper for network module
pub fn mmio_read32(addr: i64) -> i64 {
    // Always print a marker when called
    serial_out(33);  // !

    let mut result: i64 = 0;
    unsafe {
        asm!(
            "mfence
             movl (%rdi), %eax
             mfence",
            in("rdi") addr,
            lateout("eax") result,
            options(nostack, att_syntax)
        );
    }
    result
}

// Initialize network stack
fn net_init() {
    // Print banner
    serial_out(78);  // N
    serial_out(69);  // E
    serial_out(84);  // T
    serial_out(32);  // space
    serial_out(73);  // I
    serial_out(78);  // N
    serial_out(73);  // I
    serial_out(84);  // T
    serial_newline();

    // Initialize kernel page table pool for MMIO mapping
    kptpool_init();

    // Map E1000 MMIO region before initializing network stack
    map_e1000_mmio();

    // Initialize the network stack
    net::net_stack_init();
}

// Test TCP connection to debug E1000 TX
fn test_tcp_connection() {
    // Print "TCP TEST"
    serial_out(84);  // T
    serial_out(67);  // C
    serial_out(80);  // P
    serial_out(32);  // space
    serial_out(84);  // T
    serial_out(69);  // E
    serial_out(83);  // S
    serial_out(84);  // T
    serial_newline();

    // Wait for QEMU's network to initialize (SLIRP needs time)
    // QEMU's SLIRP network stack needs significant time to fully initialize
    // The E1000 RX path doesn't work until QEMU's network backend is ready
    serial_out(87);  // W - waiting for network
    let mut init_delay: i64 = 0;
    while init_delay < 500000000 {  // ~500ms for QEMU cold start
        init_delay = init_delay + 1;
    }
    serial_out(82);  // R - ready

    // Configure network for QEMU (static IP: 10.0.2.15, gateway: 10.0.2.2)
    net::net_tcp_configure_qemu();

    // Create TCP socket - domain=2 (AF_INET), type=1 (SOCK_STREAM), protocol=0
    let sock = net::net_socket_create(2, 1, 0);
    serial_out(83);  // S
    serial_out(79);  // O
    serial_out(67);  // C
    serial_out(75);  // K
    serial_out(61);  // =
    if sock >= 0 {
        serial_print_dec(sock);
    } else {
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
    }
    serial_newline();

    if sock >= 0 {
        // Get proto_id from socket descriptor
        let desc_addr = 0xD3A000 + (sock * 32);
        let proto_id = read_u32_at(desc_addr, 4) as i64;

        // Connect to gateway 10.0.2.2:80 (QEMU user mode gateway)
        // 10.0.2.2 = (10 * 16777216) + (0 * 65536) + (2 * 256) + 2 = 167772674
        let gateway_ip: i64 = 167772674;
        let port: i64 = 80;

        serial_out(67);  // C
        serial_out(79);  // O
        serial_out(78);  // N
        serial_out(78);  // N
        serial_out(69);  // E
        serial_out(67);  // C
        serial_out(84);  // T
        serial_newline();

        // This will trigger ARP resolution and send SYN
        let result = net::net_tcp_connect(proto_id, gateway_ip, port);

        serial_out(82);  // R
        serial_out(69);  // E
        serial_out(83);  // S
        serial_out(61);  // =
        if result >= 0 {
            serial_print_dec(result);
        } else {
            serial_out(45);  // -
            serial_print_dec(0 - result);
        }
        serial_newline();
    }
}

// Test RSA encryption (unit test, no network)
fn test_rsa_unit() {
    serial_out(82);  // R
    serial_out(83);  // S
    serial_out(65);  // A
    serial_out(32);  // space
    serial_out(85);  // U
    serial_out(78);  // N
    serial_out(73);  // I
    serial_out(84);  // T
    serial_newline();

    // Test big integer operations with small numbers
    let a_addr = RSA_WORK_ADDR + 8000;
    let b_addr = RSA_WORK_ADDR + 8256;
    let c_addr = RSA_WORK_ADDR + 8512;

    // Test 1: Addition
    bigint_zero(a_addr);
    bigint_zero(b_addr);
    write_u64_addr(a_addr, 0xFFFFFFFF);  // a = 2^32 - 1
    write_u64_addr(b_addr, 1);           // b = 1
    bigint_add(c_addr, a_addr, b_addr);  // c = a + b = 2^32
    let c0 = read_u64_addr(c_addr);
    let c1 = read_u64_addr(c_addr + 8);

    serial_out(65);  // A
    serial_out(68);  // D
    serial_out(68);  // D
    serial_out(58);  // :
    if c0 == 0x100000000 && c1 == 0 {
        serial_out(79);  // O
        serial_out(75);  // K
    } else {
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
        serial_out(32);  // space
        serial_hex64(c0);
        serial_out(47);  // /
        serial_hex64(c1);
    }
    serial_newline();

    // Test 2: Multiplication (small numbers)
    bigint_zero(a_addr);
    bigint_zero(b_addr);
    write_u64_addr(a_addr, 12345);
    write_u64_addr(b_addr, 67890);
    bigint_mulmod(c_addr, a_addr, b_addr, a_addr);  // For small numbers, no mod needed
    // 12345 * 67890 = 838102050
    let result = read_u64_addr(c_addr);

    serial_out(77);  // M
    serial_out(85);  // U
    serial_out(76);  // L
    serial_out(58);  // :
    // Note: mulmod reduces by a=12345, so result = 838102050 mod 12345 = 838102050 - 67890*12345 = 0
    // Actually we need a proper test. Let's just check the mul result
    serial_hex64(result);
    serial_newline();

    // Test 3: Modular exponentiation (small: 2^10 mod 1000 = 1024 mod 1000 = 24)
    bigint_zero(a_addr);  // base
    bigint_zero(b_addr);  // exponent
    bigint_zero(c_addr);  // modulus
    write_u64_addr(a_addr, 2);     // base = 2
    write_u64_addr(b_addr, 10);    // exp = 10
    write_u64_addr(c_addr, 1000);  // mod = 1000

    let result_addr = RSA_WORK_ADDR + 8768;
    bigint_modexp(result_addr, a_addr, b_addr, c_addr);
    let exp_result = read_u64_addr(result_addr);

    serial_out(69);  // E
    serial_out(88);  // X
    serial_out(80);  // P
    serial_out(58);  // :
    if exp_result == 24 {
        serial_out(79);  // O
        serial_out(75);  // K
    } else {
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
        serial_out(32);  // space
        serial_hex64(exp_result);
    }
    serial_newline();

    // Test 4: RSA-like operation with tiny key (e=17, d=2753, n=3233)
    // 3233 = 61 * 53 (prime factors)
    // phi(3233) = 60 * 52 = 3120
    // e = 17 (coprime to 3120)
    // d = 2753 (17 * 2753 mod 3120 = 1)
    // Encrypt m=123: c = 123^17 mod 3233 = 855
    // Decrypt: m = 855^2753 mod 3233 = 123

    bigint_zero(a_addr);  // message
    bigint_zero(b_addr);  // exponent
    bigint_zero(c_addr);  // modulus
    write_u64_addr(a_addr, 123);   // m = 123
    write_u64_addr(b_addr, 17);    // e = 17
    write_u64_addr(c_addr, 3233);  // n = 3233

    bigint_modexp(result_addr, a_addr, b_addr, c_addr);
    let cipher = read_u64_addr(result_addr);

    serial_out(82);  // R
    serial_out(83);  // S
    serial_out(65);  // A
    serial_out(69);  // E
    serial_out(58);  // :
    if cipher == 855 {
        serial_out(79);  // O
        serial_out(75);  // K
    } else {
        serial_out(70);  // F
        serial_out(65);  // A
        serial_out(73);  // I
        serial_out(76);  // L
        serial_out(32);  // space
        serial_hex64(cipher);
    }
    serial_newline();

    serial_out(82);  // R
    serial_out(83);  // S
    serial_out(65);  // A
    serial_out(32);  // space
    serial_out(68);  // D
    serial_out(79);  // O
    serial_out(78);  // N
    serial_out(69);  // E
    serial_newline();
}

// Test HTTPS/TLS connection
fn test_tls_connection() {
    serial_out(84);  // T
    serial_out(76);  // L
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(84);  // T
    serial_out(69);  // E
    serial_out(83);  // S
    serial_out(84);  // T
    serial_newline();

    // Configure network
    net::net_tcp_configure_qemu();

    // Create socket
    let sock = net::net_socket_create(2, 1, 0);
    if sock < 0 {
        serial_out(83);  // S
        serial_out(79);  // O
        serial_out(67);  // C
        serial_out(75);  // K
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_newline();
        return;
    }

    serial_out(83);  // S
    serial_out(79);  // O
    serial_out(67);  // C
    serial_out(75);  // K
    serial_out(61);  // =
    serial_print_dec(sock);
    serial_newline();

    // Get proto_id
    let desc_addr = 0xD3A000 + (sock * 32);
    let proto_id = read_u32_at(desc_addr, 4) as i64;

    // Connect to example.com (93.184.216.34) port 443
    // 93.184.216.34 = (93 << 24) | (184 << 16) | (216 << 8) | 34 = 1572395042
    let server_ip: i64 = 1572395042;
    let port: i64 = 443;

    serial_out(67);  // C
    serial_out(79);  // O
    serial_out(78);  // N
    serial_out(78);  // N
    serial_out(52);  // 4
    serial_out(52);  // 4
    serial_out(51);  // 3
    serial_newline();

    let result = net::net_tcp_connect(proto_id, server_ip, port);
    if result < 0 {
        serial_out(67);  // C
        serial_out(79);  // O
        serial_out(78);  // N
        serial_out(78);  // N
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_out(58);  // :
        serial_print_dec(0 - result);
        serial_newline();
        return;
    }

    serial_out(67);  // C
    serial_out(79);  // O
    serial_out(78);  // N
    serial_out(78);  // N
    serial_out(79);  // O
    serial_out(75);  // K
    serial_newline();

    // Now do TLS handshake
    // Hostname: "example.com" = 11 bytes
    let hostname_addr = RSA_WORK_ADDR + 6000;
    write_byte_addr(hostname_addr, 101);      // e
    write_byte_addr(hostname_addr + 1, 120);  // x
    write_byte_addr(hostname_addr + 2, 97);   // a
    write_byte_addr(hostname_addr + 3, 109);  // m
    write_byte_addr(hostname_addr + 4, 112);  // p
    write_byte_addr(hostname_addr + 5, 108);  // l
    write_byte_addr(hostname_addr + 6, 101);  // e
    write_byte_addr(hostname_addr + 7, 46);   // .
    write_byte_addr(hostname_addr + 8, 99);   // c
    write_byte_addr(hostname_addr + 9, 111);  // o
    write_byte_addr(hostname_addr + 10, 109); // m

    let tls_result = syscall_tls_connect(sock, hostname_addr, 11);

    serial_out(84);  // T
    serial_out(76);  // L
    serial_out(83);  // S
    serial_out(61);  // =
    if tls_result >= 0 {
        serial_out(79);  // O
        serial_out(75);  // K
    } else {
        serial_out(69);  // E
        serial_out(82);  // R
        serial_out(82);  // R
        serial_out(58);  // :
        serial_print_dec(0 - tls_result);
    }
    serial_newline();

    // Close
    syscall_tls_close(sock);

    serial_out(84);  // T
    serial_out(76);  // L
    serial_out(83);  // S
    serial_out(32);  // space
    serial_out(68);  // D
    serial_out(79);  // O
    serial_out(78);  // N
    serial_out(69);  // E
    serial_newline();
}

// ============================================================
// Kernel Entry Point
// ============================================================

fn _start() {
    // Disable interrupts during setup
    cli();

    // Debug: write "KERNEL\n" to serial
    serial_out(75);  // K
    serial_out(69);  // E
    serial_out(82);  // R
    serial_out(78);  // N
    serial_out(69);  // E
    serial_out(76);  // L
    serial_newline();

    // Clear screen
    vga_clear();

    let green = vga_color(COLOR_GREEN, COLOR_BLACK);
    let white = vga_color(COLOR_WHITE, COLOR_BLACK);

    // Line 0: "Genesis Kernel v0.0.12"
    vga_write_char(0, 0, 71, green);   // G
    vga_write_char(1, 0, 101, green);  // e
    vga_write_char(2, 0, 110, green);  // n
    vga_write_char(3, 0, 101, green);  // e
    vga_write_char(4, 0, 115, green);  // s
    vga_write_char(5, 0, 105, green);  // i
    vga_write_char(6, 0, 115, green);  // s
    vga_write_char(7, 0, 32, white);   // space
    vga_write_char(8, 0, 75, green);   // K
    vga_write_char(9, 0, 101, green);  // e
    vga_write_char(10, 0, 114, green); // r
    vga_write_char(11, 0, 110, green); // n
    vga_write_char(12, 0, 101, green); // e
    vga_write_char(13, 0, 108, green); // l
    vga_write_char(14, 0, 32, white);  // space
    vga_write_char(15, 0, 118, white); // v
    vga_write_char(16, 0, 48, white);  // 0
    vga_write_char(17, 0, 46, white);  // .
    vga_write_char(18, 0, 48, white);  // 0
    vga_write_char(19, 0, 46, white);  // .
    vga_write_char(20, 0, 49, white);  // 1
    vga_write_char(21, 0, 50, white);  // 2

    serial_out(118); // v
    serial_out(48);  // 0
    serial_out(46);  // .
    serial_out(48);  // 0
    serial_out(46);  // .
    serial_out(49);  // 1
    serial_out(50);  // 2
    serial_newline();

    // Read multiboot info address from 0x500 (stored by boot.asm)
    let mb_info_addr: i64 = read_u32_at(0x500, 0) as i64;
    let mm_ok = init_memory(mb_info_addr);

    // Initialize kernel page table pool early (needed for VBE framebuffer mapping)
    kptpool_init();

    // Initialize kernel heap (64KB initial, expandable to 64MB)
    let heap_ok = init_heap();
    if heap_ok {
        // Test heap with large allocations
        test_heap_allocs();
    }

    // Initialize VBE framebuffer
    let vbe_ok = vbe_init(mb_info_addr);

    // Initialize PS/2 mouse
    mouse_init();

    // Initialize bitmap font for text rendering
    font_init();

    // Run graphics demo if VBE is available
    if vbe_ok {
        hello_graphics_demo();
    }

    // Initialize ATA disk driver
    ata_init();

    // Initialize network stack
    net_init();

    // Early TCP test - this will likely fail but it "wakes up" QEMU's network stack
    // Without this, later network operations fail because QEMU hasn't initialized its network
    test_tcp_connection();

    // Test RSA unit operations
    test_rsa_unit();

    // Test PCI 32-bit port I/O
    test_pci_ports();

    // Test memory operations (L2)
    test_memory_ops();

    // Test volatile operations (L3)
    test_volatile_ops();

    // Test struct operations (L4)
    test_struct_ops();

    // Test array operations (L5)
    test_array_ops();

    // Test enum operations (L6)
    test_enum_ops();

    // Initialize kernel state (creates PID 0 idle process only)
    init_kernel_state();

    // Load GRUB modules into RAMFS (init.elf)
    load_multiboot_modules(mb_info_addr);

    // Execute init process from RAMFS (becomes PID 1)
    let init_pid = exec_init();
    if init_pid >= 0 {
        serial_out(73);  // I
        serial_out(78);  // N
        serial_out(73);  // I
        serial_out(84);  // T
        serial_out(32);  // space
        serial_out(80);  // P
        serial_out(73);  // I
        serial_out(68);  // D
        serial_out(58);  // :
        serial_print_dec(init_pid);
        serial_newline();
    }

    // Phase 4: Init spawns VFS, Console, Shell via exec() syscall
    // Kernel only creates init process, services are spawned by init

    // Initialize kernel capabilities for all services
    init_kernel_services();

    // Initialize interrupts (this enables timer which triggers scheduler)
    init_interrupts();

    // Main loop with halt
    loop {
        hlt();
    }
}
